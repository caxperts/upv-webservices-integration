var CAXperts = (function (exports) {
  'use strict';

  function _mergeNamespaces(n, m) {
    m.forEach(function (e) {
      e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
        if (k !== 'default' && !(k in n)) {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    });
    return Object.freeze(n);
  }

  const loadingbar = (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r);}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
  // Generated by LiveScript 1.3.1
  var presets, wrap, slice$ = [].slice, toString$ = {}.toString;
  presets = require('./presets').presets;
  wrap = function(content){
    return "data:image/svg+xml;base64," + btoa(content);
  };
  (function(){
    var make, handler, ldBar;
    make = {
      head: function(viewBox){
        return "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"" + viewBox + "\">";
      },
      gradient: function(dir, dur){
        var colors, ret, len, gx, gy, x, y, i$, i, idx;
        dir == null && (dir = 45);
        dur == null && (dur = 1);
        colors = slice$.call(arguments, 2);
        ret = [this.head("0 0 100 100")];
        len = colors.length * 4 + 1;
        dir = dir * Math.PI / 180;
        gx = Math.pow(Math.cos(dir), 2);
        gy = Math.sqrt(gx - Math.pow(gx, 2));
        if (dir > Math.PI * 0.25) {
          gy = Math.pow(Math.sin(dir), 2);
          gx = Math.sqrt(gy - Math.pow(gy, 2));
        }
        x = gx * 100;
        y = gy * 100;
        ret.push("<defs><linearGradient id=\"gradient\" x1=\"0\" x2=\"" + gx + "\" y1=\"0\" y2=\"" + gy + "\">");
        for (i$ = 0; i$ < len; ++i$) {
          i = i$;
          idx = i * 100 / (len - 1);
          ret.push("<stop offset=\"" + idx + "%\" stop-color=\"" + colors[i % colors.length] + "\"/>");
        }
        ret.push("</linearGradient></defs>\n<rect x=\"0\" y=\"0\" width=\"400\" height=\"400\" fill=\"url(#gradient)\">\n<animateTransform attributeName=\"transform\" type=\"translate\" from=\"-" + x + ",-" + y + "\"\nto=\"0,0\" dur=\"" + dur + "s\" repeatCount=\"indefinite\"/></rect></svg>");
        return wrap(ret.join(""));
      },
      stripe: function(c1, c2, dur){
        var ret, i;
        c1 == null && (c1 = '#b4b4b4');
        c2 == null && (c2 = '#e6e6e6');
        dur == null && (dur = 1);
        ret = [this.head("0 0 100 100")];
        ret = ret.concat([
          "<rect fill=\"" + c2 + "\" width=\"100\" height=\"100\"/>", "<g><g>", (function(){
            var i$, results$ = [];
            for (i$ = 0; i$ < 13; ++i$) {
              i = i$;
              results$.push(("<polygon fill=\"" + c1 + "\" ") + ("points=\"" + (-90 + i * 20) + ",100 " + (-100 + i * 20) + ",") + ("100 " + (-60 + i * 20) + ",0 " + (-50 + i * 20) + ",0 \"/>"));
            }
            return results$;
          }()).join(""), "</g><animateTransform attributeName=\"transform\" type=\"translate\" ", "from=\"0,0\" to=\"20,0\" dur=\"" + dur + "s\" repeatCount=\"indefinite\"/></g></svg>"
        ].join(""));
        return wrap(ret);
      },
      bubble: function(c1, c2, count, dur, size, sw){
        var ret, i$, i, idx, x, r, d;
        c1 == null && (c1 = '#39d');
        c2 == null && (c2 = '#9cf');
        count == null && (count = 15);
        dur == null && (dur = 1);
        size == null && (size = 6);
        sw == null && (sw = 1);
        ret = [this.head("0 0 200 200"), "<rect x=\"0\" y=\"0\" width=\"200\" height=\"200\" fill=\"" + c1 + "\"/>"];
        for (i$ = 0; i$ < count; ++i$) {
          i = i$;
          idx = -(i / count) * dur;
          x = Math.random() * 184 + 8;
          r = (Math.random() * 0.7 + 0.3) * size;
          d = dur * (1 + Math.random() * 0.5);
          ret.push(["<circle cx=\"" + x + "\" cy=\"0\" r=\"" + r + "\" fill=\"none\" stroke=\"" + c2 + "\" stroke-width=\"" + sw + "\">", "<animate attributeName=\"cy\" values=\"190;-10\" times=\"0;1\" ", "dur=\"" + d + "s\" begin=\"" + idx + "s\" repeatCount=\"indefinite\"/>", "</circle>", "<circle cx=\"" + x + "\" cy=\"0\" r=\"" + r + "\" fill=\"none\" stroke=\"" + c2 + "\" stroke-width=\"" + sw + "\">", "<animate attributeName=\"cy\" values=\"390;190\" times=\"0;1\" ", "dur=\"" + d + "s\" begin=\"" + idx + "s\" repeatCount=\"indefinite\"/>", "</circle>"].join(""));
        }
        return wrap(ret.join("") + "</svg>");
      }
    };
    handler = {
      queue: {},
      running: false,
      main: function(timestamp){
        var keepon, removed, k, ref$, func, ret, this$ = this;
        keepon = false;
        removed = [];
        for (k in ref$ = this.queue) {
          func = ref$[k];
          ret = func(timestamp);
          if (!ret) {
            removed.push(func);
          }
          keepon = keepon || ret;
        }
        for (k in ref$ = this.queue) {
          func = ref$[k];
          if (removed.indexOf(func) >= 0) {
            delete this.queue[k];
          }
        }
        if (keepon) {
          return requestAnimationFrame(function(it){
            return this$.main(it);
          });
        } else {
          return this.running = false;
        }
      },
      add: function(key, f){
        var this$ = this;
        if (!this.queue[key]) {
          this.queue[key] = f;
        }
        if (!this.running) {
          this.running = true;
          return requestAnimationFrame(function(it){
            return this$.main(it);
          });
        }
      }
    };
    window.ldBar = ldBar = function(selector, option){
      var xmlns, root, cls, idPrefix, id, domTree, newNode, x$, config, attr, that, isStroke, parseRes, dom, svg, text, group, length, path0, path1, patimg, img, ret, size, this$ = this;
      option == null && (option = {});
      xmlns = {
        xlink: "http://www.w3.org/1999/xlink"
      };
      root = toString$.call(selector).slice(8, -1) === 'String' ? document.querySelector(selector) : selector;
      if (!root.ldBar) {
        root.ldBar = this;
      } else {
        return root.ldBar;
      }
      cls = root.getAttribute('class') || '';
      if (!~cls.indexOf('ldBar')) {
        root.setAttribute('class', cls + " ldBar");
      }
      idPrefix = "ldBar-" + Math.random().toString(16).substring(2);
      id = {
        key: idPrefix,
        clip: idPrefix + "-clip",
        filter: idPrefix + "-filter",
        pattern: idPrefix + "-pattern",
        mask: idPrefix + "-mask",
        maskPath: idPrefix + "-mask-path"
      };
      domTree = function(n, o){
        var k, v;
        n = newNode(n);
        for (k in o) {
          v = o[k];
          if (k !== 'attr') {
            n.appendChild(domTree(k, v || {}));
          }
        }
        n.attrs(o.attr || {});
        return n;
      };
      newNode = function(n){
        return document.createElementNS("http://www.w3.org/2000/svg", n);
      };
      x$ = document.body.__proto__.__proto__.__proto__;
      x$.text = function(t){
        return this.appendChild(document.createTextNode(t));
      };
      x$.attrs = function(o){
        var k, v, ret, results$ = [];
        for (k in o) {
          v = o[k];
          ret = /([^:]+):([^:]+)/.exec(k);
          if (!ret || !xmlns[ret[1]]) {
            results$.push(this.setAttribute(k, v));
          } else {
            results$.push(this.setAttributeNS(xmlns[ret[1]], k, v));
          }
        }
        return results$;
      };
      x$.styles = function(o){
        var k, v, results$ = [];
        for (k in o) {
          v = o[k];
          results$.push(this.style[k] = v);
        }
        return results$;
      };
      x$.append = function(n){
        return this.appendChild(document.createElementNS("http://www.w3.og/2000/svg", n));
      };
      x$.attr = function(n, v){
        if (v != null) {
          return this.setAttribute(n, v);
        } else {
          return this.getAttribute(n);
        }
      };
      config = {
        "type": 'stroke',
        "img": '',
        "path": 'M10 10L90 10M90 8M90 12',
        "fill-dir": 'btt',
        "fill": '#25b',
        "fill-background": '#ddd',
        "fill-background-extrude": 3,
        "pattern-size": null,
        "stroke-dir": 'normal',
        "stroke": '#25b',
        "stroke-width": '3',
        "stroke-trail": '#ddd',
        "stroke-trail-width": 0.5,
        "duration": 1,
        "easing": 'linear',
        "value": 0,
        "img-size": null,
        "bbox": null,
        "set-dim": true,
        "aspect-ratio": "xMidYMid",
        "transition-in": false,
        "min": 0,
        "max": 100,
        "precision": 0,
        "padding": undefined
      };
      config["preset"] = root.attr("data-preset") || option["preset"];
      if (config.preset != null) {
        import$(config, presets[config.preset]);
      }
      for (attr in config) {
        if (that = that = root.attr("data-" + attr)) {
          config[attr] = that;
        }
      }
      import$(config, option);
      if (config.img) {
        config.path = null;
      }
      isStroke = config.type === 'stroke';
      parseRes = function(v){
        var parser, ret;
        parser = /data:ldbar\/res,([^()]+)\(([^)]+)\)/;
        ret = parser.exec(v);
        if (!ret) {
          return v;
        }
        return ret = make[ret[1]].apply(make, ret[2].split(','));
      };
      config.fill = parseRes(config.fill);
      config.stroke = parseRes(config.stroke);
      if (config["set-dim"] === 'false') {
        config["set-dim"] = false;
      }
      dom = {
        attr: {
          "xmlns:xlink": 'http://www.w3.org/1999/xlink',
          preserveAspectRatio: config["aspect-ratio"],
          width: "100%",
          height: "100%"
        },
        defs: {
          filter: {
            attr: {
              id: id.filter,
              x: -1,
              y: -1,
              width: 3,
              height: 3
            },
            feMorphology: {
              attr: {
                operator: +config["fill-background-extrude"] >= 0 ? 'dilate' : 'erode',
                radius: Math.abs(+config["fill-background-extrude"])
              }
            },
            feColorMatrix: {
              attr: {
                values: '0 0 0 0 1    0 0 0 0 1    0 0 0 0 1    0 0 0 1 0',
                result: "cm"
              }
            }
          },
          mask: {
            attr: {
              id: id.mask
            },
            image: {
              attr: {
                "xlink:href": config.img,
                filter: "url(#" + id.filter + ")",
                x: 0,
                y: 0,
                width: 100,
                height: 100,
                preserveAspectRatio: config["aspect-ratio"]
              }
            }
          },
          g: {
            mask: {
              attr: {
                id: id.maskPath
              },
              path: {
                attr: {
                  d: config.path || "",
                  fill: '#fff',
                  stroke: '#fff',
                  filter: "url(#" + id.filter + ")"
                }
              }
            }
          },
          clipPath: {
            attr: {
              id: id.clip
            },
            rect: {
              attr: {
                'class': 'mask',
                fill: '#000'
              }
            }
          },
          pattern: {
            attr: {
              id: id.pattern,
              patternUnits: 'userSpaceOnUse',
              x: 0,
              y: 0,
              width: 300,
              height: 300
            },
            image: {
              attr: {
                x: 0,
                y: 0,
                width: 300,
                height: 300
              }
            }
          }
        }
      };
      svg = domTree('svg', dom);
      text = document.createElement('div');
      text.setAttribute('class', 'ldBar-label');
      root.appendChild(svg);
      root.appendChild(text);
      group = [0, 0];
      length = 0;
      this.fit = function(){
        var that, box, d, rect;
        if (that = config["bbox"]) {
          box = that.split(' ').map(function(it){
            return +it.trim();
          });
          box = {
            x: box[0],
            y: box[1],
            width: box[2],
            height: box[3]
          };
        } else {
          box = group[1].getBBox();
        }
        if (!box || box.width === 0 || box.height === 0) {
          box = {
            x: 0,
            y: 0,
            width: 100,
            height: 100
          };
        }
        d = Math.max.apply(null, ['stroke-width', 'stroke-trail-width', 'fill-background-extrude'].map(function(it){
          return config[it];
        })) * 1.5;
        if (config["padding"] != null) {
          d = +config["padding"];
        }
        svg.attrs({
          viewBox: [box.x - d, box.y - d, box.width + d * 2, box.height + d * 2].join(" ")
        });
        if (config["set-dim"]) {
          ['width', 'height'].map(function(it){
            if (!root.style[it] || this$.fit[it]) {
              root.style[it] = (box[it] + d * 2) + "px";
              return this$.fit[it] = true;
            }
          });
        }
        rect = group[0].querySelector('rect');
        if (rect) {
          return rect.attrs({
            x: box.x - d,
            y: box.y - d,
            width: box.width + d * 2,
            height: box.height + d * 2
          });
        }
      };
      if (config.path) {
        if (isStroke) {
          group[0] = domTree('g', {
            path: {
              attr: {
                d: config.path,
                fill: 'none',
                'class': 'baseline'
              }
            }
          });
        } else {
          group[0] = domTree('g', {
            rect: {
              attr: {
                x: 0,
                y: 0,
                width: 100,
                height: 100,
                mask: "url(#" + id.maskPath + ")",
                fill: config["fill-background"],
                'class': 'frame'
              }
            }
          });
        }
        svg.appendChild(group[0]);
        group[1] = domTree('g', {
          path: {
            attr: {
              d: config.path,
              'class': isStroke ? 'mainline' : 'solid',
              "clip-path": config.type === 'fill' ? "url(#" + id.clip + ")" : 'none'
            }
          }
        });
        svg.appendChild(group[1]);
        path0 = group[0].querySelector(isStroke ? 'path' : 'rect');
        path1 = group[1].querySelector('path');
        if (isStroke) {
          path1.attrs({
            fill: 'none'
          });
        }
        patimg = svg.querySelector('pattern image');
        img = new Image();
        img.addEventListener('load', function(){
          var box, that;
          box = (that = config["pattern-size"])
            ? {
              width: +that,
              height: +that
            }
            : img.width && img.height
              ? {
                width: img.width,
                height: img.height
              }
              : {
                width: 300,
                height: 300
              };
          svg.querySelector('pattern').attrs({
            width: box.width,
            height: box.height
          });
          return patimg.attrs({
            width: box.width,
            height: box.height
          });
        });
        if (/.+\..+|^data:/.exec(!isStroke
          ? config.fill
          : config.stroke)) {
          img.src = !isStroke
            ? config.fill
            : config.stroke;
          patimg.attrs({
            "xlink:href": img.src
          });
        }
        if (isStroke) {
          path0.attrs({
            stroke: config["stroke-trail"],
            "stroke-width": config["stroke-trail-width"]
          });
          path1.attrs({
            "stroke-width": config["stroke-width"],
            stroke: /.+\..+|^data:/.exec(config.stroke)
              ? "url(#" + id.pattern + ")"
              : config.stroke
          });
        }
        if (config.fill && !isStroke) {
          path1.attrs({
            fill: /.+\..+|^data:/.exec(config.fill)
              ? "url(#" + id.pattern + ")"
              : config.fill
          });
        }
        length = path1.getTotalLength();
        this.fit();
        this.inited = true;
      } else if (config.img) {
        if (config["img-size"]) {
          ret = config["img-size"].split(',');
          size = {
            width: +ret[0],
            height: +ret[1]
          };
        } else {
          size = {
            width: 100,
            height: 100
          };
        }
        group[0] = domTree('g', {
          rect: {
            attr: {
              x: 0,
              y: 0,
              width: 100,
              height: 100,
              mask: "url(#" + id.mask + ")",
              fill: config["fill-background"]
            }
          }
        });
        svg.querySelector('mask image').attrs({
          width: size.width,
          height: size.height
        });
        group[1] = domTree('g', {
          image: {
            attr: {
              width: size.width,
              height: size.height,
              x: 0,
              y: 0,
              preserveAspectRatio: config["aspect-ratio"],
              "clip-path": config.type === 'fill' ? "url(#" + id.clip + ")" : '',
              "xlink:href": config.img,
              'class': 'solid'
            }
          }
        });
        img = new Image();
        img.addEventListener('load', function(){
          var ret, size, v;
          if (config["img-size"]) {
            ret = config["img-size"].split(',');
            size = {
              width: +ret[0],
              height: +ret[1]
            };
          } else if (img.width && img.height) {
            size = {
              width: img.width,
              height: img.height
            };
          } else {
            size = {
              width: 100,
              height: 100
            };
          }
          svg.querySelector('mask image').attrs({
            width: size.width,
            height: size.height
          });
          group[1].querySelector('image').attrs({
            width: size.width,
            height: size.height
          });
          this$.fit();
          v = this$.value;
          this$.value = undefined;
          this$.set(v, true);
          return this$.inited = true;
        });
        img.src = config.img;
        svg.appendChild(group[0]);
        svg.appendChild(group[1]);
      }
      svg.attrs({
        width: '100%',
        height: '100%'
      });
      this.transition = {
        value: {
          src: 0,
          des: 0
        },
        time: {},
        ease: function(t, b, c, d){
          t = t / (d * 0.5);
          if (t < 1) {
            return c * 0.5 * t * t + b;
          }
          t = t - 1;
          return -c * 0.5 * (t * (t - 2) - 1) + b;
        },
        handler: function(time, doTransition){
          var ref$, min, max, prec, dv, dt, dur, v, p, node, style, box, dir;
          doTransition == null && (doTransition = true);
          if (this.time.src == null) {
            this.time.src = time;
          }
          ref$ = [config["min"], config["max"], 1 / config["precision"]], min = ref$[0], max = ref$[1], prec = ref$[2];
          ref$ = [this.value.des - this.value.src, (time - this.time.src) * 0.001, +config["duration"] || 1], dv = ref$[0], dt = ref$[1], dur = ref$[2];
          v = doTransition
            ? this.ease(dt, this.value.src, dv, dur)
            : this.value.des;
          if (config.precision) {
            v = Math.round(v * prec) / prec;
          } else if (doTransition) {
            v = Math.round(v);
          }
          v >= min || (v = min);
          v <= max || (v = max);
          text.textContent = v;
          p = 100.0 * (v - min) / (max - min);
          if (isStroke) {
            node = path1;
            style = {
              "stroke-dasharray": config["stroke-dir"] === 'reverse'
                ? "0 " + length * (100 - p) * 0.01 + " " + length * p * 0.01 + " 0"
                : p * 0.01 * length + " " + ((100 - p) * 0.01 * length + 1)
            };
          } else {
            box = group[1].getBBox();
            dir = config["fill-dir"];
            style = dir === 'btt' || !dir
              ? {
                y: box.y + box.height * (100 - p) * 0.01,
                height: box.height * p * 0.01,
                x: box.x,
                width: box.width
              }
              : dir === 'ttb'
                ? {
                  y: box.y,
                  height: box.height * p * 0.01,
                  x: box.x,
                  width: box.width
                }
                : dir === 'ltr'
                  ? {
                    y: box.y,
                    height: box.height,
                    x: box.x,
                    width: box.width * p * 0.01
                  }
                  : dir === 'rtl' ? {
                    y: box.y,
                    height: box.height,
                    x: box.x + box.width * (100 - p) * 0.01,
                    width: box.width * p * 0.01
                  } : void 8;
            node = svg.querySelector('rect');
          }
          node.attrs(style);
          if (dt >= dur) {
            delete this.time.src;
            return false;
          }
          return true;
        },
        start: function(src, des, doTransition){
          var ref$, this$ = this;
          ref$ = this.value;
          ref$.src = src;
          ref$.des = des;
          !!(root.offsetWidth || root.offsetHeight || root.getClientRects().length);
          if (!doTransition || !(root.offsetWidth || root.offsetHeight || root.getClientRects().length)) {
            this.time.src = 0;
            this.handler(1000, false);
            return;
          }
          return handler.add(id.key, function(time){
            return this$.handler(time);
          });
        }
      };
      this.set = function(v, doTransition){
        var src, des;
        doTransition == null && (doTransition = true);
        src = this.value || 0;
        if (v != null) {
          this.value = v;
        } else {
          v = this.value;
        }
        des = this.value;
        return this.transition.start(src, des, doTransition);
      };
      this.set(+config.value || 0, config["transition-in"]) || false;
      return this;
    };
    return window.addEventListener('load', function(){
      var i$, ref$, len$, node, results$ = [];
      for (i$ = 0, len$ = (ref$ = document.querySelectorAll('.ldBar')).length; i$ < len$; ++i$) {
        node = ref$[i$];
        if (!node.ldBar) {
          results$.push(node.ldBar = new ldBar(node));
        }
      }
      return results$;
    }, false);
  })();
  module.exports = ldBar;
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }

  },{"./presets":2}],2:[function(require,module,exports){
  // Generated by LiveScript 1.3.1
  var out$ = typeof exports != 'undefined' && exports || this;
  out$.presets = {
    rainbow: {
      "type": 'stroke',
      "path": 'M10 10L90 10',
      "stroke": 'data:ldbar/res,gradient(0,1,#a551df,#fd51ad,#ff7f82,#ffb874,#ffeb90)',
      "bbox": "10 10 80 10"
    },
    energy: {
      "type": 'fill',
      "path": 'M15 5L85 5A5 5 0 0 1 85 15L15 15A5 5 0 0 1 15 5',
      "stroke": '#f00',
      "fill": 'data:ldbar/res,gradient(45,2,#4e9,#8fb,#4e9)',
      "fill-dir": "ltr",
      "fill-background": '#444',
      "fill-background-extrude": 1,
      "bbox": "10 5 80 10"
    },
    stripe: {
      "type": 'fill',
      "path": 'M15 5L85 5A5 5 0 0 1 85 15L15 15A5 5 0 0 1 15 5',
      "stroke": '#f00',
      "fill": 'data:ldbar/res,stripe(#25b,#58e,1)',
      "fill-dir": "ltr",
      "fill-background": '#ddd',
      "fill-background-extrude": 1,
      "bbox": "10 5 80 10"
    },
    text: {
      "type": 'fill',
      "img": "data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"70\" height=\"20\" viewBox=\"0 0 70 20\"><text x=\"35\" y=\"10\" text-anchor=\"middle\" dominant-baseline=\"central\" font-family=\"arial\">LOADING</text></svg>",
      "fill-background-extrude": 1.3,
      "pattern-size": 100,
      "fill-dir": "ltr",
      "img-size": "70,20",
      "bbox": "0 0 70 20"
    },
    line: {
      "type": 'stroke',
      "path": 'M10 10L90 10',
      "stroke": '#25b',
      "stroke-width": 3,
      "stroke-trail": '#ddd',
      "stroke-trail-width": 1,
      "bbox": "10 10 80 10"
    },
    fan: {
      "type": 'stroke',
      "path": 'M10 90A40 40 0 0 1 90 90',
      "fill-dir": 'btt',
      "fill": '#25b',
      "fill-background": '#ddd',
      "fill-background-extrude": 3,
      "stroke-dir": 'normal',
      "stroke": '#25b',
      "stroke-width": '3',
      "stroke-trail": '#ddd',
      "stroke-trail-width": 0.5,
      "bbox": "10 50 80 40"
    },
    circle: {
      "type": 'stroke',
      "path": 'M50 10A40 40 0 0 1 50 90A40 40 0 0 1 50 10',
      "fill-dir": 'btt',
      "fill": '#25b',
      "fill-background": '#ddd',
      "fill-background-extrude": 3,
      "stroke-dir": 'normal',
      "stroke": '#25b',
      "stroke-width": '3',
      "stroke-trail": '#ddd',
      "stroke-trail-width": 0.5,
      "bbox": "10 10 80 80"
    },
    bubble: {
      "type": 'fill',
      "path": 'M50 10A40 40 0 0 1 50 90A40 40 0 0 1 50 10',
      "fill-dir": 'btt',
      "fill": 'data:ldbar/res,bubble(#39d,#cef)',
      "pattern-size": "150",
      "fill-background": '#ddd',
      "fill-background-extrude": 2,
      "stroke-dir": 'normal',
      "stroke": '#25b',
      "stroke-width": '3',
      "stroke-trail": '#ddd',
      "stroke-trail-width": 0.5,
      "bbox": "10 10 80 80"
    }
  };

  },{}]},{},[1]);

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */

  let logDisabled_ = true;
  let deprecationWarnings_ = true;

  /**
   * Extract browser version out of the provided user agent string.
   *
   * @param {!string} uastring userAgent string.
   * @param {!string} expr Regular expression used as match criteria.
   * @param {!number} pos position in the version string to be returned.
   * @return {!number} browser version.
   */
  function extractVersion(uastring, expr, pos) {
    const match = uastring.match(expr);
    return match && match.length >= pos && parseInt(match[pos], 10);
  }

  // Wraps the peerconnection event eventNameToWrap in a function
  // which returns the modified event object (or false to prevent
  // the event).
  function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
    if (!window.RTCPeerConnection) {
      return;
    }
    const proto = window.RTCPeerConnection.prototype;
    const nativeAddEventListener = proto.addEventListener;
    proto.addEventListener = function(nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap) {
        return nativeAddEventListener.apply(this, arguments);
      }
      const wrappedCallback = (e) => {
        const modifiedEvent = wrapper(e);
        if (modifiedEvent) {
          if (cb.handleEvent) {
            cb.handleEvent(modifiedEvent);
          } else {
            cb(modifiedEvent);
          }
        }
      };
      this._eventMap = this._eventMap || {};
      if (!this._eventMap[eventNameToWrap]) {
        this._eventMap[eventNameToWrap] = new Map();
      }
      this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
      return nativeAddEventListener.apply(this, [nativeEventName,
        wrappedCallback]);
    };

    const nativeRemoveEventListener = proto.removeEventListener;
    proto.removeEventListener = function(nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap || !this._eventMap
          || !this._eventMap[eventNameToWrap]) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      if (!this._eventMap[eventNameToWrap].has(cb)) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
      this._eventMap[eventNameToWrap].delete(cb);
      if (this._eventMap[eventNameToWrap].size === 0) {
        delete this._eventMap[eventNameToWrap];
      }
      if (Object.keys(this._eventMap).length === 0) {
        delete this._eventMap;
      }
      return nativeRemoveEventListener.apply(this, [nativeEventName,
        unwrappedCb]);
    };

    Object.defineProperty(proto, 'on' + eventNameToWrap, {
      get() {
        return this['_on' + eventNameToWrap];
      },
      set(cb) {
        if (this['_on' + eventNameToWrap]) {
          this.removeEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap]);
          delete this['_on' + eventNameToWrap];
        }
        if (cb) {
          this.addEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap] = cb);
        }
      },
      enumerable: true,
      configurable: true
    });
  }

  function disableLog(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return (bool) ? 'adapter.js logging disabled' :
      'adapter.js logging enabled';
  }

  /**
   * Disable or enable deprecation warnings
   * @param {!boolean} bool set to true to disable warnings.
   */
  function disableWarnings(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    deprecationWarnings_ = !bool;
    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
  }

  function log() {
    if (typeof window === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  }

  /**
   * Shows a deprecation warning suggesting the modern and spec-compatible API.
   */
  function deprecated(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +
        ' instead.');
  }

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  function detectBrowser(window) {
    // Returned result object.
    const result = {browser: null, version: null};

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator ||
        !window.navigator.userAgent) {
      result.browser = 'Not a browser.';
      return result;
    }

    const {navigator} = window;

    // Prefer navigator.userAgentData.
    if (navigator.userAgentData && navigator.userAgentData.brands) {
      const chromium = navigator.userAgentData.brands.find((brand) => {
        return brand.brand === 'Chromium';
      });
      if (chromium) {
        return {browser: 'chrome', version: parseInt(chromium.version, 10)};
      }
    }

    if (navigator.mozGetUserMedia) { // Firefox.
      result.browser = 'firefox';
      result.version = extractVersion(navigator.userAgent,
        /Firefox\/(\d+)\./, 1);
    } else if (navigator.webkitGetUserMedia ||
        (window.isSecureContext === false && window.webkitRTCPeerConnection)) {
      // Chrome, Chromium, Webview, Opera.
      // Version matches Chrome/WebRTC version.
      // Chrome 74 removed webkitGetUserMedia on http as well so we need the
      // more complicated fallback to webkitRTCPeerConnection.
      result.browser = 'chrome';
      result.version = extractVersion(navigator.userAgent,
        /Chrom(e|ium)\/(\d+)\./, 2);
    } else if (window.RTCPeerConnection &&
        navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) { // Safari.
      result.browser = 'safari';
      result.version = extractVersion(navigator.userAgent,
        /AppleWebKit\/(\d+)\./, 1);
      result.supportsUnifiedPlan = window.RTCRtpTransceiver &&
          'currentDirection' in window.RTCRtpTransceiver.prototype;
    } else { // Default fallthrough: not supported.
      result.browser = 'Not a supported browser.';
      return result;
    }

    return result;
  }

  /**
   * Checks if something is an object.
   *
   * @param {*} val The something you want to check.
   * @return true if val is an object, false otherwise.
   */
  function isObject(val) {
    return Object.prototype.toString.call(val) === '[object Object]';
  }

  /**
   * Remove all empty objects and undefined values
   * from a nested object -- an enhanced and vanilla version
   * of Lodash's `compact`.
   */
  function compactObject(data) {
    if (!isObject(data)) {
      return data;
    }

    return Object.keys(data).reduce(function(accumulator, key) {
      const isObj = isObject(data[key]);
      const value = isObj ? compactObject(data[key]) : data[key];
      const isEmptyObject = isObj && !Object.keys(value).length;
      if (value === undefined || isEmptyObject) {
        return accumulator;
      }
      return Object.assign(accumulator, {[key]: value});
    }, {});
  }

  /* iterates the stats graph recursively. */
  function walkStats(stats, base, resultSet) {
    if (!base || resultSet.has(base.id)) {
      return;
    }
    resultSet.set(base.id, base);
    Object.keys(base).forEach(name => {
      if (name.endsWith('Id')) {
        walkStats(stats, stats.get(base[name]), resultSet);
      } else if (name.endsWith('Ids')) {
        base[name].forEach(id => {
          walkStats(stats, stats.get(id), resultSet);
        });
      }
    });
  }

  /* filter getStats for a sender/receiver track. */
  function filterStats(result, track, outbound) {
    const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
    const filteredResult = new Map();
    if (track === null) {
      return filteredResult;
    }
    const trackStats = [];
    result.forEach(value => {
      if (value.type === 'track' &&
          value.trackIdentifier === track.id) {
        trackStats.push(value);
      }
    });
    trackStats.forEach(trackStat => {
      result.forEach(stats => {
        if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
          walkStats(result, stats, filteredResult);
        }
      });
    });
    return filteredResult;
  }

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  const logging = log;

  function shimGetUserMedia$2(window, browserDetails) {
    const navigator = window && window.navigator;

    if (!navigator.mediaDevices) {
      return;
    }

    const constraintsToChrome_ = function(c) {
      if (typeof c !== 'object' || c.mandatory || c.optional) {
        return c;
      }
      const cc = {};
      Object.keys(c).forEach(key => {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        const r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
        if (r.exact !== undefined && typeof r.exact === 'number') {
          r.min = r.max = r.exact;
        }
        const oldname_ = function(prefix, name) {
          if (prefix) {
            return prefix + name.charAt(0).toUpperCase() + name.slice(1);
          }
          return (name === 'deviceId') ? 'sourceId' : name;
        };
        if (r.ideal !== undefined) {
          cc.optional = cc.optional || [];
          let oc = {};
          if (typeof r.ideal === 'number') {
            oc[oldname_('min', key)] = r.ideal;
            cc.optional.push(oc);
            oc = {};
            oc[oldname_('max', key)] = r.ideal;
            cc.optional.push(oc);
          } else {
            oc[oldname_('', key)] = r.ideal;
            cc.optional.push(oc);
          }
        }
        if (r.exact !== undefined && typeof r.exact !== 'number') {
          cc.mandatory = cc.mandatory || {};
          cc.mandatory[oldname_('', key)] = r.exact;
        } else {
          ['min', 'max'].forEach(mix => {
            if (r[mix] !== undefined) {
              cc.mandatory = cc.mandatory || {};
              cc.mandatory[oldname_(mix, key)] = r[mix];
            }
          });
        }
      });
      if (c.advanced) {
        cc.optional = (cc.optional || []).concat(c.advanced);
      }
      return cc;
    };

    const shimConstraints_ = function(constraints, func) {
      if (browserDetails.version >= 61) {
        return func(constraints);
      }
      constraints = JSON.parse(JSON.stringify(constraints));
      if (constraints && typeof constraints.audio === 'object') {
        const remap = function(obj, a, b) {
          if (a in obj && !(b in obj)) {
            obj[b] = obj[a];
            delete obj[a];
          }
        };
        constraints = JSON.parse(JSON.stringify(constraints));
        remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
        remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
        constraints.audio = constraintsToChrome_(constraints.audio);
      }
      if (constraints && typeof constraints.video === 'object') {
        // Shim facingMode for mobile & surface pro.
        let face = constraints.video.facingMode;
        face = face && ((typeof face === 'object') ? face : {ideal: face});
        const getSupportedFacingModeLies = browserDetails.version < 66;

        if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                      face.ideal === 'user' || face.ideal === 'environment')) &&
            !(navigator.mediaDevices.getSupportedConstraints &&
              navigator.mediaDevices.getSupportedConstraints().facingMode &&
              !getSupportedFacingModeLies)) {
          delete constraints.video.facingMode;
          let matches;
          if (face.exact === 'environment' || face.ideal === 'environment') {
            matches = ['back', 'rear'];
          } else if (face.exact === 'user' || face.ideal === 'user') {
            matches = ['front'];
          }
          if (matches) {
            // Look for matches in label, or use last cam for back (typical).
            return navigator.mediaDevices.enumerateDevices()
              .then(devices => {
                devices = devices.filter(d => d.kind === 'videoinput');
                let dev = devices.find(d => matches.some(match =>
                  d.label.toLowerCase().includes(match)));
                if (!dev && devices.length && matches.includes('back')) {
                  dev = devices[devices.length - 1]; // more likely the back cam
                }
                if (dev) {
                  constraints.video.deviceId = face.exact
                    ? {exact: dev.deviceId}
                    : {ideal: dev.deviceId};
                }
                constraints.video = constraintsToChrome_(constraints.video);
                logging('chrome: ' + JSON.stringify(constraints));
                return func(constraints);
              });
          }
        }
        constraints.video = constraintsToChrome_(constraints.video);
      }
      logging('chrome: ' + JSON.stringify(constraints));
      return func(constraints);
    };

    const shimError_ = function(e) {
      if (browserDetails.version >= 64) {
        return e;
      }
      return {
        name: {
          PermissionDeniedError: 'NotAllowedError',
          PermissionDismissedError: 'NotAllowedError',
          InvalidStateError: 'NotAllowedError',
          DevicesNotFoundError: 'NotFoundError',
          ConstraintNotSatisfiedError: 'OverconstrainedError',
          TrackStartError: 'NotReadableError',
          MediaDeviceFailedDueToShutdown: 'NotAllowedError',
          MediaDeviceKillSwitchOn: 'NotAllowedError',
          TabCaptureError: 'AbortError',
          ScreenCaptureError: 'AbortError',
          DeviceCaptureError: 'AbortError'
        }[e.name] || e.name,
        message: e.message,
        constraint: e.constraint || e.constraintName,
        toString() {
          return this.name + (this.message && ': ') + this.message;
        }
      };
    };

    const getUserMedia_ = function(constraints, onSuccess, onError) {
      shimConstraints_(constraints, c => {
        navigator.webkitGetUserMedia(c, onSuccess, e => {
          if (onError) {
            onError(shimError_(e));
          }
        });
      });
    };
    navigator.getUserMedia = getUserMedia_.bind(navigator);

    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    if (navigator.mediaDevices.getUserMedia) {
      const origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
      navigator.mediaDevices.getUserMedia = function(cs) {
        return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {
          if (c.audio && !stream.getAudioTracks().length ||
              c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(track => {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, e => Promise.reject(shimError_(e))));
      };
    }
  }

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */

  function shimMediaStream(window) {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  }

  function shimOnTrack$1(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get() {
          return this._ontrack;
        },
        set(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
          }
          this.addEventListener('track', this._ontrack = f);
        },
        enumerable: true,
        configurable: true
      });
      const origSetRemoteDescription =
          window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription =
        function setRemoteDescription() {
          if (!this._ontrackpoly) {
            this._ontrackpoly = (e) => {
              // onaddstream does not fire when a track is added to an existing
              // stream. But stream.onaddtrack is implemented so we use that.
              e.stream.addEventListener('addtrack', te => {
                let receiver;
                if (window.RTCPeerConnection.prototype.getReceivers) {
                  receiver = this.getReceivers()
                    .find(r => r.track && r.track.id === te.track.id);
                } else {
                  receiver = {track: te.track};
                }

                const event = new Event('track');
                event.track = te.track;
                event.receiver = receiver;
                event.transceiver = {receiver};
                event.streams = [e.stream];
                this.dispatchEvent(event);
              });
              e.stream.getTracks().forEach(track => {
                let receiver;
                if (window.RTCPeerConnection.prototype.getReceivers) {
                  receiver = this.getReceivers()
                    .find(r => r.track && r.track.id === track.id);
                } else {
                  receiver = {track};
                }
                const event = new Event('track');
                event.track = track;
                event.receiver = receiver;
                event.transceiver = {receiver};
                event.streams = [e.stream];
                this.dispatchEvent(event);
              });
            };
            this.addEventListener('addstream', this._ontrackpoly);
          }
          return origSetRemoteDescription.apply(this, arguments);
        };
    } else {
      // even if RTCRtpTransceiver is in window, it is only used and
      // emitted in unified-plan. Unfortunately this means we need
      // to unconditionally wrap the event.
      wrapPeerConnectionEvent(window, 'track', e => {
        if (!e.transceiver) {
          Object.defineProperty(e, 'transceiver',
            {value: {receiver: e.receiver}});
        }
        return e;
      });
    }
  }

  function shimGetSendersWithDtmf(window) {
    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
    if (typeof window === 'object' && window.RTCPeerConnection &&
        !('getSenders' in window.RTCPeerConnection.prototype) &&
        'createDTMFSender' in window.RTCPeerConnection.prototype) {
      const shimSenderWithDtmf = function(pc, track) {
        return {
          track,
          get dtmf() {
            if (this._dtmf === undefined) {
              if (track.kind === 'audio') {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };

      // augment addTrack when getSenders is not available.
      if (!window.RTCPeerConnection.prototype.getSenders) {
        window.RTCPeerConnection.prototype.getSenders = function getSenders() {
          this._senders = this._senders || [];
          return this._senders.slice(); // return a copy of the internal state.
        };
        const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        window.RTCPeerConnection.prototype.addTrack =
          function addTrack(track, stream) {
            let sender = origAddTrack.apply(this, arguments);
            if (!sender) {
              sender = shimSenderWithDtmf(this, track);
              this._senders.push(sender);
            }
            return sender;
          };

        const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
        window.RTCPeerConnection.prototype.removeTrack =
          function removeTrack(sender) {
            origRemoveTrack.apply(this, arguments);
            const idx = this._senders.indexOf(sender);
            if (idx !== -1) {
              this._senders.splice(idx, 1);
            }
          };
      }
      const origAddStream = window.RTCPeerConnection.prototype.addStream;
      window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
        this._senders = this._senders || [];
        origAddStream.apply(this, [stream]);
        stream.getTracks().forEach(track => {
          this._senders.push(shimSenderWithDtmf(this, track));
        });
      };

      const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
      window.RTCPeerConnection.prototype.removeStream =
        function removeStream(stream) {
          this._senders = this._senders || [];
          origRemoveStream.apply(this, [stream]);

          stream.getTracks().forEach(track => {
            const sender = this._senders.find(s => s.track === track);
            if (sender) { // remove sender
              this._senders.splice(this._senders.indexOf(sender), 1);
            }
          });
        };
    } else if (typeof window === 'object' && window.RTCPeerConnection &&
               'getSenders' in window.RTCPeerConnection.prototype &&
               'createDTMFSender' in window.RTCPeerConnection.prototype &&
               window.RTCRtpSender &&
               !('dtmf' in window.RTCRtpSender.prototype)) {
      const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach(sender => sender._pc = this);
        return senders;
      };

      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  }

  function shimSenderReceiverGetStats(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender && window.RTCRtpReceiver)) {
      return;
    }

    // shim sender stats.
    if (!('getStats' in window.RTCRtpSender.prototype)) {
      const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      if (origGetSenders) {
        window.RTCPeerConnection.prototype.getSenders = function getSenders() {
          const senders = origGetSenders.apply(this, []);
          senders.forEach(sender => sender._pc = this);
          return senders;
        };
      }

      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      if (origAddTrack) {
        window.RTCPeerConnection.prototype.addTrack = function addTrack() {
          const sender = origAddTrack.apply(this, arguments);
          sender._pc = this;
          return sender;
        };
      }
      window.RTCRtpSender.prototype.getStats = function getStats() {
        const sender = this;
        return this._pc.getStats().then(result =>
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          filterStats(result, sender.track, true));
      };
    }

    // shim receiver stats.
    if (!('getStats' in window.RTCRtpReceiver.prototype)) {
      const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
      if (origGetReceivers) {
        window.RTCPeerConnection.prototype.getReceivers =
          function getReceivers() {
            const receivers = origGetReceivers.apply(this, []);
            receivers.forEach(receiver => receiver._pc = this);
            return receivers;
          };
      }
      wrapPeerConnectionEvent(window, 'track', e => {
        e.receiver._pc = e.srcElement;
        return e;
      });
      window.RTCRtpReceiver.prototype.getStats = function getStats() {
        const receiver = this;
        return this._pc.getStats().then(result =>
          filterStats(result, receiver.track, false));
      };
    }

    if (!('getStats' in window.RTCRtpSender.prototype &&
        'getStats' in window.RTCRtpReceiver.prototype)) {
      return;
    }

    // shim RTCPeerConnection.getStats(track).
    const origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function getStats() {
      if (arguments.length > 0 &&
          arguments[0] instanceof window.MediaStreamTrack) {
        const track = arguments[0];
        let sender;
        let receiver;
        let err;
        this.getSenders().forEach(s => {
          if (s.track === track) {
            if (sender) {
              err = true;
            } else {
              sender = s;
            }
          }
        });
        this.getReceivers().forEach(r => {
          if (r.track === track) {
            if (receiver) {
              err = true;
            } else {
              receiver = r;
            }
          }
          return r.track === track;
        });
        if (err || (sender && receiver)) {
          return Promise.reject(new DOMException(
            'There are more than one sender or receiver for the track.',
            'InvalidAccessError'));
        } else if (sender) {
          return sender.getStats();
        } else if (receiver) {
          return receiver.getStats();
        }
        return Promise.reject(new DOMException(
          'There is no sender or receiver for the track.',
          'InvalidAccessError'));
      }
      return origGetStats.apply(this, arguments);
    };
  }

  function shimAddTrackRemoveTrackWithNative(window) {
    // shim addTrack/removeTrack with native variants in order to make
    // the interactions with legacy getLocalStreams behave as in other browsers.
    // Keeps a mapping stream.id => [stream, rtpsenders...]
    window.RTCPeerConnection.prototype.getLocalStreams =
      function getLocalStreams() {
        this._shimmedLocalStreams = this._shimmedLocalStreams || {};
        return Object.keys(this._shimmedLocalStreams)
          .map(streamId => this._shimmedLocalStreams[streamId][0]);
      };

    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addTrack =
      function addTrack(track, stream) {
        if (!stream) {
          return origAddTrack.apply(this, arguments);
        }
        this._shimmedLocalStreams = this._shimmedLocalStreams || {};

        const sender = origAddTrack.apply(this, arguments);
        if (!this._shimmedLocalStreams[stream.id]) {
          this._shimmedLocalStreams[stream.id] = [stream, sender];
        } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
          this._shimmedLocalStreams[stream.id].push(sender);
        }
        return sender;
      };

    const origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      stream.getTracks().forEach(track => {
        const alreadyExists = this.getSenders().find(s => s.track === track);
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
            'InvalidAccessError');
        }
      });
      const existingSenders = this.getSenders();
      origAddStream.apply(this, arguments);
      const newSenders = this.getSenders()
        .filter(newSender => existingSenders.indexOf(newSender) === -1);
      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
    };

    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream =
      function removeStream(stream) {
        this._shimmedLocalStreams = this._shimmedLocalStreams || {};
        delete this._shimmedLocalStreams[stream.id];
        return origRemoveStream.apply(this, arguments);
      };

    const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
    window.RTCPeerConnection.prototype.removeTrack =
      function removeTrack(sender) {
        this._shimmedLocalStreams = this._shimmedLocalStreams || {};
        if (sender) {
          Object.keys(this._shimmedLocalStreams).forEach(streamId => {
            const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
            if (idx !== -1) {
              this._shimmedLocalStreams[streamId].splice(idx, 1);
            }
            if (this._shimmedLocalStreams[streamId].length === 1) {
              delete this._shimmedLocalStreams[streamId];
            }
          });
        }
        return origRemoveTrack.apply(this, arguments);
      };
  }

  function shimAddTrackRemoveTrack(window, browserDetails) {
    if (!window.RTCPeerConnection) {
      return;
    }
    // shim addTrack and removeTrack.
    if (window.RTCPeerConnection.prototype.addTrack &&
        browserDetails.version >= 65) {
      return shimAddTrackRemoveTrackWithNative(window);
    }

    // also shim pc.getLocalStreams when addTrack is shimmed
    // to return the original streams.
    const origGetLocalStreams = window.RTCPeerConnection.prototype
      .getLocalStreams;
    window.RTCPeerConnection.prototype.getLocalStreams =
      function getLocalStreams() {
        const nativeStreams = origGetLocalStreams.apply(this);
        this._reverseStreams = this._reverseStreams || {};
        return nativeStreams.map(stream => this._reverseStreams[stream.id]);
      };

    const origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};

      stream.getTracks().forEach(track => {
        const alreadyExists = this.getSenders().find(s => s.track === track);
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
            'InvalidAccessError');
        }
      });
      // Add identity mapping for consistency with addTrack.
      // Unless this is being used with a stream from addTrack.
      if (!this._reverseStreams[stream.id]) {
        const newStream = new window.MediaStream(stream.getTracks());
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(this, [stream]);
    };

    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream =
      function removeStream(stream) {
        this._streams = this._streams || {};
        this._reverseStreams = this._reverseStreams || {};

        origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);
        delete this._reverseStreams[(this._streams[stream.id] ?
          this._streams[stream.id].id : stream.id)];
        delete this._streams[stream.id];
      };

    window.RTCPeerConnection.prototype.addTrack =
      function addTrack(track, stream) {
        if (this.signalingState === 'closed') {
          throw new DOMException(
            'The RTCPeerConnection\'s signalingState is \'closed\'.',
            'InvalidStateError');
        }
        const streams = [].slice.call(arguments, 1);
        if (streams.length !== 1 ||
            !streams[0].getTracks().find(t => t === track)) {
          // this is not fully correct but all we can manage without
          // [[associated MediaStreams]] internal slot.
          throw new DOMException(
            'The adapter.js addTrack polyfill only supports a single ' +
            ' stream which is associated with the specified track.',
            'NotSupportedError');
        }

        const alreadyExists = this.getSenders().find(s => s.track === track);
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
            'InvalidAccessError');
        }

        this._streams = this._streams || {};
        this._reverseStreams = this._reverseStreams || {};
        const oldStream = this._streams[stream.id];
        if (oldStream) {
          // this is using odd Chrome behaviour, use with caution:
          // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
          // Note: we rely on the high-level addTrack/dtmf shim to
          // create the sender with a dtmf sender.
          oldStream.addTrack(track);

          // Trigger ONN async.
          Promise.resolve().then(() => {
            this.dispatchEvent(new Event('negotiationneeded'));
          });
        } else {
          const newStream = new window.MediaStream([track]);
          this._streams[stream.id] = newStream;
          this._reverseStreams[newStream.id] = stream;
          this.addStream(newStream);
        }
        return this.getSenders().find(s => s.track === track);
      };

    // replace the internal stream id with the external one and
    // vice versa.
    function replaceInternalStreamId(pc, description) {
      let sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(internalId => {
        const externalStream = pc._reverseStreams[internalId];
        const internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(internalStream.id, 'g'),
          externalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp
      });
    }
    function replaceExternalStreamId(pc, description) {
      let sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(internalId => {
        const externalStream = pc._reverseStreams[internalId];
        const internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(externalStream.id, 'g'),
          internalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp
      });
    }
    ['createOffer', 'createAnswer'].forEach(function(method) {
      const nativeMethod = window.RTCPeerConnection.prototype[method];
      const methodObj = {[method]() {
        const args = arguments;
        const isLegacyCall = arguments.length &&
            typeof arguments[0] === 'function';
        if (isLegacyCall) {
          return nativeMethod.apply(this, [
            (description) => {
              const desc = replaceInternalStreamId(this, description);
              args[0].apply(null, [desc]);
            },
            (err) => {
              if (args[1]) {
                args[1].apply(null, err);
              }
            }, arguments[2]
          ]);
        }
        return nativeMethod.apply(this, arguments)
          .then(description => replaceInternalStreamId(this, description));
      }};
      window.RTCPeerConnection.prototype[method] = methodObj[method];
    });

    const origSetLocalDescription =
        window.RTCPeerConnection.prototype.setLocalDescription;
    window.RTCPeerConnection.prototype.setLocalDescription =
      function setLocalDescription() {
        if (!arguments.length || !arguments[0].type) {
          return origSetLocalDescription.apply(this, arguments);
        }
        arguments[0] = replaceExternalStreamId(this, arguments[0]);
        return origSetLocalDescription.apply(this, arguments);
      };

    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

    const origLocalDescription = Object.getOwnPropertyDescriptor(
      window.RTCPeerConnection.prototype, 'localDescription');
    Object.defineProperty(window.RTCPeerConnection.prototype,
      'localDescription', {
        get() {
          const description = origLocalDescription.get.apply(this);
          if (description.type === '') {
            return description;
          }
          return replaceInternalStreamId(this, description);
        }
      });

    window.RTCPeerConnection.prototype.removeTrack =
      function removeTrack(sender) {
        if (this.signalingState === 'closed') {
          throw new DOMException(
            'The RTCPeerConnection\'s signalingState is \'closed\'.',
            'InvalidStateError');
        }
        // We can not yet check for sender instanceof RTCRtpSender
        // since we shim RTPSender. So we check if sender._pc is set.
        if (!sender._pc) {
          throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +
              'does not implement interface RTCRtpSender.', 'TypeError');
        }
        const isLocal = sender._pc === this;
        if (!isLocal) {
          throw new DOMException('Sender was not created by this connection.',
            'InvalidAccessError');
        }

        // Search for the native stream the senders track belongs to.
        this._streams = this._streams || {};
        let stream;
        Object.keys(this._streams).forEach(streamid => {
          const hasTrack = this._streams[streamid].getTracks()
            .find(track => sender.track === track);
          if (hasTrack) {
            stream = this._streams[streamid];
          }
        });

        if (stream) {
          if (stream.getTracks().length === 1) {
            // if this is the last track of the stream, remove the stream. This
            // takes care of any shimmed _senders.
            this.removeStream(this._reverseStreams[stream.id]);
          } else {
            // relying on the same odd chrome behaviour as above.
            stream.removeTrack(sender.track);
          }
          this.dispatchEvent(new Event('negotiationneeded'));
        }
      };
  }

  function shimPeerConnection$1(window, browserDetails) {
    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
      // very basic support for old versions.
      window.RTCPeerConnection = window.webkitRTCPeerConnection;
    }
    if (!window.RTCPeerConnection) {
      return;
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    if (browserDetails.version < 53) {
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          const nativeMethod = window.RTCPeerConnection.prototype[method];
          const methodObj = {[method]() {
            arguments[0] = new ((method === 'addIceCandidate') ?
              window.RTCIceCandidate :
              window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          }};
          window.RTCPeerConnection.prototype[method] = methodObj[method];
        });
    }
  }

  // Attempt to fix ONN in plan-b mode.
  function fixNegotiationNeeded(window, browserDetails) {
    wrapPeerConnectionEvent(window, 'negotiationneeded', e => {
      const pc = e.target;
      if (browserDetails.version < 72 || (pc.getConfiguration &&
          pc.getConfiguration().sdpSemantics === 'plan-b')) {
        if (pc.signalingState !== 'stable') {
          return;
        }
      }
      return e;
    });
  }

  var chromeShim = /*#__PURE__*/Object.freeze({
    __proto__: null,
    fixNegotiationNeeded: fixNegotiationNeeded,
    shimAddTrackRemoveTrack: shimAddTrackRemoveTrack,
    shimAddTrackRemoveTrackWithNative: shimAddTrackRemoveTrackWithNative,
    shimGetSendersWithDtmf: shimGetSendersWithDtmf,
    shimGetUserMedia: shimGetUserMedia$2,
    shimMediaStream: shimMediaStream,
    shimOnTrack: shimOnTrack$1,
    shimPeerConnection: shimPeerConnection$1,
    shimSenderReceiverGetStats: shimSenderReceiverGetStats
  });

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */

  function shimGetUserMedia$1(window, browserDetails) {
    const navigator = window && window.navigator;
    const MediaStreamTrack = window && window.MediaStreamTrack;

    navigator.getUserMedia = function(constraints, onSuccess, onError) {
      // Replace Firefox 44+'s deprecation warning with unprefixed version.
      deprecated('navigator.getUserMedia',
        'navigator.mediaDevices.getUserMedia');
      navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
    };

    if (!(browserDetails.version > 55 &&
        'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
      const remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };

      const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
      navigator.mediaDevices.getUserMedia = function(c) {
        if (typeof c === 'object' && typeof c.audio === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
          remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeGetUserMedia(c);
      };

      if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
        const nativeGetSettings = MediaStreamTrack.prototype.getSettings;
        MediaStreamTrack.prototype.getSettings = function() {
          const obj = nativeGetSettings.apply(this, arguments);
          remap(obj, 'mozAutoGainControl', 'autoGainControl');
          remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
          return obj;
        };
      }

      if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
        const nativeApplyConstraints =
          MediaStreamTrack.prototype.applyConstraints;
        MediaStreamTrack.prototype.applyConstraints = function(c) {
          if (this.kind === 'audio' && typeof c === 'object') {
            c = JSON.parse(JSON.stringify(c));
            remap(c, 'autoGainControl', 'mozAutoGainControl');
            remap(c, 'noiseSuppression', 'mozNoiseSuppression');
          }
          return nativeApplyConstraints.apply(this, [c]);
        };
      }
    }
  }

  /*
   *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */

  function shimGetDisplayMedia(window, preferredMediaSource) {
    if (window.navigator.mediaDevices &&
      'getDisplayMedia' in window.navigator.mediaDevices) {
      return;
    }
    if (!(window.navigator.mediaDevices)) {
      return;
    }
    window.navigator.mediaDevices.getDisplayMedia =
      function getDisplayMedia(constraints) {
        if (!(constraints && constraints.video)) {
          const err = new DOMException('getDisplayMedia without video ' +
              'constraints is undefined');
          err.name = 'NotFoundError';
          // from https://heycam.github.io/webidl/#idl-DOMException-error-names
          err.code = 8;
          return Promise.reject(err);
        }
        if (constraints.video === true) {
          constraints.video = {mediaSource: preferredMediaSource};
        } else {
          constraints.video.mediaSource = preferredMediaSource;
        }
        return window.navigator.mediaDevices.getUserMedia(constraints);
      };
  }

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */

  function shimOnTrack(window) {
    if (typeof window === 'object' && window.RTCTrackEvent &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        !('transceiver' in window.RTCTrackEvent.prototype)) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get() {
          return {receiver: this.receiver};
        }
      });
    }
  }

  function shimPeerConnection(window, browserDetails) {
    if (typeof window !== 'object' ||
        !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
      // very basic support for old versions.
      window.RTCPeerConnection = window.mozRTCPeerConnection;
    }

    if (browserDetails.version < 53) {
      // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          const nativeMethod = window.RTCPeerConnection.prototype[method];
          const methodObj = {[method]() {
            arguments[0] = new ((method === 'addIceCandidate') ?
              window.RTCIceCandidate :
              window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          }};
          window.RTCPeerConnection.prototype[method] = methodObj[method];
        });
    }

    const modernStatsTypes = {
      inboundrtp: 'inbound-rtp',
      outboundrtp: 'outbound-rtp',
      candidatepair: 'candidate-pair',
      localcandidate: 'local-candidate',
      remotecandidate: 'remote-candidate'
    };

    const nativeGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function getStats() {
      const [selector, onSucc, onErr] = arguments;
      return nativeGetStats.apply(this, [selector || null])
        .then(stats => {
          if (browserDetails.version < 53 && !onSucc) {
            // Shim only promise getStats with spec-hyphens in type names
            // Leave callback version alone; misc old uses of forEach before Map
            try {
              stats.forEach(stat => {
                stat.type = modernStatsTypes[stat.type] || stat.type;
              });
            } catch (e) {
              if (e.name !== 'TypeError') {
                throw e;
              }
              // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
              stats.forEach((stat, i) => {
                stats.set(i, Object.assign({}, stat, {
                  type: modernStatsTypes[stat.type] || stat.type
                }));
              });
            }
          }
          return stats;
        })
        .then(onSucc, onErr);
    };
  }

  function shimSenderGetStats(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
      return;
    }
    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach(sender => sender._pc = this);
        return senders;
      };
    }

    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function getStats() {
      return this.track ? this._pc.getStats(this.track) :
        Promise.resolve(new Map());
    };
  }

  function shimReceiverGetStats(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
      return;
    }
    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        const receivers = origGetReceivers.apply(this, []);
        receivers.forEach(receiver => receiver._pc = this);
        return receivers;
      };
    }
    wrapPeerConnectionEvent(window, 'track', e => {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function getStats() {
      return this._pc.getStats(this.track);
    };
  }

  function shimRemoveStream(window) {
    if (!window.RTCPeerConnection ||
        'removeStream' in window.RTCPeerConnection.prototype) {
      return;
    }
    window.RTCPeerConnection.prototype.removeStream =
      function removeStream(stream) {
        deprecated('removeStream', 'removeTrack');
        this.getSenders().forEach(sender => {
          if (sender.track && stream.getTracks().includes(sender.track)) {
            this.removeTrack(sender);
          }
        });
      };
  }

  function shimRTCDataChannel(window) {
    // rename DataChannel to RTCDataChannel (native fix in FF60):
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
    if (window.DataChannel && !window.RTCDataChannel) {
      window.RTCDataChannel = window.DataChannel;
    }
  }

  function shimAddTransceiver(window) {
    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
    // Firefox ignores the init sendEncodings options passed to addTransceiver
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
    if (!(typeof window === 'object' && window.RTCPeerConnection)) {
      return;
    }
    const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;
    if (origAddTransceiver) {
      window.RTCPeerConnection.prototype.addTransceiver =
        function addTransceiver() {
          this.setParametersPromises = [];
          // WebIDL input coercion and validation
          let sendEncodings = arguments[1] && arguments[1].sendEncodings;
          if (sendEncodings === undefined) {
            sendEncodings = [];
          }
          sendEncodings = [...sendEncodings];
          const shouldPerformCheck = sendEncodings.length > 0;
          if (shouldPerformCheck) {
            // If sendEncodings params are provided, validate grammar
            sendEncodings.forEach((encodingParam) => {
              if ('rid' in encodingParam) {
                const ridRegex = /^[a-z0-9]{0,16}$/i;
                if (!ridRegex.test(encodingParam.rid)) {
                  throw new TypeError('Invalid RID value provided.');
                }
              }
              if ('scaleResolutionDownBy' in encodingParam) {
                if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {
                  throw new RangeError('scale_resolution_down_by must be >= 1.0');
                }
              }
              if ('maxFramerate' in encodingParam) {
                if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
                  throw new RangeError('max_framerate must be >= 0.0');
                }
              }
            });
          }
          const transceiver = origAddTransceiver.apply(this, arguments);
          if (shouldPerformCheck) {
            // Check if the init options were applied. If not we do this in an
            // asynchronous way and save the promise reference in a global object.
            // This is an ugly hack, but at the same time is way more robust than
            // checking the sender parameters before and after the createOffer
            // Also note that after the createoffer we are not 100% sure that
            // the params were asynchronously applied so we might miss the
            // opportunity to recreate offer.
            const {sender} = transceiver;
            const params = sender.getParameters();
            if (!('encodings' in params) ||
                // Avoid being fooled by patched getParameters() below.
                (params.encodings.length === 1 &&
                 Object.keys(params.encodings[0]).length === 0)) {
              params.encodings = sendEncodings;
              sender.sendEncodings = sendEncodings;
              this.setParametersPromises.push(sender.setParameters(params)
                .then(() => {
                  delete sender.sendEncodings;
                }).catch(() => {
                  delete sender.sendEncodings;
                })
              );
            }
          }
          return transceiver;
        };
    }
  }

  function shimGetParameters(window) {
    if (!(typeof window === 'object' && window.RTCRtpSender)) {
      return;
    }
    const origGetParameters = window.RTCRtpSender.prototype.getParameters;
    if (origGetParameters) {
      window.RTCRtpSender.prototype.getParameters =
        function getParameters() {
          const params = origGetParameters.apply(this, arguments);
          if (!('encodings' in params)) {
            params.encodings = [].concat(this.sendEncodings || [{}]);
          }
          return params;
        };
    }
  }

  function shimCreateOffer(window) {
    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
    // Firefox ignores the init sendEncodings options passed to addTransceiver
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
    if (!(typeof window === 'object' && window.RTCPeerConnection)) {
      return;
    }
    const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
    window.RTCPeerConnection.prototype.createOffer = function createOffer() {
      if (this.setParametersPromises && this.setParametersPromises.length) {
        return Promise.all(this.setParametersPromises)
          .then(() => {
            return origCreateOffer.apply(this, arguments);
          })
          .finally(() => {
            this.setParametersPromises = [];
          });
      }
      return origCreateOffer.apply(this, arguments);
    };
  }

  function shimCreateAnswer(window) {
    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
    // Firefox ignores the init sendEncodings options passed to addTransceiver
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
    if (!(typeof window === 'object' && window.RTCPeerConnection)) {
      return;
    }
    const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;
    window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
      if (this.setParametersPromises && this.setParametersPromises.length) {
        return Promise.all(this.setParametersPromises)
          .then(() => {
            return origCreateAnswer.apply(this, arguments);
          })
          .finally(() => {
            this.setParametersPromises = [];
          });
      }
      return origCreateAnswer.apply(this, arguments);
    };
  }

  var firefoxShim = /*#__PURE__*/Object.freeze({
    __proto__: null,
    shimAddTransceiver: shimAddTransceiver,
    shimCreateAnswer: shimCreateAnswer,
    shimCreateOffer: shimCreateOffer,
    shimGetDisplayMedia: shimGetDisplayMedia,
    shimGetParameters: shimGetParameters,
    shimGetUserMedia: shimGetUserMedia$1,
    shimOnTrack: shimOnTrack,
    shimPeerConnection: shimPeerConnection,
    shimRTCDataChannel: shimRTCDataChannel,
    shimReceiverGetStats: shimReceiverGetStats,
    shimRemoveStream: shimRemoveStream,
    shimSenderGetStats: shimSenderGetStats
  });

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */

  function shimLocalStreamsAPI(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getLocalStreams =
        function getLocalStreams() {
          if (!this._localStreams) {
            this._localStreams = [];
          }
          return this._localStreams;
        };
    }
    if (!('addStream' in window.RTCPeerConnection.prototype)) {
      const _addTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (!this._localStreams.includes(stream)) {
          this._localStreams.push(stream);
        }
        // Try to emulate Chrome's behaviour of adding in audio-video order.
        // Safari orders by track id.
        stream.getAudioTracks().forEach(track => _addTrack.call(this, track,
          stream));
        stream.getVideoTracks().forEach(track => _addTrack.call(this, track,
          stream));
      };

      window.RTCPeerConnection.prototype.addTrack =
        function addTrack(track, ...streams) {
          if (streams) {
            streams.forEach((stream) => {
              if (!this._localStreams) {
                this._localStreams = [stream];
              } else if (!this._localStreams.includes(stream)) {
                this._localStreams.push(stream);
              }
            });
          }
          return _addTrack.apply(this, arguments);
        };
    }
    if (!('removeStream' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.removeStream =
        function removeStream(stream) {
          if (!this._localStreams) {
            this._localStreams = [];
          }
          const index = this._localStreams.indexOf(stream);
          if (index === -1) {
            return;
          }
          this._localStreams.splice(index, 1);
          const tracks = stream.getTracks();
          this.getSenders().forEach(sender => {
            if (tracks.includes(sender.track)) {
              this.removeTrack(sender);
            }
          });
        };
    }
  }

  function shimRemoteStreamsAPI(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getRemoteStreams =
        function getRemoteStreams() {
          return this._remoteStreams ? this._remoteStreams : [];
        };
    }
    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
        get() {
          return this._onaddstream;
        },
        set(f) {
          if (this._onaddstream) {
            this.removeEventListener('addstream', this._onaddstream);
            this.removeEventListener('track', this._onaddstreampoly);
          }
          this.addEventListener('addstream', this._onaddstream = f);
          this.addEventListener('track', this._onaddstreampoly = (e) => {
            e.streams.forEach(stream => {
              if (!this._remoteStreams) {
                this._remoteStreams = [];
              }
              if (this._remoteStreams.includes(stream)) {
                return;
              }
              this._remoteStreams.push(stream);
              const event = new Event('addstream');
              event.stream = stream;
              this.dispatchEvent(event);
            });
          });
        }
      });
      const origSetRemoteDescription =
        window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription =
        function setRemoteDescription() {
          const pc = this;
          if (!this._onaddstreampoly) {
            this.addEventListener('track', this._onaddstreampoly = function(e) {
              e.streams.forEach(stream => {
                if (!pc._remoteStreams) {
                  pc._remoteStreams = [];
                }
                if (pc._remoteStreams.indexOf(stream) >= 0) {
                  return;
                }
                pc._remoteStreams.push(stream);
                const event = new Event('addstream');
                event.stream = stream;
                pc.dispatchEvent(event);
              });
            });
          }
          return origSetRemoteDescription.apply(pc, arguments);
        };
    }
  }

  function shimCallbacksAPI(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    const prototype = window.RTCPeerConnection.prototype;
    const origCreateOffer = prototype.createOffer;
    const origCreateAnswer = prototype.createAnswer;
    const setLocalDescription = prototype.setLocalDescription;
    const setRemoteDescription = prototype.setRemoteDescription;
    const addIceCandidate = prototype.addIceCandidate;

    prototype.createOffer =
      function createOffer(successCallback, failureCallback) {
        const options = (arguments.length >= 2) ? arguments[2] : arguments[0];
        const promise = origCreateOffer.apply(this, [options]);
        if (!failureCallback) {
          return promise;
        }
        promise.then(successCallback, failureCallback);
        return Promise.resolve();
      };

    prototype.createAnswer =
      function createAnswer(successCallback, failureCallback) {
        const options = (arguments.length >= 2) ? arguments[2] : arguments[0];
        const promise = origCreateAnswer.apply(this, [options]);
        if (!failureCallback) {
          return promise;
        }
        promise.then(successCallback, failureCallback);
        return Promise.resolve();
      };

    let withCallback = function(description, successCallback, failureCallback) {
      const promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;

    withCallback = function(description, successCallback, failureCallback) {
      const promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;

    withCallback = function(candidate, successCallback, failureCallback) {
      const promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  }

  function shimGetUserMedia(window) {
    const navigator = window && window.navigator;

    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      // shim not needed in Safari 12.1
      const mediaDevices = navigator.mediaDevices;
      const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
      navigator.mediaDevices.getUserMedia = (constraints) => {
        return _getUserMedia(shimConstraints(constraints));
      };
    }

    if (!navigator.getUserMedia && navigator.mediaDevices &&
      navigator.mediaDevices.getUserMedia) {
      navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
        navigator.mediaDevices.getUserMedia(constraints)
          .then(cb, errcb);
      }.bind(navigator);
    }
  }

  function shimConstraints(constraints) {
    if (constraints && constraints.video !== undefined) {
      return Object.assign({},
        constraints,
        {video: compactObject(constraints.video)}
      );
    }

    return constraints;
  }

  function shimRTCIceServerUrls(window) {
    if (!window.RTCPeerConnection) {
      return;
    }
    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
    const OrigPeerConnection = window.RTCPeerConnection;
    window.RTCPeerConnection =
      function RTCPeerConnection(pcConfig, pcConstraints) {
        if (pcConfig && pcConfig.iceServers) {
          const newIceServers = [];
          for (let i = 0; i < pcConfig.iceServers.length; i++) {
            let server = pcConfig.iceServers[i];
            if (server.urls === undefined && server.url) {
              deprecated('RTCIceServer.url', 'RTCIceServer.urls');
              server = JSON.parse(JSON.stringify(server));
              server.urls = server.url;
              delete server.url;
              newIceServers.push(server);
            } else {
              newIceServers.push(pcConfig.iceServers[i]);
            }
          }
          pcConfig.iceServers = newIceServers;
        }
        return new OrigPeerConnection(pcConfig, pcConstraints);
      };
    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    // wrap static methods. Currently just generateCertificate.
    if ('generateCertificate' in OrigPeerConnection) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }
  }

  function shimTrackEventTransceiver(window) {
    // Add event.transceiver member over deprecated event.receiver
    if (typeof window === 'object' && window.RTCTrackEvent &&
        'receiver' in window.RTCTrackEvent.prototype &&
        !('transceiver' in window.RTCTrackEvent.prototype)) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get() {
          return {receiver: this.receiver};
        }
      });
    }
  }

  function shimCreateOfferLegacy(window) {
    const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
    window.RTCPeerConnection.prototype.createOffer =
      function createOffer(offerOptions) {
        if (offerOptions) {
          if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
            // support bit values
            offerOptions.offerToReceiveAudio =
              !!offerOptions.offerToReceiveAudio;
          }
          const audioTransceiver = this.getTransceivers().find(transceiver =>
            transceiver.receiver.track.kind === 'audio');
          if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
            if (audioTransceiver.direction === 'sendrecv') {
              if (audioTransceiver.setDirection) {
                audioTransceiver.setDirection('sendonly');
              } else {
                audioTransceiver.direction = 'sendonly';
              }
            } else if (audioTransceiver.direction === 'recvonly') {
              if (audioTransceiver.setDirection) {
                audioTransceiver.setDirection('inactive');
              } else {
                audioTransceiver.direction = 'inactive';
              }
            }
          } else if (offerOptions.offerToReceiveAudio === true &&
              !audioTransceiver) {
            this.addTransceiver('audio', {direction: 'recvonly'});
          }

          if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
            // support bit values
            offerOptions.offerToReceiveVideo =
              !!offerOptions.offerToReceiveVideo;
          }
          const videoTransceiver = this.getTransceivers().find(transceiver =>
            transceiver.receiver.track.kind === 'video');
          if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
            if (videoTransceiver.direction === 'sendrecv') {
              if (videoTransceiver.setDirection) {
                videoTransceiver.setDirection('sendonly');
              } else {
                videoTransceiver.direction = 'sendonly';
              }
            } else if (videoTransceiver.direction === 'recvonly') {
              if (videoTransceiver.setDirection) {
                videoTransceiver.setDirection('inactive');
              } else {
                videoTransceiver.direction = 'inactive';
              }
            }
          } else if (offerOptions.offerToReceiveVideo === true &&
              !videoTransceiver) {
            this.addTransceiver('video', {direction: 'recvonly'});
          }
        }
        return origCreateOffer.apply(this, arguments);
      };
  }

  function shimAudioContext(window) {
    if (typeof window !== 'object' || window.AudioContext) {
      return;
    }
    window.AudioContext = window.webkitAudioContext;
  }

  var safariShim = /*#__PURE__*/Object.freeze({
    __proto__: null,
    shimAudioContext: shimAudioContext,
    shimCallbacksAPI: shimCallbacksAPI,
    shimConstraints: shimConstraints,
    shimCreateOfferLegacy: shimCreateOfferLegacy,
    shimGetUserMedia: shimGetUserMedia,
    shimLocalStreamsAPI: shimLocalStreamsAPI,
    shimRTCIceServerUrls: shimRTCIceServerUrls,
    shimRemoteStreamsAPI: shimRemoteStreamsAPI,
    shimTrackEventTransceiver: shimTrackEventTransceiver
  });

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var sdp$1 = {exports: {}};

  /* eslint-env node */

  (function (module) {

  	// SDP helpers.
  	const SDPUtils = {};

  	// Generate an alphanumeric identifier for cname or mids.
  	// TODO: use UUIDs instead? https://gist.github.com/jed/982883
  	SDPUtils.generateIdentifier = function() {
  	  return Math.random().toString(36).substring(2, 12);
  	};

  	// The RTCP CNAME used by all peerconnections from the same JS.
  	SDPUtils.localCName = SDPUtils.generateIdentifier();

  	// Splits SDP into lines, dealing with both CRLF and LF.
  	SDPUtils.splitLines = function(blob) {
  	  return blob.trim().split('\n').map(line => line.trim());
  	};
  	// Splits SDP into sessionpart and mediasections. Ensures CRLF.
  	SDPUtils.splitSections = function(blob) {
  	  const parts = blob.split('\nm=');
  	  return parts.map((part, index) => (index > 0 ?
  	    'm=' + part : part).trim() + '\r\n');
  	};

  	// Returns the session description.
  	SDPUtils.getDescription = function(blob) {
  	  const sections = SDPUtils.splitSections(blob);
  	  return sections && sections[0];
  	};

  	// Returns the individual media sections.
  	SDPUtils.getMediaSections = function(blob) {
  	  const sections = SDPUtils.splitSections(blob);
  	  sections.shift();
  	  return sections;
  	};

  	// Returns lines that start with a certain prefix.
  	SDPUtils.matchPrefix = function(blob, prefix) {
  	  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);
  	};

  	// Parses an ICE candidate line. Sample input:
  	// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
  	// rport 55996"
  	// Input can be prefixed with a=.
  	SDPUtils.parseCandidate = function(line) {
  	  let parts;
  	  // Parse both variants.
  	  if (line.indexOf('a=candidate:') === 0) {
  	    parts = line.substring(12).split(' ');
  	  } else {
  	    parts = line.substring(10).split(' ');
  	  }

  	  const candidate = {
  	    foundation: parts[0],
  	    component: {1: 'rtp', 2: 'rtcp'}[parts[1]] || parts[1],
  	    protocol: parts[2].toLowerCase(),
  	    priority: parseInt(parts[3], 10),
  	    ip: parts[4],
  	    address: parts[4], // address is an alias for ip.
  	    port: parseInt(parts[5], 10),
  	    // skip parts[6] == 'typ'
  	    type: parts[7],
  	  };

  	  for (let i = 8; i < parts.length; i += 2) {
  	    switch (parts[i]) {
  	      case 'raddr':
  	        candidate.relatedAddress = parts[i + 1];
  	        break;
  	      case 'rport':
  	        candidate.relatedPort = parseInt(parts[i + 1], 10);
  	        break;
  	      case 'tcptype':
  	        candidate.tcpType = parts[i + 1];
  	        break;
  	      case 'ufrag':
  	        candidate.ufrag = parts[i + 1]; // for backward compatibility.
  	        candidate.usernameFragment = parts[i + 1];
  	        break;
  	      default: // extension handling, in particular ufrag. Don't overwrite.
  	        if (candidate[parts[i]] === undefined) {
  	          candidate[parts[i]] = parts[i + 1];
  	        }
  	        break;
  	    }
  	  }
  	  return candidate;
  	};

  	// Translates a candidate object into SDP candidate attribute.
  	// This does not include the a= prefix!
  	SDPUtils.writeCandidate = function(candidate) {
  	  const sdp = [];
  	  sdp.push(candidate.foundation);

  	  const component = candidate.component;
  	  if (component === 'rtp') {
  	    sdp.push(1);
  	  } else if (component === 'rtcp') {
  	    sdp.push(2);
  	  } else {
  	    sdp.push(component);
  	  }
  	  sdp.push(candidate.protocol.toUpperCase());
  	  sdp.push(candidate.priority);
  	  sdp.push(candidate.address || candidate.ip);
  	  sdp.push(candidate.port);

  	  const type = candidate.type;
  	  sdp.push('typ');
  	  sdp.push(type);
  	  if (type !== 'host' && candidate.relatedAddress &&
  	      candidate.relatedPort) {
  	    sdp.push('raddr');
  	    sdp.push(candidate.relatedAddress);
  	    sdp.push('rport');
  	    sdp.push(candidate.relatedPort);
  	  }
  	  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
  	    sdp.push('tcptype');
  	    sdp.push(candidate.tcpType);
  	  }
  	  if (candidate.usernameFragment || candidate.ufrag) {
  	    sdp.push('ufrag');
  	    sdp.push(candidate.usernameFragment || candidate.ufrag);
  	  }
  	  return 'candidate:' + sdp.join(' ');
  	};

  	// Parses an ice-options line, returns an array of option tags.
  	// Sample input:
  	// a=ice-options:foo bar
  	SDPUtils.parseIceOptions = function(line) {
  	  return line.substring(14).split(' ');
  	};

  	// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:
  	// a=rtpmap:111 opus/48000/2
  	SDPUtils.parseRtpMap = function(line) {
  	  let parts = line.substring(9).split(' ');
  	  const parsed = {
  	    payloadType: parseInt(parts.shift(), 10), // was: id
  	  };

  	  parts = parts[0].split('/');

  	  parsed.name = parts[0];
  	  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  	  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  	  // legacy alias, got renamed back to channels in ORTC.
  	  parsed.numChannels = parsed.channels;
  	  return parsed;
  	};

  	// Generates a rtpmap line from RTCRtpCodecCapability or
  	// RTCRtpCodecParameters.
  	SDPUtils.writeRtpMap = function(codec) {
  	  let pt = codec.payloadType;
  	  if (codec.preferredPayloadType !== undefined) {
  	    pt = codec.preferredPayloadType;
  	  }
  	  const channels = codec.channels || codec.numChannels || 1;
  	  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
  	      (channels !== 1 ? '/' + channels : '') + '\r\n';
  	};

  	// Parses a extmap line (headerextension from RFC 5285). Sample input:
  	// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
  	// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
  	SDPUtils.parseExtmap = function(line) {
  	  const parts = line.substring(9).split(' ');
  	  return {
  	    id: parseInt(parts[0], 10),
  	    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
  	    uri: parts[1],
  	    attributes: parts.slice(2).join(' '),
  	  };
  	};

  	// Generates an extmap line from RTCRtpHeaderExtensionParameters or
  	// RTCRtpHeaderExtension.
  	SDPUtils.writeExtmap = function(headerExtension) {
  	  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
  	      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
  	        ? '/' + headerExtension.direction
  	        : '') +
  	      ' ' + headerExtension.uri +
  	      (headerExtension.attributes ? ' ' + headerExtension.attributes : '') +
  	      '\r\n';
  	};

  	// Parses a fmtp line, returns dictionary. Sample input:
  	// a=fmtp:96 vbr=on;cng=on
  	// Also deals with vbr=on; cng=on
  	SDPUtils.parseFmtp = function(line) {
  	  const parsed = {};
  	  let kv;
  	  const parts = line.substring(line.indexOf(' ') + 1).split(';');
  	  for (let j = 0; j < parts.length; j++) {
  	    kv = parts[j].trim().split('=');
  	    parsed[kv[0].trim()] = kv[1];
  	  }
  	  return parsed;
  	};

  	// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
  	SDPUtils.writeFmtp = function(codec) {
  	  let line = '';
  	  let pt = codec.payloadType;
  	  if (codec.preferredPayloadType !== undefined) {
  	    pt = codec.preferredPayloadType;
  	  }
  	  if (codec.parameters && Object.keys(codec.parameters).length) {
  	    const params = [];
  	    Object.keys(codec.parameters).forEach(param => {
  	      if (codec.parameters[param] !== undefined) {
  	        params.push(param + '=' + codec.parameters[param]);
  	      } else {
  	        params.push(param);
  	      }
  	    });
  	    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  	  }
  	  return line;
  	};

  	// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
  	// a=rtcp-fb:98 nack rpsi
  	SDPUtils.parseRtcpFb = function(line) {
  	  const parts = line.substring(line.indexOf(' ') + 1).split(' ');
  	  return {
  	    type: parts.shift(),
  	    parameter: parts.join(' '),
  	  };
  	};

  	// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
  	SDPUtils.writeRtcpFb = function(codec) {
  	  let lines = '';
  	  let pt = codec.payloadType;
  	  if (codec.preferredPayloadType !== undefined) {
  	    pt = codec.preferredPayloadType;
  	  }
  	  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
  	    // FIXME: special handling for trr-int?
  	    codec.rtcpFeedback.forEach(fb => {
  	      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
  	      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
  	          '\r\n';
  	    });
  	  }
  	  return lines;
  	};

  	// Parses a RFC 5576 ssrc media attribute. Sample input:
  	// a=ssrc:3735928559 cname:something
  	SDPUtils.parseSsrcMedia = function(line) {
  	  const sp = line.indexOf(' ');
  	  const parts = {
  	    ssrc: parseInt(line.substring(7, sp), 10),
  	  };
  	  const colon = line.indexOf(':', sp);
  	  if (colon > -1) {
  	    parts.attribute = line.substring(sp + 1, colon);
  	    parts.value = line.substring(colon + 1);
  	  } else {
  	    parts.attribute = line.substring(sp + 1);
  	  }
  	  return parts;
  	};

  	// Parse a ssrc-group line (see RFC 5576). Sample input:
  	// a=ssrc-group:semantics 12 34
  	SDPUtils.parseSsrcGroup = function(line) {
  	  const parts = line.substring(13).split(' ');
  	  return {
  	    semantics: parts.shift(),
  	    ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),
  	  };
  	};

  	// Extracts the MID (RFC 5888) from a media section.
  	// Returns the MID or undefined if no mid line was found.
  	SDPUtils.getMid = function(mediaSection) {
  	  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  	  if (mid) {
  	    return mid.substring(6);
  	  }
  	};

  	// Parses a fingerprint line for DTLS-SRTP.
  	SDPUtils.parseFingerprint = function(line) {
  	  const parts = line.substring(14).split(' ');
  	  return {
  	    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
  	    value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.
  	  };
  	};

  	// Extracts DTLS parameters from SDP media section or sessionpart.
  	// FIXME: for consistency with other functions this should only
  	//   get the fingerprint line as input. See also getIceParameters.
  	SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  	  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
  	    'a=fingerprint:');
  	  // Note: a=setup line is ignored since we use the 'auto' role in Edge.
  	  return {
  	    role: 'auto',
  	    fingerprints: lines.map(SDPUtils.parseFingerprint),
  	  };
  	};

  	// Serializes DTLS parameters to SDP.
  	SDPUtils.writeDtlsParameters = function(params, setupType) {
  	  let sdp = 'a=setup:' + setupType + '\r\n';
  	  params.fingerprints.forEach(fp => {
  	    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  	  });
  	  return sdp;
  	};

  	// Parses a=crypto lines into
  	//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
  	SDPUtils.parseCryptoLine = function(line) {
  	  const parts = line.substring(9).split(' ');
  	  return {
  	    tag: parseInt(parts[0], 10),
  	    cryptoSuite: parts[1],
  	    keyParams: parts[2],
  	    sessionParams: parts.slice(3),
  	  };
  	};

  	SDPUtils.writeCryptoLine = function(parameters) {
  	  return 'a=crypto:' + parameters.tag + ' ' +
  	    parameters.cryptoSuite + ' ' +
  	    (typeof parameters.keyParams === 'object'
  	      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)
  	      : parameters.keyParams) +
  	    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +
  	    '\r\n';
  	};

  	// Parses the crypto key parameters into
  	//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
  	SDPUtils.parseCryptoKeyParams = function(keyParams) {
  	  if (keyParams.indexOf('inline:') !== 0) {
  	    return null;
  	  }
  	  const parts = keyParams.substring(7).split('|');
  	  return {
  	    keyMethod: 'inline',
  	    keySalt: parts[0],
  	    lifeTime: parts[1],
  	    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
  	    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,
  	  };
  	};

  	SDPUtils.writeCryptoKeyParams = function(keyParams) {
  	  return keyParams.keyMethod + ':'
  	    + keyParams.keySalt +
  	    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +
  	    (keyParams.mkiValue && keyParams.mkiLength
  	      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength
  	      : '');
  	};

  	// Extracts all SDES parameters.
  	SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {
  	  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
  	    'a=crypto:');
  	  return lines.map(SDPUtils.parseCryptoLine);
  	};

  	// Parses ICE information from SDP media section or sessionpart.
  	// FIXME: for consistency with other functions this should only
  	//   get the ice-ufrag and ice-pwd lines as input.
  	SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  	  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,
  	    'a=ice-ufrag:')[0];
  	  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,
  	    'a=ice-pwd:')[0];
  	  if (!(ufrag && pwd)) {
  	    return null;
  	  }
  	  return {
  	    usernameFragment: ufrag.substring(12),
  	    password: pwd.substring(10),
  	  };
  	};

  	// Serializes ICE parameters to SDP.
  	SDPUtils.writeIceParameters = function(params) {
  	  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
  	      'a=ice-pwd:' + params.password + '\r\n';
  	  if (params.iceLite) {
  	    sdp += 'a=ice-lite\r\n';
  	  }
  	  return sdp;
  	};

  	// Parses the SDP media section and returns RTCRtpParameters.
  	SDPUtils.parseRtpParameters = function(mediaSection) {
  	  const description = {
  	    codecs: [],
  	    headerExtensions: [],
  	    fecMechanisms: [],
  	    rtcp: [],
  	  };
  	  const lines = SDPUtils.splitLines(mediaSection);
  	  const mline = lines[0].split(' ');
  	  description.profile = mline[2];
  	  for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
  	    const pt = mline[i];
  	    const rtpmapline = SDPUtils.matchPrefix(
  	      mediaSection, 'a=rtpmap:' + pt + ' ')[0];
  	    if (rtpmapline) {
  	      const codec = SDPUtils.parseRtpMap(rtpmapline);
  	      const fmtps = SDPUtils.matchPrefix(
  	        mediaSection, 'a=fmtp:' + pt + ' ');
  	      // Only the first a=fmtp:<pt> is considered.
  	      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
  	      codec.rtcpFeedback = SDPUtils.matchPrefix(
  	        mediaSection, 'a=rtcp-fb:' + pt + ' ')
  	        .map(SDPUtils.parseRtcpFb);
  	      description.codecs.push(codec);
  	      // parse FEC mechanisms from rtpmap lines.
  	      switch (codec.name.toUpperCase()) {
  	        case 'RED':
  	        case 'ULPFEC':
  	          description.fecMechanisms.push(codec.name.toUpperCase());
  	          break;
  	      }
  	    }
  	  }
  	  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {
  	    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  	  });
  	  const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ')
  	    .map(SDPUtils.parseRtcpFb);
  	  description.codecs.forEach(codec => {
  	    wildcardRtcpFb.forEach(fb=> {
  	      const duplicate = codec.rtcpFeedback.find(existingFeedback => {
  	        return existingFeedback.type === fb.type &&
  	          existingFeedback.parameter === fb.parameter;
  	      });
  	      if (!duplicate) {
  	        codec.rtcpFeedback.push(fb);
  	      }
  	    });
  	  });
  	  // FIXME: parse rtcp.
  	  return description;
  	};

  	// Generates parts of the SDP media section describing the capabilities /
  	// parameters.
  	SDPUtils.writeRtpDescription = function(kind, caps) {
  	  let sdp = '';

  	  // Build the mline.
  	  sdp += 'm=' + kind + ' ';
  	  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  	  sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';
  	  sdp += caps.codecs.map(codec => {
  	    if (codec.preferredPayloadType !== undefined) {
  	      return codec.preferredPayloadType;
  	    }
  	    return codec.payloadType;
  	  }).join(' ') + '\r\n';

  	  sdp += 'c=IN IP4 0.0.0.0\r\n';
  	  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  	  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  	  caps.codecs.forEach(codec => {
  	    sdp += SDPUtils.writeRtpMap(codec);
  	    sdp += SDPUtils.writeFmtp(codec);
  	    sdp += SDPUtils.writeRtcpFb(codec);
  	  });
  	  let maxptime = 0;
  	  caps.codecs.forEach(codec => {
  	    if (codec.maxptime > maxptime) {
  	      maxptime = codec.maxptime;
  	    }
  	  });
  	  if (maxptime > 0) {
  	    sdp += 'a=maxptime:' + maxptime + '\r\n';
  	  }

  	  if (caps.headerExtensions) {
  	    caps.headerExtensions.forEach(extension => {
  	      sdp += SDPUtils.writeExtmap(extension);
  	    });
  	  }
  	  // FIXME: write fecMechanisms.
  	  return sdp;
  	};

  	// Parses the SDP media section and returns an array of
  	// RTCRtpEncodingParameters.
  	SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  	  const encodingParameters = [];
  	  const description = SDPUtils.parseRtpParameters(mediaSection);
  	  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  	  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  	  // filter a=ssrc:... cname:, ignore PlanB-msid
  	  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  	    .map(line => SDPUtils.parseSsrcMedia(line))
  	    .filter(parts => parts.attribute === 'cname');
  	  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  	  let secondarySsrc;

  	  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
  	    .map(line => {
  	      const parts = line.substring(17).split(' ');
  	      return parts.map(part => parseInt(part, 10));
  	    });
  	  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
  	    secondarySsrc = flows[0][1];
  	  }

  	  description.codecs.forEach(codec => {
  	    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
  	      let encParam = {
  	        ssrc: primarySsrc,
  	        codecPayloadType: parseInt(codec.parameters.apt, 10),
  	      };
  	      if (primarySsrc && secondarySsrc) {
  	        encParam.rtx = {ssrc: secondarySsrc};
  	      }
  	      encodingParameters.push(encParam);
  	      if (hasRed) {
  	        encParam = JSON.parse(JSON.stringify(encParam));
  	        encParam.fec = {
  	          ssrc: primarySsrc,
  	          mechanism: hasUlpfec ? 'red+ulpfec' : 'red',
  	        };
  	        encodingParameters.push(encParam);
  	      }
  	    }
  	  });
  	  if (encodingParameters.length === 0 && primarySsrc) {
  	    encodingParameters.push({
  	      ssrc: primarySsrc,
  	    });
  	  }

  	  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  	  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  	  if (bandwidth.length) {
  	    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
  	      bandwidth = parseInt(bandwidth[0].substring(7), 10);
  	    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
  	      // use formula from JSEP to convert b=AS to TIAS value.
  	      bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95
  	          - (50 * 40 * 8);
  	    } else {
  	      bandwidth = undefined;
  	    }
  	    encodingParameters.forEach(params => {
  	      params.maxBitrate = bandwidth;
  	    });
  	  }
  	  return encodingParameters;
  	};

  	// parses http://draft.ortc.org/#rtcrtcpparameters*
  	SDPUtils.parseRtcpParameters = function(mediaSection) {
  	  const rtcpParameters = {};

  	  // Gets the first SSRC. Note that with RTX there might be multiple
  	  // SSRCs.
  	  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  	    .map(line => SDPUtils.parseSsrcMedia(line))
  	    .filter(obj => obj.attribute === 'cname')[0];
  	  if (remoteSsrc) {
  	    rtcpParameters.cname = remoteSsrc.value;
  	    rtcpParameters.ssrc = remoteSsrc.ssrc;
  	  }

  	  // Edge uses the compound attribute instead of reducedSize
  	  // compound is !reducedSize
  	  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  	  rtcpParameters.reducedSize = rsize.length > 0;
  	  rtcpParameters.compound = rsize.length === 0;

  	  // parses the rtcp-mux attrіbute.
  	  // Note that Edge does not support unmuxed RTCP.
  	  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  	  rtcpParameters.mux = mux.length > 0;

  	  return rtcpParameters;
  	};

  	SDPUtils.writeRtcpParameters = function(rtcpParameters) {
  	  let sdp = '';
  	  if (rtcpParameters.reducedSize) {
  	    sdp += 'a=rtcp-rsize\r\n';
  	  }
  	  if (rtcpParameters.mux) {
  	    sdp += 'a=rtcp-mux\r\n';
  	  }
  	  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {
  	    sdp += 'a=ssrc:' + rtcpParameters.ssrc +
  	      ' cname:' + rtcpParameters.cname + '\r\n';
  	  }
  	  return sdp;
  	};


  	// parses either a=msid: or a=ssrc:... msid lines and returns
  	// the id of the MediaStream and MediaStreamTrack.
  	SDPUtils.parseMsid = function(mediaSection) {
  	  let parts;
  	  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  	  if (spec.length === 1) {
  	    parts = spec[0].substring(7).split(' ');
  	    return {stream: parts[0], track: parts[1]};
  	  }
  	  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  	    .map(line => SDPUtils.parseSsrcMedia(line))
  	    .filter(msidParts => msidParts.attribute === 'msid');
  	  if (planB.length > 0) {
  	    parts = planB[0].value.split(' ');
  	    return {stream: parts[0], track: parts[1]};
  	  }
  	};

  	// SCTP
  	// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
  	// to draft-ietf-mmusic-sctp-sdp-05
  	SDPUtils.parseSctpDescription = function(mediaSection) {
  	  const mline = SDPUtils.parseMLine(mediaSection);
  	  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
  	  let maxMessageSize;
  	  if (maxSizeLine.length > 0) {
  	    maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
  	  }
  	  if (isNaN(maxMessageSize)) {
  	    maxMessageSize = 65536;
  	  }
  	  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
  	  if (sctpPort.length > 0) {
  	    return {
  	      port: parseInt(sctpPort[0].substring(12), 10),
  	      protocol: mline.fmt,
  	      maxMessageSize,
  	    };
  	  }
  	  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
  	  if (sctpMapLines.length > 0) {
  	    const parts = sctpMapLines[0]
  	      .substring(10)
  	      .split(' ');
  	    return {
  	      port: parseInt(parts[0], 10),
  	      protocol: parts[1],
  	      maxMessageSize,
  	    };
  	  }
  	};

  	// SCTP
  	// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
  	// support by now receiving in this format, unless we originally parsed
  	// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
  	// protocol of DTLS/SCTP -- without UDP/ or TCP/)
  	SDPUtils.writeSctpDescription = function(media, sctp) {
  	  let output = [];
  	  if (media.protocol !== 'DTLS/SCTP') {
  	    output = [
  	      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
  	      'c=IN IP4 0.0.0.0\r\n',
  	      'a=sctp-port:' + sctp.port + '\r\n',
  	    ];
  	  } else {
  	    output = [
  	      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
  	      'c=IN IP4 0.0.0.0\r\n',
  	      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n',
  	    ];
  	  }
  	  if (sctp.maxMessageSize !== undefined) {
  	    output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
  	  }
  	  return output.join('');
  	};

  	// Generate a session ID for SDP.
  	// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
  	// recommends using a cryptographically random +ve 64-bit value
  	// but right now this should be acceptable and within the right range
  	SDPUtils.generateSessionId = function() {
  	  return Math.random().toString().substr(2, 22);
  	};

  	// Write boiler plate for start of SDP
  	// sessId argument is optional - if not supplied it will
  	// be generated randomly
  	// sessVersion is optional and defaults to 2
  	// sessUser is optional and defaults to 'thisisadapterortc'
  	SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
  	  let sessionId;
  	  const version = sessVer !== undefined ? sessVer : 2;
  	  if (sessId) {
  	    sessionId = sessId;
  	  } else {
  	    sessionId = SDPUtils.generateSessionId();
  	  }
  	  const user = sessUser || 'thisisadapterortc';
  	  // FIXME: sess-id should be an NTP timestamp.
  	  return 'v=0\r\n' +
  	      'o=' + user + ' ' + sessionId + ' ' + version +
  	        ' IN IP4 127.0.0.1\r\n' +
  	      's=-\r\n' +
  	      't=0 0\r\n';
  	};

  	// Gets the direction from the mediaSection or the sessionpart.
  	SDPUtils.getDirection = function(mediaSection, sessionpart) {
  	  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  	  const lines = SDPUtils.splitLines(mediaSection);
  	  for (let i = 0; i < lines.length; i++) {
  	    switch (lines[i]) {
  	      case 'a=sendrecv':
  	      case 'a=sendonly':
  	      case 'a=recvonly':
  	      case 'a=inactive':
  	        return lines[i].substring(2);
  	        // FIXME: What should happen here?
  	    }
  	  }
  	  if (sessionpart) {
  	    return SDPUtils.getDirection(sessionpart);
  	  }
  	  return 'sendrecv';
  	};

  	SDPUtils.getKind = function(mediaSection) {
  	  const lines = SDPUtils.splitLines(mediaSection);
  	  const mline = lines[0].split(' ');
  	  return mline[0].substring(2);
  	};

  	SDPUtils.isRejected = function(mediaSection) {
  	  return mediaSection.split(' ', 2)[1] === '0';
  	};

  	SDPUtils.parseMLine = function(mediaSection) {
  	  const lines = SDPUtils.splitLines(mediaSection);
  	  const parts = lines[0].substring(2).split(' ');
  	  return {
  	    kind: parts[0],
  	    port: parseInt(parts[1], 10),
  	    protocol: parts[2],
  	    fmt: parts.slice(3).join(' '),
  	  };
  	};

  	SDPUtils.parseOLine = function(mediaSection) {
  	  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  	  const parts = line.substring(2).split(' ');
  	  return {
  	    username: parts[0],
  	    sessionId: parts[1],
  	    sessionVersion: parseInt(parts[2], 10),
  	    netType: parts[3],
  	    addressType: parts[4],
  	    address: parts[5],
  	  };
  	};

  	// a very naive interpretation of a valid SDP.
  	SDPUtils.isValidSDP = function(blob) {
  	  if (typeof blob !== 'string' || blob.length === 0) {
  	    return false;
  	  }
  	  const lines = SDPUtils.splitLines(blob);
  	  for (let i = 0; i < lines.length; i++) {
  	    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
  	      return false;
  	    }
  	    // TODO: check the modifier a bit more.
  	  }
  	  return true;
  	};

  	// Expose public methods.
  	{
  	  module.exports = SDPUtils;
  	} 
  } (sdp$1));

  var sdpExports = sdp$1.exports;
  var SDPUtils = /*@__PURE__*/getDefaultExportFromCjs(sdpExports);

  var sdp = /*#__PURE__*/_mergeNamespaces({
    __proto__: null,
    default: SDPUtils
  }, [sdpExports]);

  /*
   *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */

  function shimRTCIceCandidate(window) {
    // foundation is arbitrarily chosen as an indicator for full support for
    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
    if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in
        window.RTCIceCandidate.prototype)) {
      return;
    }

    const NativeRTCIceCandidate = window.RTCIceCandidate;
    window.RTCIceCandidate = function RTCIceCandidate(args) {
      // Remove the a= which shouldn't be part of the candidate string.
      if (typeof args === 'object' && args.candidate &&
          args.candidate.indexOf('a=') === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substring(2);
      }

      if (args.candidate && args.candidate.length) {
        // Augment the native candidate with the parsed fields.
        const nativeCandidate = new NativeRTCIceCandidate(args);
        const parsedCandidate = SDPUtils.parseCandidate(args.candidate);
        for (const key in parsedCandidate) {
          if (!(key in nativeCandidate)) {
            Object.defineProperty(nativeCandidate, key,
              {value: parsedCandidate[key]});
          }
        }

        // Override serializer to not serialize the extra attributes.
        nativeCandidate.toJSON = function toJSON() {
          return {
            candidate: nativeCandidate.candidate,
            sdpMid: nativeCandidate.sdpMid,
            sdpMLineIndex: nativeCandidate.sdpMLineIndex,
            usernameFragment: nativeCandidate.usernameFragment,
          };
        };
        return nativeCandidate;
      }
      return new NativeRTCIceCandidate(args);
    };
    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

    // Hook up the augmented candidate in onicecandidate and
    // addEventListener('icecandidate', ...)
    wrapPeerConnectionEvent(window, 'icecandidate', e => {
      if (e.candidate) {
        Object.defineProperty(e, 'candidate', {
          value: new window.RTCIceCandidate(e.candidate),
          writable: 'false'
        });
      }
      return e;
    });
  }

  function shimRTCIceCandidateRelayProtocol(window) {
    if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'relayProtocol' in
        window.RTCIceCandidate.prototype)) {
      return;
    }

    // Hook up the augmented candidate in onicecandidate and
    // addEventListener('icecandidate', ...)
    wrapPeerConnectionEvent(window, 'icecandidate', e => {
      if (e.candidate) {
        const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);
        if (parsedCandidate.type === 'relay') {
          // This is a libwebrtc-specific mapping of local type preference
          // to relayProtocol.
          e.candidate.relayProtocol = {
            0: 'tls',
            1: 'tcp',
            2: 'udp',
          }[parsedCandidate.priority >> 24];
        }
      }
      return e;
    });
  }

  function shimMaxMessageSize(window, browserDetails) {
    if (!window.RTCPeerConnection) {
      return;
    }

    if (!('sctp' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
        get() {
          return typeof this._sctp === 'undefined' ? null : this._sctp;
        }
      });
    }

    const sctpInDescription = function(description) {
      if (!description || !description.sdp) {
        return false;
      }
      const sections = SDPUtils.splitSections(description.sdp);
      sections.shift();
      return sections.some(mediaSection => {
        const mLine = SDPUtils.parseMLine(mediaSection);
        return mLine && mLine.kind === 'application'
            && mLine.protocol.indexOf('SCTP') !== -1;
      });
    };

    const getRemoteFirefoxVersion = function(description) {
      // TODO: Is there a better solution for detecting Firefox?
      const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (match === null || match.length < 2) {
        return -1;
      }
      const version = parseInt(match[1], 10);
      // Test for NaN (yes, this is ugly)
      return version !== version ? -1 : version;
    };

    const getCanSendMaxMessageSize = function(remoteIsFirefox) {
      // Every implementation we know can send at least 64 KiB.
      // Note: Although Chrome is technically able to send up to 256 KiB, the
      //       data does not reach the other peer reliably.
      //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
      let canSendMaxMessageSize = 65536;
      if (browserDetails.browser === 'firefox') {
        if (browserDetails.version < 57) {
          if (remoteIsFirefox === -1) {
            // FF < 57 will send in 16 KiB chunks using the deprecated PPID
            // fragmentation.
            canSendMaxMessageSize = 16384;
          } else {
            // However, other FF (and RAWRTC) can reassemble PPID-fragmented
            // messages. Thus, supporting ~2 GiB when sending.
            canSendMaxMessageSize = 2147483637;
          }
        } else if (browserDetails.version < 60) {
          // Currently, all FF >= 57 will reset the remote maximum message size
          // to the default value when a data channel is created at a later
          // stage. :(
          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
          canSendMaxMessageSize =
            browserDetails.version === 57 ? 65535 : 65536;
        } else {
          // FF >= 60 supports sending ~2 GiB
          canSendMaxMessageSize = 2147483637;
        }
      }
      return canSendMaxMessageSize;
    };

    const getMaxMessageSize = function(description, remoteIsFirefox) {
      // Note: 65536 bytes is the default value from the SDP spec. Also,
      //       every implementation we know supports receiving 65536 bytes.
      let maxMessageSize = 65536;

      // FF 57 has a slightly incorrect default remote max message size, so
      // we need to adjust it here to avoid a failure when sending.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
      if (browserDetails.browser === 'firefox'
           && browserDetails.version === 57) {
        maxMessageSize = 65535;
      }

      const match = SDPUtils.matchPrefix(description.sdp,
        'a=max-message-size:');
      if (match.length > 0) {
        maxMessageSize = parseInt(match[0].substring(19), 10);
      } else if (browserDetails.browser === 'firefox' &&
                  remoteIsFirefox !== -1) {
        // If the maximum message size is not present in the remote SDP and
        // both local and remote are Firefox, the remote peer can receive
        // ~2 GiB.
        maxMessageSize = 2147483637;
      }
      return maxMessageSize;
    };

    const origSetRemoteDescription =
        window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription =
      function setRemoteDescription() {
        this._sctp = null;
        // Chrome decided to not expose .sctp in plan-b mode.
        // As usual, adapter.js has to do an 'ugly worakaround'
        // to cover up the mess.
        if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
          const {sdpSemantics} = this.getConfiguration();
          if (sdpSemantics === 'plan-b') {
            Object.defineProperty(this, 'sctp', {
              get() {
                return typeof this._sctp === 'undefined' ? null : this._sctp;
              },
              enumerable: true,
              configurable: true,
            });
          }
        }

        if (sctpInDescription(arguments[0])) {
          // Check if the remote is FF.
          const isFirefox = getRemoteFirefoxVersion(arguments[0]);

          // Get the maximum message size the local peer is capable of sending
          const canSendMMS = getCanSendMaxMessageSize(isFirefox);

          // Get the maximum message size of the remote peer.
          const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

          // Determine final maximum message size
          let maxMessageSize;
          if (canSendMMS === 0 && remoteMMS === 0) {
            maxMessageSize = Number.POSITIVE_INFINITY;
          } else if (canSendMMS === 0 || remoteMMS === 0) {
            maxMessageSize = Math.max(canSendMMS, remoteMMS);
          } else {
            maxMessageSize = Math.min(canSendMMS, remoteMMS);
          }

          // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
          // attribute.
          const sctp = {};
          Object.defineProperty(sctp, 'maxMessageSize', {
            get() {
              return maxMessageSize;
            }
          });
          this._sctp = sctp;
        }

        return origSetRemoteDescription.apply(this, arguments);
      };
  }

  function shimSendThrowTypeError(window) {
    if (!(window.RTCPeerConnection &&
        'createDataChannel' in window.RTCPeerConnection.prototype)) {
      return;
    }

    // Note: Although Firefox >= 57 has a native implementation, the maximum
    //       message size can be reset for all data channels at a later stage.
    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

    function wrapDcSend(dc, pc) {
      const origDataChannelSend = dc.send;
      dc.send = function send() {
        const data = arguments[0];
        const length = data.length || data.size || data.byteLength;
        if (dc.readyState === 'open' &&
            pc.sctp && length > pc.sctp.maxMessageSize) {
          throw new TypeError('Message too large (can send a maximum of ' +
            pc.sctp.maxMessageSize + ' bytes)');
        }
        return origDataChannelSend.apply(dc, arguments);
      };
    }
    const origCreateDataChannel =
      window.RTCPeerConnection.prototype.createDataChannel;
    window.RTCPeerConnection.prototype.createDataChannel =
      function createDataChannel() {
        const dataChannel = origCreateDataChannel.apply(this, arguments);
        wrapDcSend(dataChannel, this);
        return dataChannel;
      };
    wrapPeerConnectionEvent(window, 'datachannel', e => {
      wrapDcSend(e.channel, e.target);
      return e;
    });
  }


  /* shims RTCConnectionState by pretending it is the same as iceConnectionState.
   * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
   * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
   * since DTLS failures would be hidden. See
   * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
   * for the Firefox tracking bug.
   */
  function shimConnectionState(window) {
    if (!window.RTCPeerConnection ||
        'connectionState' in window.RTCPeerConnection.prototype) {
      return;
    }
    const proto = window.RTCPeerConnection.prototype;
    Object.defineProperty(proto, 'connectionState', {
      get() {
        return {
          completed: 'connected',
          checking: 'connecting'
        }[this.iceConnectionState] || this.iceConnectionState;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(proto, 'onconnectionstatechange', {
      get() {
        return this._onconnectionstatechange || null;
      },
      set(cb) {
        if (this._onconnectionstatechange) {
          this.removeEventListener('connectionstatechange',
            this._onconnectionstatechange);
          delete this._onconnectionstatechange;
        }
        if (cb) {
          this.addEventListener('connectionstatechange',
            this._onconnectionstatechange = cb);
        }
      },
      enumerable: true,
      configurable: true
    });

    ['setLocalDescription', 'setRemoteDescription'].forEach((method) => {
      const origMethod = proto[method];
      proto[method] = function() {
        if (!this._connectionstatechangepoly) {
          this._connectionstatechangepoly = e => {
            const pc = e.target;
            if (pc._lastConnectionState !== pc.connectionState) {
              pc._lastConnectionState = pc.connectionState;
              const newEvent = new Event('connectionstatechange', e);
              pc.dispatchEvent(newEvent);
            }
            return e;
          };
          this.addEventListener('iceconnectionstatechange',
            this._connectionstatechangepoly);
        }
        return origMethod.apply(this, arguments);
      };
    });
  }

  function removeExtmapAllowMixed(window, browserDetails) {
    /* remove a=extmap-allow-mixed for webrtc.org < M71 */
    if (!window.RTCPeerConnection) {
      return;
    }
    if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
      return;
    }
    if (browserDetails.browser === 'safari' && browserDetails.version >= 605) {
      return;
    }
    const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription =
    function setRemoteDescription(desc) {
      if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
        const sdp = desc.sdp.split('\n').filter((line) => {
          return line.trim() !== 'a=extmap-allow-mixed';
        }).join('\n');
        // Safari enforces read-only-ness of RTCSessionDescription fields.
        if (window.RTCSessionDescription &&
            desc instanceof window.RTCSessionDescription) {
          arguments[0] = new window.RTCSessionDescription({
            type: desc.type,
            sdp,
          });
        } else {
          desc.sdp = sdp;
        }
      }
      return nativeSRD.apply(this, arguments);
    };
  }

  function shimAddIceCandidateNullOrEmpty(window, browserDetails) {
    // Support for addIceCandidate(null or undefined)
    // as well as addIceCandidate({candidate: "", ...})
    // https://bugs.chromium.org/p/chromium/issues/detail?id=978582
    // Note: must be called before other polyfills which change the signature.
    if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {
      return;
    }
    const nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
      return;
    }
    window.RTCPeerConnection.prototype.addIceCandidate =
      function addIceCandidate() {
        if (!arguments[0]) {
          if (arguments[1]) {
            arguments[1].apply(null);
          }
          return Promise.resolve();
        }
        // Firefox 68+ emits and processes {candidate: "", ...}, ignore
        // in older versions.
        // Native support for ignoring exists for Chrome M77+.
        // Safari ignores as well, exact version unknown but works in the same
        // version that also ignores addIceCandidate(null).
        if (((browserDetails.browser === 'chrome' && browserDetails.version < 78)
             || (browserDetails.browser === 'firefox'
                 && browserDetails.version < 68)
             || (browserDetails.browser === 'safari'))
            && arguments[0] && arguments[0].candidate === '') {
          return Promise.resolve();
        }
        return nativeAddIceCandidate.apply(this, arguments);
      };
  }

  // Note: Make sure to call this ahead of APIs that modify
  // setLocalDescription.length
  function shimParameterlessSetLocalDescription(window, browserDetails) {
    if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {
      return;
    }
    const nativeSetLocalDescription =
        window.RTCPeerConnection.prototype.setLocalDescription;
    if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
      return;
    }
    window.RTCPeerConnection.prototype.setLocalDescription =
      function setLocalDescription() {
        let desc = arguments[0] || {};
        if (typeof desc !== 'object' || (desc.type && desc.sdp)) {
          return nativeSetLocalDescription.apply(this, arguments);
        }
        // The remaining steps should technically happen when SLD comes off the
        // RTCPeerConnection's operations chain (not ahead of going on it), but
        // this is too difficult to shim. Instead, this shim only covers the
        // common case where the operations chain is empty. This is imperfect, but
        // should cover many cases. Rationale: Even if we can't reduce the glare
        // window to zero on imperfect implementations, there's value in tapping
        // into the perfect negotiation pattern that several browsers support.
        desc = {type: desc.type, sdp: desc.sdp};
        if (!desc.type) {
          switch (this.signalingState) {
            case 'stable':
            case 'have-local-offer':
            case 'have-remote-pranswer':
              desc.type = 'offer';
              break;
            default:
              desc.type = 'answer';
              break;
          }
        }
        if (desc.sdp || (desc.type !== 'offer' && desc.type !== 'answer')) {
          return nativeSetLocalDescription.apply(this, [desc]);
        }
        const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;
        return func.apply(this)
          .then(d => nativeSetLocalDescription.apply(this, [d]));
      };
  }

  var commonShim = /*#__PURE__*/Object.freeze({
    __proto__: null,
    removeExtmapAllowMixed: removeExtmapAllowMixed,
    shimAddIceCandidateNullOrEmpty: shimAddIceCandidateNullOrEmpty,
    shimConnectionState: shimConnectionState,
    shimMaxMessageSize: shimMaxMessageSize,
    shimParameterlessSetLocalDescription: shimParameterlessSetLocalDescription,
    shimRTCIceCandidate: shimRTCIceCandidate,
    shimRTCIceCandidateRelayProtocol: shimRTCIceCandidateRelayProtocol,
    shimSendThrowTypeError: shimSendThrowTypeError
  });

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */

  // Shimming starts here.
  function adapterFactory({window} = {}, options = {
    shimChrome: true,
    shimFirefox: true,
    shimSafari: true,
  }) {
    // Utils.
    const logging = log;
    const browserDetails = detectBrowser(window);

    const adapter = {
      browserDetails,
      commonShim,
      extractVersion: extractVersion,
      disableLog: disableLog,
      disableWarnings: disableWarnings,
      // Expose sdp as a convenience. For production apps include directly.
      sdp,
    };

    // Shim browser if found.
    switch (browserDetails.browser) {
      case 'chrome':
        if (!chromeShim || !shimPeerConnection$1 ||
            !options.shimChrome) {
          logging('Chrome shim is not included in this adapter release.');
          return adapter;
        }
        if (browserDetails.version === null) {
          logging('Chrome shim can not determine version, not shimming.');
          return adapter;
        }
        logging('adapter.js shimming chrome.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = chromeShim;

        // Must be called before shimPeerConnection.
        shimAddIceCandidateNullOrEmpty(window, browserDetails);
        shimParameterlessSetLocalDescription(window);

        shimGetUserMedia$2(window, browserDetails);
        shimMediaStream(window);
        shimPeerConnection$1(window, browserDetails);
        shimOnTrack$1(window);
        shimAddTrackRemoveTrack(window, browserDetails);
        shimGetSendersWithDtmf(window);
        shimSenderReceiverGetStats(window);
        fixNegotiationNeeded(window, browserDetails);

        shimRTCIceCandidate(window);
        shimRTCIceCandidateRelayProtocol(window);
        shimConnectionState(window);
        shimMaxMessageSize(window, browserDetails);
        shimSendThrowTypeError(window);
        removeExtmapAllowMixed(window, browserDetails);
        break;
      case 'firefox':
        if (!firefoxShim || !shimPeerConnection ||
            !options.shimFirefox) {
          logging('Firefox shim is not included in this adapter release.');
          return adapter;
        }
        logging('adapter.js shimming firefox.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = firefoxShim;

        // Must be called before shimPeerConnection.
        shimAddIceCandidateNullOrEmpty(window, browserDetails);
        shimParameterlessSetLocalDescription(window);

        shimGetUserMedia$1(window, browserDetails);
        shimPeerConnection(window, browserDetails);
        shimOnTrack(window);
        shimRemoveStream(window);
        shimSenderGetStats(window);
        shimReceiverGetStats(window);
        shimRTCDataChannel(window);
        shimAddTransceiver(window);
        shimGetParameters(window);
        shimCreateOffer(window);
        shimCreateAnswer(window);

        shimRTCIceCandidate(window);
        shimConnectionState(window);
        shimMaxMessageSize(window, browserDetails);
        shimSendThrowTypeError(window);
        break;
      case 'safari':
        if (!safariShim || !options.shimSafari) {
          logging('Safari shim is not included in this adapter release.');
          return adapter;
        }
        logging('adapter.js shimming safari.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = safariShim;

        // Must be called before shimCallbackAPI.
        shimAddIceCandidateNullOrEmpty(window, browserDetails);
        shimParameterlessSetLocalDescription(window);

        shimRTCIceServerUrls(window);
        shimCreateOfferLegacy(window);
        shimCallbacksAPI(window);
        shimLocalStreamsAPI(window);
        shimRemoteStreamsAPI(window);
        shimTrackEventTransceiver(window);
        shimGetUserMedia(window);
        shimAudioContext(window);

        shimRTCIceCandidate(window);
        shimRTCIceCandidateRelayProtocol(window);
        shimMaxMessageSize(window, browserDetails);
        shimSendThrowTypeError(window);
        removeExtmapAllowMixed(window, browserDetails);
        break;
      default:
        logging('Unsupported browser!');
        break;
    }

    return adapter;
  }

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */


  adapterFactory({window: typeof window === 'undefined' ? undefined : window});

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise, SuppressedError, Symbol, Iterator */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };

  class InvalidTokenError extends Error {
  }
  InvalidTokenError.prototype.name = "InvalidTokenError";
  function b64DecodeUnicode(str) {
      return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {
          let code = p.charCodeAt(0).toString(16).toUpperCase();
          if (code.length < 2) {
              code = "0" + code;
          }
          return "%" + code;
      }));
  }
  function base64UrlDecode(str) {
      let output = str.replace(/-/g, "+").replace(/_/g, "/");
      switch (output.length % 4) {
          case 0:
              break;
          case 2:
              output += "==";
              break;
          case 3:
              output += "=";
              break;
          default:
              throw new Error("base64 string is not of the correct length");
      }
      try {
          return b64DecodeUnicode(output);
      }
      catch (err) {
          return atob(output);
      }
  }
  function jwtDecode(token, options) {
      if (typeof token !== "string") {
          throw new InvalidTokenError("Invalid token specified: must be a string");
      }
      options || (options = {});
      const pos = options.header === true ? 0 : 1;
      const part = token.split(".")[pos];
      if (typeof part !== "string") {
          throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
      }
      let decoded;
      try {
          decoded = base64UrlDecode(part);
      }
      catch (e) {
          throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);
      }
      try {
          return JSON.parse(decoded);
      }
      catch (e) {
          throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);
      }
  }

  // src/utils/Logger.ts
  var nopLogger = {
    debug: () => void 0,
    info: () => void 0,
    warn: () => void 0,
    error: () => void 0
  };
  var level;
  var logger;
  var Log = /* @__PURE__ */ ((Log2) => {
    Log2[Log2["NONE"] = 0] = "NONE";
    Log2[Log2["ERROR"] = 1] = "ERROR";
    Log2[Log2["WARN"] = 2] = "WARN";
    Log2[Log2["INFO"] = 3] = "INFO";
    Log2[Log2["DEBUG"] = 4] = "DEBUG";
    return Log2;
  })(Log || {});
  ((Log2) => {
    function reset() {
      level = 3 /* INFO */;
      logger = nopLogger;
    }
    Log2.reset = reset;
    function setLevel(value) {
      if (!(0 /* NONE */ <= value && value <= 4 /* DEBUG */)) {
        throw new Error("Invalid log level");
      }
      level = value;
    }
    Log2.setLevel = setLevel;
    function setLogger(value) {
      logger = value;
    }
    Log2.setLogger = setLogger;
  })(Log || (Log = {}));
  var Logger = class _Logger {
    constructor(_name) {
      this._name = _name;
    }
    /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */
    debug(...args) {
      if (level >= 4 /* DEBUG */) {
        logger.debug(_Logger._format(this._name, this._method), ...args);
      }
    }
    info(...args) {
      if (level >= 3 /* INFO */) {
        logger.info(_Logger._format(this._name, this._method), ...args);
      }
    }
    warn(...args) {
      if (level >= 2 /* WARN */) {
        logger.warn(_Logger._format(this._name, this._method), ...args);
      }
    }
    error(...args) {
      if (level >= 1 /* ERROR */) {
        logger.error(_Logger._format(this._name, this._method), ...args);
      }
    }
    /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */
    throw(err) {
      this.error(err);
      throw err;
    }
    create(method) {
      const methodLogger = Object.create(this);
      methodLogger._method = method;
      methodLogger.debug("begin");
      return methodLogger;
    }
    static createStatic(name, staticMethod) {
      const staticLogger = new _Logger(`${name}.${staticMethod}`);
      staticLogger.debug("begin");
      return staticLogger;
    }
    static _format(name, method) {
      const prefix = `[${name}]`;
      return method ? `${prefix} ${method}:` : prefix;
    }
    /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */
    // helpers for static class methods
    static debug(name, ...args) {
      if (level >= 4 /* DEBUG */) {
        logger.debug(_Logger._format(name), ...args);
      }
    }
    static info(name, ...args) {
      if (level >= 3 /* INFO */) {
        logger.info(_Logger._format(name), ...args);
      }
    }
    static warn(name, ...args) {
      if (level >= 2 /* WARN */) {
        logger.warn(_Logger._format(name), ...args);
      }
    }
    static error(name, ...args) {
      if (level >= 1 /* ERROR */) {
        logger.error(_Logger._format(name), ...args);
      }
    }
    /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */
  };
  Log.reset();

  // src/utils/CryptoUtils.ts
  var UUID_V4_TEMPLATE = "10000000-1000-4000-8000-100000000000";
  var toBase64 = (val) => btoa([...new Uint8Array(val)].map((chr) => String.fromCharCode(chr)).join(""));
  var CryptoUtils = class _CryptoUtils {
    static _randomWord() {
      const arr = new Uint32Array(1);
      crypto.getRandomValues(arr);
      return arr[0];
    }
    /**
     * Generates RFC4122 version 4 guid
     */
    static generateUUIDv4() {
      const uuid = UUID_V4_TEMPLATE.replace(
        /[018]/g,
        (c) => (+c ^ _CryptoUtils._randomWord() & 15 >> +c / 4).toString(16)
      );
      return uuid.replace(/-/g, "");
    }
    /**
     * PKCE: Generate a code verifier
     */
    static generateCodeVerifier() {
      return _CryptoUtils.generateUUIDv4() + _CryptoUtils.generateUUIDv4() + _CryptoUtils.generateUUIDv4();
    }
    /**
     * PKCE: Generate a code challenge
     */
    static async generateCodeChallenge(code_verifier) {
      if (!crypto.subtle) {
        throw new Error("Crypto.subtle is available only in secure contexts (HTTPS).");
      }
      try {
        const encoder = new TextEncoder();
        const data = encoder.encode(code_verifier);
        const hashed = await crypto.subtle.digest("SHA-256", data);
        return toBase64(hashed).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
      } catch (err) {
        Logger.error("CryptoUtils.generateCodeChallenge", err);
        throw err;
      }
    }
    /**
     * Generates a base64-encoded string for a basic auth header
     */
    static generateBasicAuth(client_id, client_secret) {
      const encoder = new TextEncoder();
      const data = encoder.encode([client_id, client_secret].join(":"));
      return toBase64(data);
    }
  };

  // src/utils/Event.ts
  var Event$1 = class Event {
    constructor(_name) {
      this._name = _name;
      this._logger = new Logger(`Event('${this._name}')`);
      this._callbacks = [];
    }
    addHandler(cb) {
      this._callbacks.push(cb);
      return () => this.removeHandler(cb);
    }
    removeHandler(cb) {
      const idx = this._callbacks.lastIndexOf(cb);
      if (idx >= 0) {
        this._callbacks.splice(idx, 1);
      }
    }
    async raise(...ev) {
      this._logger.debug("raise:", ...ev);
      for (const cb of this._callbacks) {
        await cb(...ev);
      }
    }
  };
  var JwtUtils = class {
    // IMPORTANT: doesn't validate the token
    static decode(token) {
      try {
        return jwtDecode(token);
      } catch (err) {
        Logger.error("JwtUtils.decode", err);
        throw err;
      }
    }
  };

  // src/utils/PopupUtils.ts
  var PopupUtils = class {
    /**
     * Populates a map of window features with a placement centered in front of
     * the current window. If no explicit width is given, a default value is
     * binned into [800, 720, 600, 480, 360] based on the current window's width.
     */
    static center({ ...features }) {
      var _a, _b, _c;
      if (features.width == null)
        features.width = (_a = [800, 720, 600, 480].find((width) => width <= window.outerWidth / 1.618)) != null ? _a : 360;
      (_b = features.left) != null ? _b : features.left = Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));
      if (features.height != null)
        (_c = features.top) != null ? _c : features.top = Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));
      return features;
    }
    static serialize(features) {
      return Object.entries(features).filter(([, value]) => value != null).map(([key, value]) => `${key}=${typeof value !== "boolean" ? value : value ? "yes" : "no"}`).join(",");
    }
  };

  // src/utils/Timer.ts
  var Timer = class _Timer extends Event$1 {
    constructor() {
      super(...arguments);
      this._logger = new Logger(`Timer('${this._name}')`);
      this._timerHandle = null;
      this._expiration = 0;
      this._callback = () => {
        const diff = this._expiration - _Timer.getEpochTime();
        this._logger.debug("timer completes in", diff);
        if (this._expiration <= _Timer.getEpochTime()) {
          this.cancel();
          void super.raise();
        }
      };
    }
    // get the time
    static getEpochTime() {
      return Math.floor(Date.now() / 1e3);
    }
    init(durationInSeconds) {
      const logger2 = this._logger.create("init");
      durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);
      const expiration = _Timer.getEpochTime() + durationInSeconds;
      if (this.expiration === expiration && this._timerHandle) {
        logger2.debug("skipping since already initialized for expiration at", this.expiration);
        return;
      }
      this.cancel();
      logger2.debug("using duration", durationInSeconds);
      this._expiration = expiration;
      const timerDurationInSeconds = Math.min(durationInSeconds, 5);
      this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1e3);
    }
    get expiration() {
      return this._expiration;
    }
    cancel() {
      this._logger.create("cancel");
      if (this._timerHandle) {
        clearInterval(this._timerHandle);
        this._timerHandle = null;
      }
    }
  };

  // src/utils/UrlUtils.ts
  var UrlUtils = class {
    static readParams(url, responseMode = "query") {
      if (!url)
        throw new TypeError("Invalid URL");
      const parsedUrl = new URL(url, "http://127.0.0.1");
      const params = parsedUrl[responseMode === "fragment" ? "hash" : "search"];
      return new URLSearchParams(params.slice(1));
    }
  };
  var URL_STATE_DELIMITER = ";";

  // src/errors/ErrorResponse.ts
  var ErrorResponse = class extends Error {
    constructor(args, form) {
      var _a, _b, _c;
      super(args.error_description || args.error || "");
      this.form = form;
      /** Marker to detect class: "ErrorResponse" */
      this.name = "ErrorResponse";
      if (!args.error) {
        Logger.error("ErrorResponse", "No error passed");
        throw new Error("No error passed");
      }
      this.error = args.error;
      this.error_description = (_a = args.error_description) != null ? _a : null;
      this.error_uri = (_b = args.error_uri) != null ? _b : null;
      this.state = args.userState;
      this.session_state = (_c = args.session_state) != null ? _c : null;
      this.url_state = args.url_state;
    }
  };

  // src/errors/ErrorTimeout.ts
  var ErrorTimeout = class extends Error {
    constructor(message) {
      super(message);
      /** Marker to detect class: "ErrorTimeout" */
      this.name = "ErrorTimeout";
    }
  };

  // src/AccessTokenEvents.ts
  var AccessTokenEvents = class {
    constructor(args) {
      this._logger = new Logger("AccessTokenEvents");
      this._expiringTimer = new Timer("Access token expiring");
      this._expiredTimer = new Timer("Access token expired");
      this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;
    }
    load(container) {
      const logger2 = this._logger.create("load");
      if (container.access_token && container.expires_in !== void 0) {
        const duration = container.expires_in;
        logger2.debug("access token present, remaining duration:", duration);
        if (duration > 0) {
          let expiring = duration - this._expiringNotificationTimeInSeconds;
          if (expiring <= 0) {
            expiring = 1;
          }
          logger2.debug("registering expiring timer, raising in", expiring, "seconds");
          this._expiringTimer.init(expiring);
        } else {
          logger2.debug("canceling existing expiring timer because we're past expiration.");
          this._expiringTimer.cancel();
        }
        const expired = duration + 1;
        logger2.debug("registering expired timer, raising in", expired, "seconds");
        this._expiredTimer.init(expired);
      } else {
        this._expiringTimer.cancel();
        this._expiredTimer.cancel();
      }
    }
    unload() {
      this._logger.debug("unload: canceling existing access token timers");
      this._expiringTimer.cancel();
      this._expiredTimer.cancel();
    }
    /**
     * Add callback: Raised prior to the access token expiring.
     */
    addAccessTokenExpiring(cb) {
      return this._expiringTimer.addHandler(cb);
    }
    /**
     * Remove callback: Raised prior to the access token expiring.
     */
    removeAccessTokenExpiring(cb) {
      this._expiringTimer.removeHandler(cb);
    }
    /**
     * Add callback: Raised after the access token has expired.
     */
    addAccessTokenExpired(cb) {
      return this._expiredTimer.addHandler(cb);
    }
    /**
     * Remove callback: Raised after the access token has expired.
     */
    removeAccessTokenExpired(cb) {
      this._expiredTimer.removeHandler(cb);
    }
  };

  // src/CheckSessionIFrame.ts
  var CheckSessionIFrame = class {
    constructor(_callback, _client_id, url, _intervalInSeconds, _stopOnError) {
      this._callback = _callback;
      this._client_id = _client_id;
      this._intervalInSeconds = _intervalInSeconds;
      this._stopOnError = _stopOnError;
      this._logger = new Logger("CheckSessionIFrame");
      this._timer = null;
      this._session_state = null;
      this._message = (e) => {
        if (e.origin === this._frame_origin && e.source === this._frame.contentWindow) {
          if (e.data === "error") {
            this._logger.error("error message from check session op iframe");
            if (this._stopOnError) {
              this.stop();
            }
          } else if (e.data === "changed") {
            this._logger.debug("changed message from check session op iframe");
            this.stop();
            void this._callback();
          } else {
            this._logger.debug(e.data + " message from check session op iframe");
          }
        }
      };
      const parsedUrl = new URL(url);
      this._frame_origin = parsedUrl.origin;
      this._frame = window.document.createElement("iframe");
      this._frame.style.visibility = "hidden";
      this._frame.style.position = "fixed";
      this._frame.style.left = "-1000px";
      this._frame.style.top = "0";
      this._frame.width = "0";
      this._frame.height = "0";
      this._frame.src = parsedUrl.href;
    }
    load() {
      return new Promise((resolve) => {
        this._frame.onload = () => {
          resolve();
        };
        window.document.body.appendChild(this._frame);
        window.addEventListener("message", this._message, false);
      });
    }
    start(session_state) {
      if (this._session_state === session_state) {
        return;
      }
      this._logger.create("start");
      this.stop();
      this._session_state = session_state;
      const send = () => {
        if (!this._frame.contentWindow || !this._session_state) {
          return;
        }
        this._frame.contentWindow.postMessage(this._client_id + " " + this._session_state, this._frame_origin);
      };
      send();
      this._timer = setInterval(send, this._intervalInSeconds * 1e3);
    }
    stop() {
      this._logger.create("stop");
      this._session_state = null;
      if (this._timer) {
        clearInterval(this._timer);
        this._timer = null;
      }
    }
  };

  // src/InMemoryWebStorage.ts
  var InMemoryWebStorage = class {
    constructor() {
      this._logger = new Logger("InMemoryWebStorage");
      this._data = {};
    }
    clear() {
      this._logger.create("clear");
      this._data = {};
    }
    getItem(key) {
      this._logger.create(`getItem('${key}')`);
      return this._data[key];
    }
    setItem(key, value) {
      this._logger.create(`setItem('${key}')`);
      this._data[key] = value;
    }
    removeItem(key) {
      this._logger.create(`removeItem('${key}')`);
      delete this._data[key];
    }
    get length() {
      return Object.getOwnPropertyNames(this._data).length;
    }
    key(index) {
      return Object.getOwnPropertyNames(this._data)[index];
    }
  };

  // src/JsonService.ts
  var JsonService = class {
    constructor(additionalContentTypes = [], _jwtHandler = null, _extraHeaders = {}) {
      this._jwtHandler = _jwtHandler;
      this._extraHeaders = _extraHeaders;
      this._logger = new Logger("JsonService");
      this._contentTypes = [];
      this._contentTypes.push(...additionalContentTypes, "application/json");
      if (_jwtHandler) {
        this._contentTypes.push("application/jwt");
      }
    }
    async fetchWithTimeout(input, init = {}) {
      const { timeoutInSeconds, ...initFetch } = init;
      if (!timeoutInSeconds) {
        return await fetch(input, initFetch);
      }
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1e3);
      try {
        const response = await fetch(input, {
          ...init,
          signal: controller.signal
        });
        return response;
      } catch (err) {
        if (err instanceof DOMException && err.name === "AbortError") {
          throw new ErrorTimeout("Network timed out");
        }
        throw err;
      } finally {
        clearTimeout(timeoutId);
      }
    }
    async getJson(url, {
      token,
      credentials
    } = {}) {
      const logger2 = this._logger.create("getJson");
      const headers = {
        "Accept": this._contentTypes.join(", ")
      };
      if (token) {
        logger2.debug("token passed, setting Authorization header");
        headers["Authorization"] = "Bearer " + token;
      }
      this.appendExtraHeaders(headers);
      let response;
      try {
        logger2.debug("url:", url);
        response = await this.fetchWithTimeout(url, { method: "GET", headers, credentials });
      } catch (err) {
        logger2.error("Network Error");
        throw err;
      }
      logger2.debug("HTTP response received, status", response.status);
      const contentType = response.headers.get("Content-Type");
      if (contentType && !this._contentTypes.find((item) => contentType.startsWith(item))) {
        logger2.throw(new Error(`Invalid response Content-Type: ${contentType != null ? contentType : "undefined"}, from URL: ${url}`));
      }
      if (response.ok && this._jwtHandler && (contentType == null ? void 0 : contentType.startsWith("application/jwt"))) {
        return await this._jwtHandler(await response.text());
      }
      let json;
      try {
        json = await response.json();
      } catch (err) {
        logger2.error("Error parsing JSON response", err);
        if (response.ok)
          throw err;
        throw new Error(`${response.statusText} (${response.status})`);
      }
      if (!response.ok) {
        logger2.error("Error from server:", json);
        if (json.error) {
          throw new ErrorResponse(json);
        }
        throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);
      }
      return json;
    }
    async postForm(url, {
      body,
      basicAuth,
      timeoutInSeconds,
      initCredentials
    }) {
      const logger2 = this._logger.create("postForm");
      const headers = {
        "Accept": this._contentTypes.join(", "),
        "Content-Type": "application/x-www-form-urlencoded"
      };
      if (basicAuth !== void 0) {
        headers["Authorization"] = "Basic " + basicAuth;
      }
      this.appendExtraHeaders(headers);
      let response;
      try {
        logger2.debug("url:", url);
        response = await this.fetchWithTimeout(url, { method: "POST", headers, body, timeoutInSeconds, credentials: initCredentials });
      } catch (err) {
        logger2.error("Network error");
        throw err;
      }
      logger2.debug("HTTP response received, status", response.status);
      const contentType = response.headers.get("Content-Type");
      if (contentType && !this._contentTypes.find((item) => contentType.startsWith(item))) {
        throw new Error(`Invalid response Content-Type: ${contentType != null ? contentType : "undefined"}, from URL: ${url}`);
      }
      const responseText = await response.text();
      let json = {};
      if (responseText) {
        try {
          json = JSON.parse(responseText);
        } catch (err) {
          logger2.error("Error parsing JSON response", err);
          if (response.ok)
            throw err;
          throw new Error(`${response.statusText} (${response.status})`);
        }
      }
      if (!response.ok) {
        logger2.error("Error from server:", json);
        if (json.error) {
          throw new ErrorResponse(json, body);
        }
        throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);
      }
      return json;
    }
    appendExtraHeaders(headers) {
      const logger2 = this._logger.create("appendExtraHeaders");
      const customKeys = Object.keys(this._extraHeaders);
      const protectedHeaders = [
        "authorization",
        "accept",
        "content-type"
      ];
      if (customKeys.length === 0) {
        return;
      }
      customKeys.forEach((headerName) => {
        if (protectedHeaders.includes(headerName.toLocaleLowerCase())) {
          logger2.warn("Protected header could not be overridden", headerName, protectedHeaders);
          return;
        }
        const content = typeof this._extraHeaders[headerName] === "function" ? this._extraHeaders[headerName]() : this._extraHeaders[headerName];
        if (content && content !== "") {
          headers[headerName] = content;
        }
      });
    }
  };

  // src/MetadataService.ts
  var MetadataService = class {
    constructor(_settings) {
      this._settings = _settings;
      this._logger = new Logger("MetadataService");
      this._signingKeys = null;
      this._metadata = null;
      this._metadataUrl = this._settings.metadataUrl;
      this._jsonService = new JsonService(
        ["application/jwk-set+json"],
        null,
        this._settings.extraHeaders
      );
      if (this._settings.signingKeys) {
        this._logger.debug("using signingKeys from settings");
        this._signingKeys = this._settings.signingKeys;
      }
      if (this._settings.metadata) {
        this._logger.debug("using metadata from settings");
        this._metadata = this._settings.metadata;
      }
      if (this._settings.fetchRequestCredentials) {
        this._logger.debug("using fetchRequestCredentials from settings");
        this._fetchRequestCredentials = this._settings.fetchRequestCredentials;
      }
    }
    resetSigningKeys() {
      this._signingKeys = null;
    }
    async getMetadata() {
      const logger2 = this._logger.create("getMetadata");
      if (this._metadata) {
        logger2.debug("using cached values");
        return this._metadata;
      }
      if (!this._metadataUrl) {
        logger2.throw(new Error("No authority or metadataUrl configured on settings"));
        throw null;
      }
      logger2.debug("getting metadata from", this._metadataUrl);
      const metadata = await this._jsonService.getJson(this._metadataUrl, { credentials: this._fetchRequestCredentials });
      logger2.debug("merging remote JSON with seed metadata");
      this._metadata = Object.assign({}, this._settings.metadataSeed, metadata);
      return this._metadata;
    }
    getIssuer() {
      return this._getMetadataProperty("issuer");
    }
    getAuthorizationEndpoint() {
      return this._getMetadataProperty("authorization_endpoint");
    }
    getUserInfoEndpoint() {
      return this._getMetadataProperty("userinfo_endpoint");
    }
    getTokenEndpoint(optional = true) {
      return this._getMetadataProperty("token_endpoint", optional);
    }
    getCheckSessionIframe() {
      return this._getMetadataProperty("check_session_iframe", true);
    }
    getEndSessionEndpoint() {
      return this._getMetadataProperty("end_session_endpoint", true);
    }
    getRevocationEndpoint(optional = true) {
      return this._getMetadataProperty("revocation_endpoint", optional);
    }
    getKeysEndpoint(optional = true) {
      return this._getMetadataProperty("jwks_uri", optional);
    }
    async _getMetadataProperty(name, optional = false) {
      const logger2 = this._logger.create(`_getMetadataProperty('${name}')`);
      const metadata = await this.getMetadata();
      logger2.debug("resolved");
      if (metadata[name] === void 0) {
        if (optional === true) {
          logger2.warn("Metadata does not contain optional property");
          return void 0;
        }
        logger2.throw(new Error("Metadata does not contain property " + name));
      }
      return metadata[name];
    }
    async getSigningKeys() {
      const logger2 = this._logger.create("getSigningKeys");
      if (this._signingKeys) {
        logger2.debug("returning signingKeys from cache");
        return this._signingKeys;
      }
      const jwks_uri = await this.getKeysEndpoint(false);
      logger2.debug("got jwks_uri", jwks_uri);
      const keySet = await this._jsonService.getJson(jwks_uri);
      logger2.debug("got key set", keySet);
      if (!Array.isArray(keySet.keys)) {
        logger2.throw(new Error("Missing keys on keyset"));
        throw null;
      }
      this._signingKeys = keySet.keys;
      return this._signingKeys;
    }
  };

  // src/WebStorageStateStore.ts
  var WebStorageStateStore = class {
    constructor({
      prefix = "oidc.",
      store = localStorage
    } = {}) {
      this._logger = new Logger("WebStorageStateStore");
      this._store = store;
      this._prefix = prefix;
    }
    async set(key, value) {
      this._logger.create(`set('${key}')`);
      key = this._prefix + key;
      await this._store.setItem(key, value);
    }
    async get(key) {
      this._logger.create(`get('${key}')`);
      key = this._prefix + key;
      const item = await this._store.getItem(key);
      return item;
    }
    async remove(key) {
      this._logger.create(`remove('${key}')`);
      key = this._prefix + key;
      const item = await this._store.getItem(key);
      await this._store.removeItem(key);
      return item;
    }
    async getAllKeys() {
      this._logger.create("getAllKeys");
      const len = await this._store.length;
      const keys = [];
      for (let index = 0; index < len; index++) {
        const key = await this._store.key(index);
        if (key && key.indexOf(this._prefix) === 0) {
          keys.push(key.substr(this._prefix.length));
        }
      }
      return keys;
    }
  };

  // src/OidcClientSettings.ts
  var DefaultResponseType = "code";
  var DefaultScope = "openid";
  var DefaultClientAuthentication = "client_secret_post";
  var DefaultStaleStateAgeInSeconds = 60 * 15;
  var OidcClientSettingsStore = class {
    constructor({
      // metadata related
      authority,
      metadataUrl,
      metadata,
      signingKeys,
      metadataSeed,
      // client related
      client_id,
      client_secret,
      response_type = DefaultResponseType,
      scope = DefaultScope,
      redirect_uri,
      post_logout_redirect_uri,
      client_authentication = DefaultClientAuthentication,
      // optional protocol
      prompt,
      display,
      max_age,
      ui_locales,
      acr_values,
      resource,
      response_mode,
      // behavior flags
      filterProtocolClaims = true,
      loadUserInfo = false,
      staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,
      mergeClaimsStrategy = { array: "replace" },
      disablePKCE = false,
      // other behavior
      stateStore,
      revokeTokenAdditionalContentTypes,
      fetchRequestCredentials,
      refreshTokenAllowedScope,
      // extra
      extraQueryParams = {},
      extraTokenParams = {},
      extraHeaders = {}
    }) {
      this.authority = authority;
      if (metadataUrl) {
        this.metadataUrl = metadataUrl;
      } else {
        this.metadataUrl = authority;
        if (authority) {
          if (!this.metadataUrl.endsWith("/")) {
            this.metadataUrl += "/";
          }
          this.metadataUrl += ".well-known/openid-configuration";
        }
      }
      this.metadata = metadata;
      this.metadataSeed = metadataSeed;
      this.signingKeys = signingKeys;
      this.client_id = client_id;
      this.client_secret = client_secret;
      this.response_type = response_type;
      this.scope = scope;
      this.redirect_uri = redirect_uri;
      this.post_logout_redirect_uri = post_logout_redirect_uri;
      this.client_authentication = client_authentication;
      this.prompt = prompt;
      this.display = display;
      this.max_age = max_age;
      this.ui_locales = ui_locales;
      this.acr_values = acr_values;
      this.resource = resource;
      this.response_mode = response_mode;
      this.filterProtocolClaims = filterProtocolClaims != null ? filterProtocolClaims : true;
      this.loadUserInfo = !!loadUserInfo;
      this.staleStateAgeInSeconds = staleStateAgeInSeconds;
      this.mergeClaimsStrategy = mergeClaimsStrategy;
      this.disablePKCE = !!disablePKCE;
      this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;
      this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials : "same-origin";
      if (stateStore) {
        this.stateStore = stateStore;
      } else {
        const store = typeof window !== "undefined" ? window.localStorage : new InMemoryWebStorage();
        this.stateStore = new WebStorageStateStore({ store });
      }
      this.refreshTokenAllowedScope = refreshTokenAllowedScope;
      this.extraQueryParams = extraQueryParams;
      this.extraTokenParams = extraTokenParams;
      this.extraHeaders = extraHeaders;
    }
  };

  // src/UserInfoService.ts
  var UserInfoService = class {
    constructor(_settings, _metadataService) {
      this._settings = _settings;
      this._metadataService = _metadataService;
      this._logger = new Logger("UserInfoService");
      this._getClaimsFromJwt = async (responseText) => {
        const logger2 = this._logger.create("_getClaimsFromJwt");
        try {
          const payload = JwtUtils.decode(responseText);
          logger2.debug("JWT decoding successful");
          return payload;
        } catch (err) {
          logger2.error("Error parsing JWT response");
          throw err;
        }
      };
      this._jsonService = new JsonService(
        void 0,
        this._getClaimsFromJwt,
        this._settings.extraHeaders
      );
    }
    async getClaims(token) {
      const logger2 = this._logger.create("getClaims");
      if (!token) {
        this._logger.throw(new Error("No token passed"));
      }
      const url = await this._metadataService.getUserInfoEndpoint();
      logger2.debug("got userinfo url", url);
      const claims = await this._jsonService.getJson(url, {
        token,
        credentials: this._settings.fetchRequestCredentials
      });
      logger2.debug("got claims", claims);
      return claims;
    }
  };

  // src/TokenClient.ts
  var TokenClient = class {
    constructor(_settings, _metadataService) {
      this._settings = _settings;
      this._metadataService = _metadataService;
      this._logger = new Logger("TokenClient");
      this._jsonService = new JsonService(
        this._settings.revokeTokenAdditionalContentTypes,
        null,
        this._settings.extraHeaders
      );
    }
    /**
     * Exchange code.
     *
     * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3
     */
    async exchangeCode({
      grant_type = "authorization_code",
      redirect_uri = this._settings.redirect_uri,
      client_id = this._settings.client_id,
      client_secret = this._settings.client_secret,
      ...args
    }) {
      const logger2 = this._logger.create("exchangeCode");
      if (!client_id) {
        logger2.throw(new Error("A client_id is required"));
      }
      if (!redirect_uri) {
        logger2.throw(new Error("A redirect_uri is required"));
      }
      if (!args.code) {
        logger2.throw(new Error("A code is required"));
      }
      const params = new URLSearchParams({ grant_type, redirect_uri });
      for (const [key, value] of Object.entries(args)) {
        if (value != null) {
          params.set(key, value);
        }
      }
      let basicAuth;
      switch (this._settings.client_authentication) {
        case "client_secret_basic":
          if (!client_secret) {
            logger2.throw(new Error("A client_secret is required"));
            throw null;
          }
          basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);
          break;
        case "client_secret_post":
          params.append("client_id", client_id);
          if (client_secret) {
            params.append("client_secret", client_secret);
          }
          break;
      }
      const url = await this._metadataService.getTokenEndpoint(false);
      logger2.debug("got token endpoint");
      const response = await this._jsonService.postForm(url, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });
      logger2.debug("got response");
      return response;
    }
    /**
     * Exchange credentials.
     *
     * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2
     */
    async exchangeCredentials({
      grant_type = "password",
      client_id = this._settings.client_id,
      client_secret = this._settings.client_secret,
      scope = this._settings.scope,
      ...args
    }) {
      const logger2 = this._logger.create("exchangeCredentials");
      if (!client_id) {
        logger2.throw(new Error("A client_id is required"));
      }
      const params = new URLSearchParams({ grant_type, scope });
      for (const [key, value] of Object.entries(args)) {
        if (value != null) {
          params.set(key, value);
        }
      }
      let basicAuth;
      switch (this._settings.client_authentication) {
        case "client_secret_basic":
          if (!client_secret) {
            logger2.throw(new Error("A client_secret is required"));
            throw null;
          }
          basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);
          break;
        case "client_secret_post":
          params.append("client_id", client_id);
          if (client_secret) {
            params.append("client_secret", client_secret);
          }
          break;
      }
      const url = await this._metadataService.getTokenEndpoint(false);
      logger2.debug("got token endpoint");
      const response = await this._jsonService.postForm(url, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });
      logger2.debug("got response");
      return response;
    }
    /**
     * Exchange a refresh token.
     *
     * @see https://www.rfc-editor.org/rfc/rfc6749#section-6
     */
    async exchangeRefreshToken({
      grant_type = "refresh_token",
      client_id = this._settings.client_id,
      client_secret = this._settings.client_secret,
      timeoutInSeconds,
      ...args
    }) {
      const logger2 = this._logger.create("exchangeRefreshToken");
      if (!client_id) {
        logger2.throw(new Error("A client_id is required"));
      }
      if (!args.refresh_token) {
        logger2.throw(new Error("A refresh_token is required"));
      }
      const params = new URLSearchParams({ grant_type });
      for (const [key, value] of Object.entries(args)) {
        if (Array.isArray(value)) {
          value.forEach((param) => params.append(key, param));
        } else if (value != null) {
          params.set(key, value);
        }
      }
      let basicAuth;
      switch (this._settings.client_authentication) {
        case "client_secret_basic":
          if (!client_secret) {
            logger2.throw(new Error("A client_secret is required"));
            throw null;
          }
          basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);
          break;
        case "client_secret_post":
          params.append("client_id", client_id);
          if (client_secret) {
            params.append("client_secret", client_secret);
          }
          break;
      }
      const url = await this._metadataService.getTokenEndpoint(false);
      logger2.debug("got token endpoint");
      const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials });
      logger2.debug("got response");
      return response;
    }
    /**
     * Revoke an access or refresh token.
     *
     * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1
     */
    async revoke(args) {
      var _a;
      const logger2 = this._logger.create("revoke");
      if (!args.token) {
        logger2.throw(new Error("A token is required"));
      }
      const url = await this._metadataService.getRevocationEndpoint(false);
      logger2.debug(`got revocation endpoint, revoking ${(_a = args.token_type_hint) != null ? _a : "default token type"}`);
      const params = new URLSearchParams();
      for (const [key, value] of Object.entries(args)) {
        if (value != null) {
          params.set(key, value);
        }
      }
      params.set("client_id", this._settings.client_id);
      if (this._settings.client_secret) {
        params.set("client_secret", this._settings.client_secret);
      }
      await this._jsonService.postForm(url, { body: params });
      logger2.debug("got response");
    }
  };

  // src/ResponseValidator.ts
  var ResponseValidator = class {
    constructor(_settings, _metadataService, _claimsService) {
      this._settings = _settings;
      this._metadataService = _metadataService;
      this._claimsService = _claimsService;
      this._logger = new Logger("ResponseValidator");
      this._userInfoService = new UserInfoService(this._settings, this._metadataService);
      this._tokenClient = new TokenClient(this._settings, this._metadataService);
    }
    async validateSigninResponse(response, state) {
      const logger2 = this._logger.create("validateSigninResponse");
      this._processSigninState(response, state);
      logger2.debug("state processed");
      await this._processCode(response, state);
      logger2.debug("code processed");
      if (response.isOpenId) {
        this._validateIdTokenAttributes(response);
      }
      logger2.debug("tokens validated");
      await this._processClaims(response, state == null ? void 0 : state.skipUserInfo, response.isOpenId);
      logger2.debug("claims processed");
    }
    async validateCredentialsResponse(response, skipUserInfo) {
      const logger2 = this._logger.create("validateCredentialsResponse");
      if (response.isOpenId && !!response.id_token) {
        this._validateIdTokenAttributes(response);
      }
      logger2.debug("tokens validated");
      await this._processClaims(response, skipUserInfo, response.isOpenId);
      logger2.debug("claims processed");
    }
    async validateRefreshResponse(response, state) {
      var _a, _b;
      const logger2 = this._logger.create("validateRefreshResponse");
      response.userState = state.data;
      (_a = response.session_state) != null ? _a : response.session_state = state.session_state;
      (_b = response.scope) != null ? _b : response.scope = state.scope;
      if (response.isOpenId && !!response.id_token) {
        this._validateIdTokenAttributes(response, state.id_token);
        logger2.debug("ID Token validated");
      }
      if (!response.id_token) {
        response.id_token = state.id_token;
        response.profile = state.profile;
      }
      const hasIdToken = response.isOpenId && !!response.id_token;
      await this._processClaims(response, false, hasIdToken);
      logger2.debug("claims processed");
    }
    validateSignoutResponse(response, state) {
      const logger2 = this._logger.create("validateSignoutResponse");
      if (state.id !== response.state) {
        logger2.throw(new Error("State does not match"));
      }
      logger2.debug("state validated");
      response.userState = state.data;
      if (response.error) {
        logger2.warn("Response was error", response.error);
        throw new ErrorResponse(response);
      }
    }
    _processSigninState(response, state) {
      var _a;
      const logger2 = this._logger.create("_processSigninState");
      if (state.id !== response.state) {
        logger2.throw(new Error("State does not match"));
      }
      if (!state.client_id) {
        logger2.throw(new Error("No client_id on state"));
      }
      if (!state.authority) {
        logger2.throw(new Error("No authority on state"));
      }
      if (this._settings.authority !== state.authority) {
        logger2.throw(new Error("authority mismatch on settings vs. signin state"));
      }
      if (this._settings.client_id && this._settings.client_id !== state.client_id) {
        logger2.throw(new Error("client_id mismatch on settings vs. signin state"));
      }
      logger2.debug("state validated");
      response.userState = state.data;
      response.url_state = state.url_state;
      (_a = response.scope) != null ? _a : response.scope = state.scope;
      if (response.error) {
        logger2.warn("Response was error", response.error);
        throw new ErrorResponse(response);
      }
      if (state.code_verifier && !response.code) {
        logger2.throw(new Error("Expected code in response"));
      }
    }
    async _processClaims(response, skipUserInfo = false, validateSub = true) {
      const logger2 = this._logger.create("_processClaims");
      response.profile = this._claimsService.filterProtocolClaims(response.profile);
      if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {
        logger2.debug("not loading user info");
        return;
      }
      logger2.debug("loading user info");
      const claims = await this._userInfoService.getClaims(response.access_token);
      logger2.debug("user info claims received from user info endpoint");
      if (validateSub && claims.sub !== response.profile.sub) {
        logger2.throw(new Error("subject from UserInfo response does not match subject in ID Token"));
      }
      response.profile = this._claimsService.mergeClaims(response.profile, this._claimsService.filterProtocolClaims(claims));
      logger2.debug("user info claims received, updated profile:", response.profile);
    }
    async _processCode(response, state) {
      const logger2 = this._logger.create("_processCode");
      if (response.code) {
        logger2.debug("Validating code");
        const tokenResponse = await this._tokenClient.exchangeCode({
          client_id: state.client_id,
          client_secret: state.client_secret,
          code: response.code,
          redirect_uri: state.redirect_uri,
          code_verifier: state.code_verifier,
          ...state.extraTokenParams
        });
        Object.assign(response, tokenResponse);
      } else {
        logger2.debug("No code to process");
      }
    }
    _validateIdTokenAttributes(response, existingToken) {
      var _a;
      const logger2 = this._logger.create("_validateIdTokenAttributes");
      logger2.debug("decoding ID Token JWT");
      const incoming = JwtUtils.decode((_a = response.id_token) != null ? _a : "");
      if (!incoming.sub) {
        logger2.throw(new Error("ID Token is missing a subject claim"));
      }
      if (existingToken) {
        const existing = JwtUtils.decode(existingToken);
        if (incoming.sub !== existing.sub) {
          logger2.throw(new Error("sub in id_token does not match current sub"));
        }
        if (incoming.auth_time && incoming.auth_time !== existing.auth_time) {
          logger2.throw(new Error("auth_time in id_token does not match original auth_time"));
        }
        if (incoming.azp && incoming.azp !== existing.azp) {
          logger2.throw(new Error("azp in id_token does not match original azp"));
        }
        if (!incoming.azp && existing.azp) {
          logger2.throw(new Error("azp not in id_token, but present in original id_token"));
        }
      }
      response.profile = incoming;
    }
  };

  // src/State.ts
  var State = class _State {
    constructor(args) {
      this.id = args.id || CryptoUtils.generateUUIDv4();
      this.data = args.data;
      if (args.created && args.created > 0) {
        this.created = args.created;
      } else {
        this.created = Timer.getEpochTime();
      }
      this.request_type = args.request_type;
      this.url_state = args.url_state;
    }
    toStorageString() {
      new Logger("State").create("toStorageString");
      return JSON.stringify({
        id: this.id,
        data: this.data,
        created: this.created,
        request_type: this.request_type,
        url_state: this.url_state
      });
    }
    static fromStorageString(storageString) {
      Logger.createStatic("State", "fromStorageString");
      return Promise.resolve(new _State(JSON.parse(storageString)));
    }
    static async clearStaleState(storage, age) {
      const logger2 = Logger.createStatic("State", "clearStaleState");
      const cutoff = Timer.getEpochTime() - age;
      const keys = await storage.getAllKeys();
      logger2.debug("got keys", keys);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const item = await storage.get(key);
        let remove = false;
        if (item) {
          try {
            const state = await _State.fromStorageString(item);
            logger2.debug("got item from key:", key, state.created);
            if (state.created <= cutoff) {
              remove = true;
            }
          } catch (err) {
            logger2.error("Error parsing state for key:", key, err);
            remove = true;
          }
        } else {
          logger2.debug("no item in storage for key:", key);
          remove = true;
        }
        if (remove) {
          logger2.debug("removed item for key:", key);
          void storage.remove(key);
        }
      }
    }
  };

  // src/SigninState.ts
  var SigninState = class _SigninState extends State {
    constructor(args) {
      super(args);
      this.code_verifier = args.code_verifier;
      this.code_challenge = args.code_challenge;
      this.authority = args.authority;
      this.client_id = args.client_id;
      this.redirect_uri = args.redirect_uri;
      this.scope = args.scope;
      this.client_secret = args.client_secret;
      this.extraTokenParams = args.extraTokenParams;
      this.response_mode = args.response_mode;
      this.skipUserInfo = args.skipUserInfo;
    }
    static async create(args) {
      const code_verifier = args.code_verifier === true ? CryptoUtils.generateCodeVerifier() : args.code_verifier || void 0;
      const code_challenge = code_verifier ? await CryptoUtils.generateCodeChallenge(code_verifier) : void 0;
      return new _SigninState({
        ...args,
        code_verifier,
        code_challenge
      });
    }
    toStorageString() {
      new Logger("SigninState").create("toStorageString");
      return JSON.stringify({
        id: this.id,
        data: this.data,
        created: this.created,
        request_type: this.request_type,
        url_state: this.url_state,
        code_verifier: this.code_verifier,
        authority: this.authority,
        client_id: this.client_id,
        redirect_uri: this.redirect_uri,
        scope: this.scope,
        client_secret: this.client_secret,
        extraTokenParams: this.extraTokenParams,
        response_mode: this.response_mode,
        skipUserInfo: this.skipUserInfo
      });
    }
    static fromStorageString(storageString) {
      Logger.createStatic("SigninState", "fromStorageString");
      const data = JSON.parse(storageString);
      return _SigninState.create(data);
    }
  };

  // src/SigninRequest.ts
  var _SigninRequest = class _SigninRequest {
    constructor(args) {
      this.url = args.url;
      this.state = args.state;
    }
    static async create({
      // mandatory
      url,
      authority,
      client_id,
      redirect_uri,
      response_type,
      scope,
      // optional
      state_data,
      response_mode,
      request_type,
      client_secret,
      nonce,
      url_state,
      resource,
      skipUserInfo,
      extraQueryParams,
      extraTokenParams,
      disablePKCE,
      ...optionalParams
    }) {
      if (!url) {
        this._logger.error("create: No url passed");
        throw new Error("url");
      }
      if (!client_id) {
        this._logger.error("create: No client_id passed");
        throw new Error("client_id");
      }
      if (!redirect_uri) {
        this._logger.error("create: No redirect_uri passed");
        throw new Error("redirect_uri");
      }
      if (!response_type) {
        this._logger.error("create: No response_type passed");
        throw new Error("response_type");
      }
      if (!scope) {
        this._logger.error("create: No scope passed");
        throw new Error("scope");
      }
      if (!authority) {
        this._logger.error("create: No authority passed");
        throw new Error("authority");
      }
      const state = await SigninState.create({
        data: state_data,
        request_type,
        url_state,
        code_verifier: !disablePKCE,
        client_id,
        authority,
        redirect_uri,
        response_mode,
        client_secret,
        scope,
        extraTokenParams,
        skipUserInfo
      });
      const parsedUrl = new URL(url);
      parsedUrl.searchParams.append("client_id", client_id);
      parsedUrl.searchParams.append("redirect_uri", redirect_uri);
      parsedUrl.searchParams.append("response_type", response_type);
      parsedUrl.searchParams.append("scope", scope);
      if (nonce) {
        parsedUrl.searchParams.append("nonce", nonce);
      }
      let stateParam = state.id;
      if (url_state) {
        stateParam = `${stateParam}${URL_STATE_DELIMITER}${url_state}`;
      }
      parsedUrl.searchParams.append("state", stateParam);
      if (state.code_challenge) {
        parsedUrl.searchParams.append("code_challenge", state.code_challenge);
        parsedUrl.searchParams.append("code_challenge_method", "S256");
      }
      if (resource) {
        const resources = Array.isArray(resource) ? resource : [resource];
        resources.forEach((r) => parsedUrl.searchParams.append("resource", r));
      }
      for (const [key, value] of Object.entries({ response_mode, ...optionalParams, ...extraQueryParams })) {
        if (value != null) {
          parsedUrl.searchParams.append(key, value.toString());
        }
      }
      return new _SigninRequest({
        url: parsedUrl.href,
        state
      });
    }
  };
  _SigninRequest._logger = new Logger("SigninRequest");
  var SigninRequest = _SigninRequest;

  // src/SigninResponse.ts
  var OidcScope = "openid";
  var SigninResponse = class {
    constructor(params) {
      /** @see {@link User.access_token} */
      this.access_token = "";
      /** @see {@link User.token_type} */
      this.token_type = "";
      /** @see {@link User.profile} */
      this.profile = {};
      this.state = params.get("state");
      this.session_state = params.get("session_state");
      if (this.state) {
        const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);
        this.state = splitState[0];
        if (splitState.length > 1) {
          this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);
        }
      }
      this.error = params.get("error");
      this.error_description = params.get("error_description");
      this.error_uri = params.get("error_uri");
      this.code = params.get("code");
    }
    get expires_in() {
      if (this.expires_at === void 0) {
        return void 0;
      }
      return this.expires_at - Timer.getEpochTime();
    }
    set expires_in(value) {
      if (typeof value === "string")
        value = Number(value);
      if (value !== void 0 && value >= 0) {
        this.expires_at = Math.floor(value) + Timer.getEpochTime();
      }
    }
    get isOpenId() {
      var _a;
      return ((_a = this.scope) == null ? void 0 : _a.split(" ").includes(OidcScope)) || !!this.id_token;
    }
  };

  // src/SignoutRequest.ts
  var SignoutRequest = class {
    constructor({
      url,
      state_data,
      id_token_hint,
      post_logout_redirect_uri,
      extraQueryParams,
      request_type,
      client_id
    }) {
      this._logger = new Logger("SignoutRequest");
      if (!url) {
        this._logger.error("ctor: No url passed");
        throw new Error("url");
      }
      const parsedUrl = new URL(url);
      if (id_token_hint) {
        parsedUrl.searchParams.append("id_token_hint", id_token_hint);
      }
      if (client_id) {
        parsedUrl.searchParams.append("client_id", client_id);
      }
      if (post_logout_redirect_uri) {
        parsedUrl.searchParams.append("post_logout_redirect_uri", post_logout_redirect_uri);
        if (state_data) {
          this.state = new State({ data: state_data, request_type });
          parsedUrl.searchParams.append("state", this.state.id);
        }
      }
      for (const [key, value] of Object.entries({ ...extraQueryParams })) {
        if (value != null) {
          parsedUrl.searchParams.append(key, value.toString());
        }
      }
      this.url = parsedUrl.href;
    }
  };

  // src/SignoutResponse.ts
  var SignoutResponse = class {
    constructor(params) {
      this.state = params.get("state");
      this.error = params.get("error");
      this.error_description = params.get("error_description");
      this.error_uri = params.get("error_uri");
    }
  };

  // src/ClaimsService.ts
  var DefaultProtocolClaims = [
    "nbf",
    "jti",
    "auth_time",
    "nonce",
    "acr",
    "amr",
    "azp",
    "at_hash"
    // https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken
  ];
  var InternalRequiredProtocolClaims = ["sub", "iss", "aud", "exp", "iat"];
  var ClaimsService = class {
    constructor(_settings) {
      this._settings = _settings;
      this._logger = new Logger("ClaimsService");
    }
    filterProtocolClaims(claims) {
      const result = { ...claims };
      if (this._settings.filterProtocolClaims) {
        let protocolClaims;
        if (Array.isArray(this._settings.filterProtocolClaims)) {
          protocolClaims = this._settings.filterProtocolClaims;
        } else {
          protocolClaims = DefaultProtocolClaims;
        }
        for (const claim of protocolClaims) {
          if (!InternalRequiredProtocolClaims.includes(claim)) {
            delete result[claim];
          }
        }
      }
      return result;
    }
    mergeClaims(claims1, claims2) {
      const result = { ...claims1 };
      for (const [claim, values] of Object.entries(claims2)) {
        if (result[claim] !== values) {
          if (Array.isArray(result[claim]) || Array.isArray(values)) {
            if (this._settings.mergeClaimsStrategy.array == "replace") {
              result[claim] = values;
            } else {
              const mergedValues = Array.isArray(result[claim]) ? result[claim] : [result[claim]];
              for (const value of Array.isArray(values) ? values : [values]) {
                if (!mergedValues.includes(value)) {
                  mergedValues.push(value);
                }
              }
              result[claim] = mergedValues;
            }
          } else if (typeof result[claim] === "object" && typeof values === "object") {
            result[claim] = this.mergeClaims(result[claim], values);
          } else {
            result[claim] = values;
          }
        }
      }
      return result;
    }
  };

  // src/OidcClient.ts
  var OidcClient = class {
    constructor(settings, metadataService) {
      this._logger = new Logger("OidcClient");
      this.settings = settings instanceof OidcClientSettingsStore ? settings : new OidcClientSettingsStore(settings);
      this.metadataService = metadataService != null ? metadataService : new MetadataService(this.settings);
      this._claimsService = new ClaimsService(this.settings);
      this._validator = new ResponseValidator(this.settings, this.metadataService, this._claimsService);
      this._tokenClient = new TokenClient(this.settings, this.metadataService);
    }
    async createSigninRequest({
      state,
      request,
      request_uri,
      request_type,
      id_token_hint,
      login_hint,
      skipUserInfo,
      nonce,
      url_state,
      response_type = this.settings.response_type,
      scope = this.settings.scope,
      redirect_uri = this.settings.redirect_uri,
      prompt = this.settings.prompt,
      display = this.settings.display,
      max_age = this.settings.max_age,
      ui_locales = this.settings.ui_locales,
      acr_values = this.settings.acr_values,
      resource = this.settings.resource,
      response_mode = this.settings.response_mode,
      extraQueryParams = this.settings.extraQueryParams,
      extraTokenParams = this.settings.extraTokenParams
    }) {
      const logger2 = this._logger.create("createSigninRequest");
      if (response_type !== "code") {
        throw new Error("Only the Authorization Code flow (with PKCE) is supported");
      }
      const url = await this.metadataService.getAuthorizationEndpoint();
      logger2.debug("Received authorization endpoint", url);
      const signinRequest = await SigninRequest.create({
        url,
        authority: this.settings.authority,
        client_id: this.settings.client_id,
        redirect_uri,
        response_type,
        scope,
        state_data: state,
        url_state,
        prompt,
        display,
        max_age,
        ui_locales,
        id_token_hint,
        login_hint,
        acr_values,
        resource,
        request,
        request_uri,
        extraQueryParams,
        extraTokenParams,
        request_type,
        response_mode,
        client_secret: this.settings.client_secret,
        skipUserInfo,
        nonce,
        disablePKCE: this.settings.disablePKCE
      });
      await this.clearStaleState();
      const signinState = signinRequest.state;
      await this.settings.stateStore.set(signinState.id, signinState.toStorageString());
      return signinRequest;
    }
    async readSigninResponseState(url, removeState = false) {
      const logger2 = this._logger.create("readSigninResponseState");
      const response = new SigninResponse(UrlUtils.readParams(url, this.settings.response_mode));
      if (!response.state) {
        logger2.throw(new Error("No state in response"));
        throw null;
      }
      const storedStateString = await this.settings.stateStore[removeState ? "remove" : "get"](response.state);
      if (!storedStateString) {
        logger2.throw(new Error("No matching state found in storage"));
        throw null;
      }
      const state = await SigninState.fromStorageString(storedStateString);
      return { state, response };
    }
    async processSigninResponse(url) {
      const logger2 = this._logger.create("processSigninResponse");
      const { state, response } = await this.readSigninResponseState(url, true);
      logger2.debug("received state from storage; validating response");
      await this._validator.validateSigninResponse(response, state);
      return response;
    }
    async processResourceOwnerPasswordCredentials({
      username,
      password,
      skipUserInfo = false,
      extraTokenParams = {}
    }) {
      const tokenResponse = await this._tokenClient.exchangeCredentials({ username, password, ...extraTokenParams });
      const signinResponse = new SigninResponse(new URLSearchParams());
      Object.assign(signinResponse, tokenResponse);
      await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);
      return signinResponse;
    }
    async useRefreshToken({
      state,
      redirect_uri,
      resource,
      timeoutInSeconds,
      extraTokenParams
    }) {
      var _a;
      const logger2 = this._logger.create("useRefreshToken");
      let scope;
      if (this.settings.refreshTokenAllowedScope === void 0) {
        scope = state.scope;
      } else {
        const allowableScopes = this.settings.refreshTokenAllowedScope.split(" ");
        const providedScopes = ((_a = state.scope) == null ? void 0 : _a.split(" ")) || [];
        scope = providedScopes.filter((s) => allowableScopes.includes(s)).join(" ");
      }
      const result = await this._tokenClient.exchangeRefreshToken({
        refresh_token: state.refresh_token,
        // provide the (possible filtered) scope list
        scope,
        redirect_uri,
        resource,
        timeoutInSeconds,
        ...extraTokenParams
      });
      const response = new SigninResponse(new URLSearchParams());
      Object.assign(response, result);
      logger2.debug("validating response", response);
      await this._validator.validateRefreshResponse(response, {
        ...state,
        // override the scope in the state handed over to the validator
        // so it can set the granted scope to the requested scope in case none is included in the response
        scope
      });
      return response;
    }
    async createSignoutRequest({
      state,
      id_token_hint,
      client_id,
      request_type,
      post_logout_redirect_uri = this.settings.post_logout_redirect_uri,
      extraQueryParams = this.settings.extraQueryParams
    } = {}) {
      const logger2 = this._logger.create("createSignoutRequest");
      const url = await this.metadataService.getEndSessionEndpoint();
      if (!url) {
        logger2.throw(new Error("No end session endpoint"));
        throw null;
      }
      logger2.debug("Received end session endpoint", url);
      if (!client_id && post_logout_redirect_uri && !id_token_hint) {
        client_id = this.settings.client_id;
      }
      const request = new SignoutRequest({
        url,
        id_token_hint,
        client_id,
        post_logout_redirect_uri,
        state_data: state,
        extraQueryParams,
        request_type
      });
      await this.clearStaleState();
      const signoutState = request.state;
      if (signoutState) {
        logger2.debug("Signout request has state to persist");
        await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());
      }
      return request;
    }
    async readSignoutResponseState(url, removeState = false) {
      const logger2 = this._logger.create("readSignoutResponseState");
      const response = new SignoutResponse(UrlUtils.readParams(url, this.settings.response_mode));
      if (!response.state) {
        logger2.debug("No state in response");
        if (response.error) {
          logger2.warn("Response was error:", response.error);
          throw new ErrorResponse(response);
        }
        return { state: void 0, response };
      }
      const storedStateString = await this.settings.stateStore[removeState ? "remove" : "get"](response.state);
      if (!storedStateString) {
        logger2.throw(new Error("No matching state found in storage"));
        throw null;
      }
      const state = await State.fromStorageString(storedStateString);
      return { state, response };
    }
    async processSignoutResponse(url) {
      const logger2 = this._logger.create("processSignoutResponse");
      const { state, response } = await this.readSignoutResponseState(url, true);
      if (state) {
        logger2.debug("Received state from storage; validating response");
        this._validator.validateSignoutResponse(response, state);
      } else {
        logger2.debug("No state from storage; skipping response validation");
      }
      return response;
    }
    clearStaleState() {
      this._logger.create("clearStaleState");
      return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);
    }
    async revokeToken(token, type) {
      this._logger.create("revokeToken");
      return await this._tokenClient.revoke({
        token,
        token_type_hint: type
      });
    }
  };

  // src/SessionMonitor.ts
  var SessionMonitor = class {
    constructor(_userManager) {
      this._userManager = _userManager;
      this._logger = new Logger("SessionMonitor");
      this._start = async (user) => {
        const session_state = user.session_state;
        if (!session_state) {
          return;
        }
        const logger2 = this._logger.create("_start");
        if (user.profile) {
          this._sub = user.profile.sub;
          logger2.debug("session_state", session_state, ", sub", this._sub);
        } else {
          this._sub = void 0;
          logger2.debug("session_state", session_state, ", anonymous user");
        }
        if (this._checkSessionIFrame) {
          this._checkSessionIFrame.start(session_state);
          return;
        }
        try {
          const url = await this._userManager.metadataService.getCheckSessionIframe();
          if (url) {
            logger2.debug("initializing check session iframe");
            const client_id = this._userManager.settings.client_id;
            const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;
            const stopOnError = this._userManager.settings.stopCheckSessionOnError;
            const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);
            await checkSessionIFrame.load();
            this._checkSessionIFrame = checkSessionIFrame;
            checkSessionIFrame.start(session_state);
          } else {
            logger2.warn("no check session iframe found in the metadata");
          }
        } catch (err) {
          logger2.error("Error from getCheckSessionIframe:", err instanceof Error ? err.message : err);
        }
      };
      this._stop = () => {
        const logger2 = this._logger.create("_stop");
        this._sub = void 0;
        if (this._checkSessionIFrame) {
          this._checkSessionIFrame.stop();
        }
        if (this._userManager.settings.monitorAnonymousSession) {
          const timerHandle = setInterval(async () => {
            clearInterval(timerHandle);
            try {
              const session = await this._userManager.querySessionStatus();
              if (session) {
                const tmpUser = {
                  session_state: session.session_state,
                  profile: session.sub ? {
                    sub: session.sub
                  } : null
                };
                void this._start(tmpUser);
              }
            } catch (err) {
              logger2.error("error from querySessionStatus", err instanceof Error ? err.message : err);
            }
          }, 1e3);
        }
      };
      this._callback = async () => {
        const logger2 = this._logger.create("_callback");
        try {
          const session = await this._userManager.querySessionStatus();
          let raiseEvent = true;
          if (session && this._checkSessionIFrame) {
            if (session.sub === this._sub) {
              raiseEvent = false;
              this._checkSessionIFrame.start(session.session_state);
              logger2.debug("same sub still logged in at OP, session state has changed, restarting check session iframe; session_state", session.session_state);
              await this._userManager.events._raiseUserSessionChanged();
            } else {
              logger2.debug("different subject signed into OP", session.sub);
            }
          } else {
            logger2.debug("subject no longer signed into OP");
          }
          if (raiseEvent) {
            if (this._sub) {
              await this._userManager.events._raiseUserSignedOut();
            } else {
              await this._userManager.events._raiseUserSignedIn();
            }
          } else {
            logger2.debug("no change in session detected, no event to raise");
          }
        } catch (err) {
          if (this._sub) {
            logger2.debug("Error calling queryCurrentSigninSession; raising signed out event", err);
            await this._userManager.events._raiseUserSignedOut();
          }
        }
      };
      if (!_userManager) {
        this._logger.throw(new Error("No user manager passed"));
      }
      this._userManager.events.addUserLoaded(this._start);
      this._userManager.events.addUserUnloaded(this._stop);
      this._init().catch((err) => {
        this._logger.error(err);
      });
    }
    async _init() {
      this._logger.create("_init");
      const user = await this._userManager.getUser();
      if (user) {
        void this._start(user);
      } else if (this._userManager.settings.monitorAnonymousSession) {
        const session = await this._userManager.querySessionStatus();
        if (session) {
          const tmpUser = {
            session_state: session.session_state,
            profile: session.sub ? {
              sub: session.sub
            } : null
          };
          void this._start(tmpUser);
        }
      }
    }
  };

  // src/User.ts
  var User = class _User {
    constructor(args) {
      var _a;
      this.id_token = args.id_token;
      this.session_state = (_a = args.session_state) != null ? _a : null;
      this.access_token = args.access_token;
      this.refresh_token = args.refresh_token;
      this.token_type = args.token_type;
      this.scope = args.scope;
      this.profile = args.profile;
      this.expires_at = args.expires_at;
      this.state = args.userState;
      this.url_state = args.url_state;
    }
    /** Computed number of seconds the access token has remaining. */
    get expires_in() {
      if (this.expires_at === void 0) {
        return void 0;
      }
      return this.expires_at - Timer.getEpochTime();
    }
    set expires_in(value) {
      if (value !== void 0) {
        this.expires_at = Math.floor(value) + Timer.getEpochTime();
      }
    }
    /** Computed value indicating if the access token is expired. */
    get expired() {
      const expires_in = this.expires_in;
      if (expires_in === void 0) {
        return void 0;
      }
      return expires_in <= 0;
    }
    /** Array representing the parsed values from the `scope`. */
    get scopes() {
      var _a, _b;
      return (_b = (_a = this.scope) == null ? void 0 : _a.split(" ")) != null ? _b : [];
    }
    toStorageString() {
      new Logger("User").create("toStorageString");
      return JSON.stringify({
        id_token: this.id_token,
        session_state: this.session_state,
        access_token: this.access_token,
        refresh_token: this.refresh_token,
        token_type: this.token_type,
        scope: this.scope,
        profile: this.profile,
        expires_at: this.expires_at
      });
    }
    static fromStorageString(storageString) {
      Logger.createStatic("User", "fromStorageString");
      return new _User(JSON.parse(storageString));
    }
  };

  // src/navigators/AbstractChildWindow.ts
  var messageSource = "oidc-client";
  var AbstractChildWindow = class {
    constructor() {
      this._abort = new Event$1("Window navigation aborted");
      this._disposeHandlers = /* @__PURE__ */ new Set();
      this._window = null;
    }
    async navigate(params) {
      const logger2 = this._logger.create("navigate");
      if (!this._window) {
        throw new Error("Attempted to navigate on a disposed window");
      }
      logger2.debug("setting URL in window");
      this._window.location.replace(params.url);
      const { url, keepOpen } = await new Promise((resolve, reject) => {
        const listener = (e) => {
          var _a;
          const data = e.data;
          const origin = (_a = params.scriptOrigin) != null ? _a : window.location.origin;
          if (e.origin !== origin || (data == null ? void 0 : data.source) !== messageSource) {
            return;
          }
          try {
            const state = UrlUtils.readParams(data.url, params.response_mode).get("state");
            if (!state) {
              logger2.warn("no state found in response url");
            }
            if (e.source !== this._window && state !== params.state) {
              return;
            }
          } catch (err) {
            this._dispose();
            reject(new Error("Invalid response from window"));
          }
          resolve(data);
        };
        window.addEventListener("message", listener, false);
        this._disposeHandlers.add(() => window.removeEventListener("message", listener, false));
        this._disposeHandlers.add(this._abort.addHandler((reason) => {
          this._dispose();
          reject(reason);
        }));
      });
      logger2.debug("got response from window");
      this._dispose();
      if (!keepOpen) {
        this.close();
      }
      return { url };
    }
    _dispose() {
      this._logger.create("_dispose");
      for (const dispose of this._disposeHandlers) {
        dispose();
      }
      this._disposeHandlers.clear();
    }
    static _notifyParent(parent, url, keepOpen = false, targetOrigin = window.location.origin) {
      parent.postMessage({
        source: messageSource,
        url,
        keepOpen
      }, targetOrigin);
    }
  };

  // src/UserManagerSettings.ts
  var DefaultPopupWindowFeatures = {
    location: false,
    toolbar: false,
    height: 640,
    closePopupWindowAfterInSeconds: -1
  };
  var DefaultPopupTarget = "_blank";
  var DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;
  var DefaultCheckSessionIntervalInSeconds = 2;
  var DefaultSilentRequestTimeoutInSeconds = 10;
  var UserManagerSettingsStore = class extends OidcClientSettingsStore {
    constructor(args) {
      const {
        popup_redirect_uri = args.redirect_uri,
        popup_post_logout_redirect_uri = args.post_logout_redirect_uri,
        popupWindowFeatures = DefaultPopupWindowFeatures,
        popupWindowTarget = DefaultPopupTarget,
        redirectMethod = "assign",
        redirectTarget = "self",
        iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,
        iframeScriptOrigin = args.iframeScriptOrigin,
        silent_redirect_uri = args.redirect_uri,
        silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,
        automaticSilentRenew = true,
        validateSubOnSilentRenew = true,
        includeIdTokenInSilentRenew = false,
        monitorSession = false,
        monitorAnonymousSession = false,
        checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,
        query_status_response_type = "code",
        stopCheckSessionOnError = true,
        revokeTokenTypes = ["access_token", "refresh_token"],
        revokeTokensOnSignout = false,
        includeIdTokenInSilentSignout = false,
        accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,
        userStore
      } = args;
      super(args);
      this.popup_redirect_uri = popup_redirect_uri;
      this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;
      this.popupWindowFeatures = popupWindowFeatures;
      this.popupWindowTarget = popupWindowTarget;
      this.redirectMethod = redirectMethod;
      this.redirectTarget = redirectTarget;
      this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;
      this.iframeScriptOrigin = iframeScriptOrigin;
      this.silent_redirect_uri = silent_redirect_uri;
      this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds;
      this.automaticSilentRenew = automaticSilentRenew;
      this.validateSubOnSilentRenew = validateSubOnSilentRenew;
      this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;
      this.monitorSession = monitorSession;
      this.monitorAnonymousSession = monitorAnonymousSession;
      this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;
      this.stopCheckSessionOnError = stopCheckSessionOnError;
      this.query_status_response_type = query_status_response_type;
      this.revokeTokenTypes = revokeTokenTypes;
      this.revokeTokensOnSignout = revokeTokensOnSignout;
      this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;
      this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;
      if (userStore) {
        this.userStore = userStore;
      } else {
        const store = typeof window !== "undefined" ? window.sessionStorage : new InMemoryWebStorage();
        this.userStore = new WebStorageStateStore({ store });
      }
    }
  };

  // src/navigators/IFrameWindow.ts
  var IFrameWindow = class _IFrameWindow extends AbstractChildWindow {
    constructor({
      silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds
    }) {
      super();
      this._logger = new Logger("IFrameWindow");
      this._timeoutInSeconds = silentRequestTimeoutInSeconds;
      this._frame = _IFrameWindow.createHiddenIframe();
      this._window = this._frame.contentWindow;
    }
    static createHiddenIframe() {
      const iframe = window.document.createElement("iframe");
      iframe.style.visibility = "hidden";
      iframe.style.position = "fixed";
      iframe.style.left = "-1000px";
      iframe.style.top = "0";
      iframe.width = "0";
      iframe.height = "0";
      window.document.body.appendChild(iframe);
      return iframe;
    }
    async navigate(params) {
      this._logger.debug("navigate: Using timeout of:", this._timeoutInSeconds);
      const timer = setTimeout(() => void this._abort.raise(new ErrorTimeout("IFrame timed out without a response")), this._timeoutInSeconds * 1e3);
      this._disposeHandlers.add(() => clearTimeout(timer));
      return await super.navigate(params);
    }
    close() {
      var _a;
      if (this._frame) {
        if (this._frame.parentNode) {
          this._frame.addEventListener("load", (ev) => {
            var _a2;
            const frame = ev.target;
            (_a2 = frame.parentNode) == null ? void 0 : _a2.removeChild(frame);
            void this._abort.raise(new Error("IFrame removed from DOM"));
          }, true);
          (_a = this._frame.contentWindow) == null ? void 0 : _a.location.replace("about:blank");
        }
        this._frame = null;
      }
      this._window = null;
    }
    static notifyParent(url, targetOrigin) {
      return super._notifyParent(window.parent, url, false, targetOrigin);
    }
  };

  // src/navigators/IFrameNavigator.ts
  var IFrameNavigator = class {
    constructor(_settings) {
      this._settings = _settings;
      this._logger = new Logger("IFrameNavigator");
    }
    async prepare({
      silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds
    }) {
      return new IFrameWindow({ silentRequestTimeoutInSeconds });
    }
    async callback(url) {
      this._logger.create("callback");
      IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);
    }
  };

  // src/navigators/PopupWindow.ts
  var checkForPopupClosedInterval = 500;
  var second = 1e3;
  var PopupWindow = class extends AbstractChildWindow {
    constructor({
      popupWindowTarget = DefaultPopupTarget,
      popupWindowFeatures = {}
    }) {
      super();
      this._logger = new Logger("PopupWindow");
      const centeredPopup = PopupUtils.center({ ...DefaultPopupWindowFeatures, ...popupWindowFeatures });
      this._window = window.open(void 0, popupWindowTarget, PopupUtils.serialize(centeredPopup));
      if (popupWindowFeatures.closePopupWindowAfterInSeconds && popupWindowFeatures.closePopupWindowAfterInSeconds > 0) {
        setTimeout(() => {
          if (!this._window || typeof this._window.closed !== "boolean" || this._window.closed) {
            void this._abort.raise(new Error("Popup blocked by user"));
            return;
          }
          this.close();
        }, popupWindowFeatures.closePopupWindowAfterInSeconds * second);
      }
    }
    async navigate(params) {
      var _a;
      (_a = this._window) == null ? void 0 : _a.focus();
      const popupClosedInterval = setInterval(() => {
        if (!this._window || this._window.closed) {
          void this._abort.raise(new Error("Popup closed by user"));
        }
      }, checkForPopupClosedInterval);
      this._disposeHandlers.add(() => clearInterval(popupClosedInterval));
      return await super.navigate(params);
    }
    close() {
      if (this._window) {
        if (!this._window.closed) {
          this._window.close();
          void this._abort.raise(new Error("Popup closed"));
        }
      }
      this._window = null;
    }
    static notifyOpener(url, keepOpen) {
      if (!window.opener) {
        throw new Error("No window.opener. Can't complete notification.");
      }
      return super._notifyParent(window.opener, url, keepOpen);
    }
  };

  // src/navigators/PopupNavigator.ts
  var PopupNavigator = class {
    constructor(_settings) {
      this._settings = _settings;
      this._logger = new Logger("PopupNavigator");
    }
    async prepare({
      popupWindowFeatures = this._settings.popupWindowFeatures,
      popupWindowTarget = this._settings.popupWindowTarget
    }) {
      return new PopupWindow({ popupWindowFeatures, popupWindowTarget });
    }
    async callback(url, { keepOpen = false }) {
      this._logger.create("callback");
      PopupWindow.notifyOpener(url, keepOpen);
    }
  };

  // src/navigators/RedirectNavigator.ts
  var RedirectNavigator = class {
    constructor(_settings) {
      this._settings = _settings;
      this._logger = new Logger("RedirectNavigator");
    }
    async prepare({
      redirectMethod = this._settings.redirectMethod,
      redirectTarget = this._settings.redirectTarget
    }) {
      var _a;
      this._logger.create("prepare");
      let targetWindow = window.self;
      if (redirectTarget === "top") {
        targetWindow = (_a = window.top) != null ? _a : window.self;
      }
      const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location);
      let abort;
      return {
        navigate: async (params) => {
          this._logger.create("navigate");
          const promise = new Promise((resolve, reject) => {
            abort = reject;
          });
          redirect(params.url);
          return await promise;
        },
        close: () => {
          this._logger.create("close");
          abort == null ? void 0 : abort(new Error("Redirect aborted"));
          targetWindow.stop();
        }
      };
    }
    async callback() {
      return;
    }
  };

  // src/UserManagerEvents.ts
  var UserManagerEvents = class extends AccessTokenEvents {
    constructor(settings) {
      super({ expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds });
      this._logger = new Logger("UserManagerEvents");
      this._userLoaded = new Event$1("User loaded");
      this._userUnloaded = new Event$1("User unloaded");
      this._silentRenewError = new Event$1("Silent renew error");
      this._userSignedIn = new Event$1("User signed in");
      this._userSignedOut = new Event$1("User signed out");
      this._userSessionChanged = new Event$1("User session changed");
    }
    async load(user, raiseEvent = true) {
      super.load(user);
      if (raiseEvent) {
        await this._userLoaded.raise(user);
      }
    }
    async unload() {
      super.unload();
      await this._userUnloaded.raise();
    }
    /**
     * Add callback: Raised when a user session has been established (or re-established).
     */
    addUserLoaded(cb) {
      return this._userLoaded.addHandler(cb);
    }
    /**
     * Remove callback: Raised when a user session has been established (or re-established).
     */
    removeUserLoaded(cb) {
      return this._userLoaded.removeHandler(cb);
    }
    /**
     * Add callback: Raised when a user session has been terminated.
     */
    addUserUnloaded(cb) {
      return this._userUnloaded.addHandler(cb);
    }
    /**
     * Remove callback: Raised when a user session has been terminated.
     */
    removeUserUnloaded(cb) {
      return this._userUnloaded.removeHandler(cb);
    }
    /**
     * Add callback: Raised when the automatic silent renew has failed.
     */
    addSilentRenewError(cb) {
      return this._silentRenewError.addHandler(cb);
    }
    /**
     * Remove callback: Raised when the automatic silent renew has failed.
     */
    removeSilentRenewError(cb) {
      return this._silentRenewError.removeHandler(cb);
    }
    /**
     * @internal
     */
    async _raiseSilentRenewError(e) {
      await this._silentRenewError.raise(e);
    }
    /**
     * Add callback: Raised when the user is signed in (when `monitorSession` is set).
     * @see {@link UserManagerSettings.monitorSession}
     */
    addUserSignedIn(cb) {
      return this._userSignedIn.addHandler(cb);
    }
    /**
     * Remove callback: Raised when the user is signed in (when `monitorSession` is set).
     */
    removeUserSignedIn(cb) {
      this._userSignedIn.removeHandler(cb);
    }
    /**
     * @internal
     */
    async _raiseUserSignedIn() {
      await this._userSignedIn.raise();
    }
    /**
     * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).
     * @see {@link UserManagerSettings.monitorSession}
     */
    addUserSignedOut(cb) {
      return this._userSignedOut.addHandler(cb);
    }
    /**
     * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).
     */
    removeUserSignedOut(cb) {
      this._userSignedOut.removeHandler(cb);
    }
    /**
     * @internal
     */
    async _raiseUserSignedOut() {
      await this._userSignedOut.raise();
    }
    /**
     * Add callback: Raised when the user session changed (when `monitorSession` is set).
     * @see {@link UserManagerSettings.monitorSession}
     */
    addUserSessionChanged(cb) {
      return this._userSessionChanged.addHandler(cb);
    }
    /**
     * Remove callback: Raised when the user session changed (when `monitorSession` is set).
     */
    removeUserSessionChanged(cb) {
      this._userSessionChanged.removeHandler(cb);
    }
    /**
     * @internal
     */
    async _raiseUserSessionChanged() {
      await this._userSessionChanged.raise();
    }
  };

  // src/SilentRenewService.ts
  var SilentRenewService = class {
    constructor(_userManager) {
      this._userManager = _userManager;
      this._logger = new Logger("SilentRenewService");
      this._isStarted = false;
      this._retryTimer = new Timer("Retry Silent Renew");
      this._tokenExpiring = async () => {
        const logger2 = this._logger.create("_tokenExpiring");
        try {
          await this._userManager.signinSilent();
          logger2.debug("silent token renewal successful");
        } catch (err) {
          if (err instanceof ErrorTimeout) {
            logger2.warn("ErrorTimeout from signinSilent:", err, "retry in 5s");
            this._retryTimer.init(5);
            return;
          }
          logger2.error("Error from signinSilent:", err);
          await this._userManager.events._raiseSilentRenewError(err);
        }
      };
    }
    async start() {
      const logger2 = this._logger.create("start");
      if (!this._isStarted) {
        this._isStarted = true;
        this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);
        this._retryTimer.addHandler(this._tokenExpiring);
        try {
          await this._userManager.getUser();
        } catch (err) {
          logger2.error("getUser error", err);
        }
      }
    }
    stop() {
      if (this._isStarted) {
        this._retryTimer.cancel();
        this._retryTimer.removeHandler(this._tokenExpiring);
        this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);
        this._isStarted = false;
      }
    }
  };

  // src/RefreshState.ts
  var RefreshState = class {
    constructor(args) {
      this.refresh_token = args.refresh_token;
      this.id_token = args.id_token;
      this.session_state = args.session_state;
      this.scope = args.scope;
      this.profile = args.profile;
      this.data = args.state;
    }
  };

  // src/UserManager.ts
  var UserManager = class {
    constructor(settings, redirectNavigator, popupNavigator, iframeNavigator) {
      this._logger = new Logger("UserManager");
      this.settings = new UserManagerSettingsStore(settings);
      this._client = new OidcClient(settings);
      this._redirectNavigator = redirectNavigator != null ? redirectNavigator : new RedirectNavigator(this.settings);
      this._popupNavigator = popupNavigator != null ? popupNavigator : new PopupNavigator(this.settings);
      this._iframeNavigator = iframeNavigator != null ? iframeNavigator : new IFrameNavigator(this.settings);
      this._events = new UserManagerEvents(this.settings);
      this._silentRenewService = new SilentRenewService(this);
      if (this.settings.automaticSilentRenew) {
        this.startSilentRenew();
      }
      this._sessionMonitor = null;
      if (this.settings.monitorSession) {
        this._sessionMonitor = new SessionMonitor(this);
      }
    }
    /**
     * Get object used to register for events raised by the `UserManager`.
     */
    get events() {
      return this._events;
    }
    /**
     * Get object used to access the metadata configuration of the identity provider.
     */
    get metadataService() {
      return this._client.metadataService;
    }
    /**
     * Load the `User` object for the currently authenticated user.
     *
     * @returns A promise
     */
    async getUser() {
      const logger2 = this._logger.create("getUser");
      const user = await this._loadUser();
      if (user) {
        logger2.info("user loaded");
        await this._events.load(user, false);
        return user;
      }
      logger2.info("user not found in storage");
      return null;
    }
    /**
     * Remove from any storage the currently authenticated user.
     *
     * @returns A promise
     */
    async removeUser() {
      const logger2 = this._logger.create("removeUser");
      await this.storeUser(null);
      logger2.info("user removed from storage");
      await this._events.unload();
    }
    /**
     * Trigger a redirect of the current window to the authorization endpoint.
     *
     * @returns A promise
     *
     * @throws `Error` In cases of wrong authentication.
     */
    async signinRedirect(args = {}) {
      this._logger.create("signinRedirect");
      const {
        redirectMethod,
        ...requestArgs
      } = args;
      const handle = await this._redirectNavigator.prepare({ redirectMethod });
      await this._signinStart({
        request_type: "si:r",
        ...requestArgs
      }, handle);
    }
    /**
     * Process the response (callback) from the authorization endpoint.
     * It is recommend to use {@link UserManager.signinCallback} instead.
     *
     * @returns A promise containing the authenticated `User`.
     *
     * @see {@link UserManager.signinCallback}
     */
    async signinRedirectCallback(url = window.location.href) {
      const logger2 = this._logger.create("signinRedirectCallback");
      const user = await this._signinEnd(url);
      if (user.profile && user.profile.sub) {
        logger2.info("success, signed in subject", user.profile.sub);
      } else {
        logger2.info("no subject");
      }
      return user;
    }
    /**
     * Trigger the signin with user/password.
     *
     * @returns A promise containing the authenticated `User`.
     * @throws {@link ErrorResponse} In cases of wrong authentication.
     */
    async signinResourceOwnerCredentials({
      username,
      password,
      skipUserInfo = false
    }) {
      const logger2 = this._logger.create("signinResourceOwnerCredential");
      const signinResponse = await this._client.processResourceOwnerPasswordCredentials({ username, password, skipUserInfo, extraTokenParams: this.settings.extraTokenParams });
      logger2.debug("got signin response");
      const user = await this._buildUser(signinResponse);
      if (user.profile && user.profile.sub) {
        logger2.info("success, signed in subject", user.profile.sub);
      } else {
        logger2.info("no subject");
      }
      return user;
    }
    /**
     * Trigger a request (via a popup window) to the authorization endpoint.
     *
     * @returns A promise containing the authenticated `User`.
     * @throws `Error` In cases of wrong authentication.
     */
    async signinPopup(args = {}) {
      const logger2 = this._logger.create("signinPopup");
      const {
        popupWindowFeatures,
        popupWindowTarget,
        ...requestArgs
      } = args;
      const url = this.settings.popup_redirect_uri;
      if (!url) {
        logger2.throw(new Error("No popup_redirect_uri configured"));
      }
      const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });
      const user = await this._signin({
        request_type: "si:p",
        redirect_uri: url,
        display: "popup",
        ...requestArgs
      }, handle);
      if (user) {
        if (user.profile && user.profile.sub) {
          logger2.info("success, signed in subject", user.profile.sub);
        } else {
          logger2.info("no subject");
        }
      }
      return user;
    }
    /**
     * Notify the opening window of response (callback) from the authorization endpoint.
     * It is recommend to use {@link UserManager.signinCallback} instead.
     *
     * @returns A promise
     *
     * @see {@link UserManager.signinCallback}
     */
    async signinPopupCallback(url = window.location.href, keepOpen = false) {
      const logger2 = this._logger.create("signinPopupCallback");
      await this._popupNavigator.callback(url, { keepOpen });
      logger2.info("success");
    }
    /**
     * Trigger a silent request (via refresh token or an iframe) to the authorization endpoint.
     *
     * @returns A promise that contains the authenticated `User`.
     */
    async signinSilent(args = {}) {
      var _a;
      const logger2 = this._logger.create("signinSilent");
      const {
        silentRequestTimeoutInSeconds,
        ...requestArgs
      } = args;
      let user = await this._loadUser();
      if (user == null ? void 0 : user.refresh_token) {
        logger2.debug("using refresh token");
        const state = new RefreshState(user);
        return await this._useRefreshToken({
          state,
          redirect_uri: requestArgs.redirect_uri,
          resource: requestArgs.resource,
          extraTokenParams: requestArgs.extraTokenParams,
          timeoutInSeconds: silentRequestTimeoutInSeconds
        });
      }
      const url = this.settings.silent_redirect_uri;
      if (!url) {
        logger2.throw(new Error("No silent_redirect_uri configured"));
      }
      let verifySub;
      if (user && this.settings.validateSubOnSilentRenew) {
        logger2.debug("subject prior to silent renew:", user.profile.sub);
        verifySub = user.profile.sub;
      }
      const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });
      user = await this._signin({
        request_type: "si:s",
        redirect_uri: url,
        prompt: "none",
        id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,
        ...requestArgs
      }, handle, verifySub);
      if (user) {
        if ((_a = user.profile) == null ? void 0 : _a.sub) {
          logger2.info("success, signed in subject", user.profile.sub);
        } else {
          logger2.info("no subject");
        }
      }
      return user;
    }
    async _useRefreshToken(args) {
      const response = await this._client.useRefreshToken({
        ...args,
        timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds
      });
      const user = new User({ ...args.state, ...response });
      await this.storeUser(user);
      await this._events.load(user);
      return user;
    }
    /**
     *
     * Notify the parent window of response (callback) from the authorization endpoint.
     * It is recommend to use {@link UserManager.signinCallback} instead.
     *
     * @returns A promise
     *
     * @see {@link UserManager.signinCallback}
     */
    async signinSilentCallback(url = window.location.href) {
      const logger2 = this._logger.create("signinSilentCallback");
      await this._iframeNavigator.callback(url);
      logger2.info("success");
    }
    /**
     * Process any response (callback) from the authorization endpoint, by dispatching the request_type
     * and executing one of the following functions:
     * - {@link UserManager.signinRedirectCallback}
     * - {@link UserManager.signinPopupCallback}
     * - {@link UserManager.signinSilentCallback}
     *
     * @throws `Error` If request_type is unknown or signout can not processed.
     */
    async signinCallback(url = window.location.href) {
      const { state } = await this._client.readSigninResponseState(url);
      switch (state.request_type) {
        case "si:r":
          return await this.signinRedirectCallback(url);
        case "si:p":
          return await this.signinPopupCallback(url);
        case "si:s":
          return await this.signinSilentCallback(url);
        default:
          throw new Error("invalid response_type in state");
      }
    }
    /**
     * Process any response (callback) from the end session endpoint, by dispatching the request_type
     * and executing one of the following functions:
     * - {@link UserManager.signoutRedirectCallback}
     * - {@link UserManager.signoutPopupCallback}
     * - {@link UserManager.signoutSilentCallback}
     *
     * @throws `Error` If request_type is unknown or signout can not processed.
     */
    async signoutCallback(url = window.location.href, keepOpen = false) {
      const { state } = await this._client.readSignoutResponseState(url);
      if (!state) {
        return;
      }
      switch (state.request_type) {
        case "so:r":
          await this.signoutRedirectCallback(url);
          break;
        case "so:p":
          await this.signoutPopupCallback(url, keepOpen);
          break;
        case "so:s":
          await this.signoutSilentCallback(url);
          break;
        default:
          throw new Error("invalid response_type in state");
      }
    }
    /**
     * Query OP for user's current signin status.
     *
     * @returns A promise object with session_state and subject identifier.
     */
    async querySessionStatus(args = {}) {
      const logger2 = this._logger.create("querySessionStatus");
      const {
        silentRequestTimeoutInSeconds,
        ...requestArgs
      } = args;
      const url = this.settings.silent_redirect_uri;
      if (!url) {
        logger2.throw(new Error("No silent_redirect_uri configured"));
      }
      const user = await this._loadUser();
      const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });
      const navResponse = await this._signinStart({
        request_type: "si:s",
        // this acts like a signin silent
        redirect_uri: url,
        prompt: "none",
        id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,
        response_type: this.settings.query_status_response_type,
        scope: "openid",
        skipUserInfo: true,
        ...requestArgs
      }, handle);
      try {
        const signinResponse = await this._client.processSigninResponse(navResponse.url);
        logger2.debug("got signin response");
        if (signinResponse.session_state && signinResponse.profile.sub) {
          logger2.info("success for subject", signinResponse.profile.sub);
          return {
            session_state: signinResponse.session_state,
            sub: signinResponse.profile.sub
          };
        }
        logger2.info("success, user not authenticated");
        return null;
      } catch (err) {
        if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {
          switch (err.error) {
            case "login_required":
            case "consent_required":
            case "interaction_required":
            case "account_selection_required":
              logger2.info("success for anonymous user");
              return {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                session_state: err.session_state
              };
          }
        }
        throw err;
      }
    }
    async _signin(args, handle, verifySub) {
      const navResponse = await this._signinStart(args, handle);
      return await this._signinEnd(navResponse.url, verifySub);
    }
    async _signinStart(args, handle) {
      const logger2 = this._logger.create("_signinStart");
      try {
        const signinRequest = await this._client.createSigninRequest(args);
        logger2.debug("got signin request");
        return await handle.navigate({
          url: signinRequest.url,
          state: signinRequest.state.id,
          response_mode: signinRequest.state.response_mode,
          scriptOrigin: this.settings.iframeScriptOrigin
        });
      } catch (err) {
        logger2.debug("error after preparing navigator, closing navigator window");
        handle.close();
        throw err;
      }
    }
    async _signinEnd(url, verifySub) {
      const logger2 = this._logger.create("_signinEnd");
      const signinResponse = await this._client.processSigninResponse(url);
      logger2.debug("got signin response");
      const user = await this._buildUser(signinResponse, verifySub);
      return user;
    }
    async _buildUser(signinResponse, verifySub) {
      const logger2 = this._logger.create("_buildUser");
      const user = new User(signinResponse);
      if (verifySub) {
        if (verifySub !== user.profile.sub) {
          logger2.debug("current user does not match user returned from signin. sub from signin:", user.profile.sub);
          throw new ErrorResponse({ ...signinResponse, error: "login_required" });
        }
        logger2.debug("current user matches user returned from signin");
      }
      await this.storeUser(user);
      logger2.debug("user stored");
      await this._events.load(user);
      return user;
    }
    /**
     * Trigger a redirect of the current window to the end session endpoint.
     *
     * @returns A promise
     */
    async signoutRedirect(args = {}) {
      const logger2 = this._logger.create("signoutRedirect");
      const {
        redirectMethod,
        ...requestArgs
      } = args;
      const handle = await this._redirectNavigator.prepare({ redirectMethod });
      await this._signoutStart({
        request_type: "so:r",
        post_logout_redirect_uri: this.settings.post_logout_redirect_uri,
        ...requestArgs
      }, handle);
      logger2.info("success");
    }
    /**
     * Process response (callback) from the end session endpoint.
     * It is recommend to use {@link UserManager.signoutCallback} instead.
     *
     * @returns A promise containing signout response
     *
     * @see {@link UserManager.signoutCallback}
     */
    async signoutRedirectCallback(url = window.location.href) {
      const logger2 = this._logger.create("signoutRedirectCallback");
      const response = await this._signoutEnd(url);
      logger2.info("success");
      return response;
    }
    /**
     * Trigger a redirect of a popup window window to the end session endpoint.
     *
     * @returns A promise
     */
    async signoutPopup(args = {}) {
      const logger2 = this._logger.create("signoutPopup");
      const {
        popupWindowFeatures,
        popupWindowTarget,
        ...requestArgs
      } = args;
      const url = this.settings.popup_post_logout_redirect_uri;
      const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });
      await this._signout({
        request_type: "so:p",
        post_logout_redirect_uri: url,
        // we're putting a dummy entry in here because we
        // need a unique id from the state for notification
        // to the parent window, which is necessary if we
        // plan to return back to the client after signout
        // and so we can close the popup after signout
        state: url == null ? void 0 : {},
        ...requestArgs
      }, handle);
      logger2.info("success");
    }
    /**
     * Process response (callback) from the end session endpoint from a popup window.
     * It is recommend to use {@link UserManager.signoutCallback} instead.
     *
     * @returns A promise
     *
     * @see {@link UserManager.signoutCallback}
     */
    async signoutPopupCallback(url = window.location.href, keepOpen = false) {
      const logger2 = this._logger.create("signoutPopupCallback");
      await this._popupNavigator.callback(url, { keepOpen });
      logger2.info("success");
    }
    async _signout(args, handle) {
      const navResponse = await this._signoutStart(args, handle);
      return await this._signoutEnd(navResponse.url);
    }
    async _signoutStart(args = {}, handle) {
      var _a;
      const logger2 = this._logger.create("_signoutStart");
      try {
        const user = await this._loadUser();
        logger2.debug("loaded current user from storage");
        if (this.settings.revokeTokensOnSignout) {
          await this._revokeInternal(user);
        }
        const id_token = args.id_token_hint || user && user.id_token;
        if (id_token) {
          logger2.debug("setting id_token_hint in signout request");
          args.id_token_hint = id_token;
        }
        await this.removeUser();
        logger2.debug("user removed, creating signout request");
        const signoutRequest = await this._client.createSignoutRequest(args);
        logger2.debug("got signout request");
        return await handle.navigate({
          url: signoutRequest.url,
          state: (_a = signoutRequest.state) == null ? void 0 : _a.id,
          scriptOrigin: this.settings.iframeScriptOrigin
        });
      } catch (err) {
        logger2.debug("error after preparing navigator, closing navigator window");
        handle.close();
        throw err;
      }
    }
    async _signoutEnd(url) {
      const logger2 = this._logger.create("_signoutEnd");
      const signoutResponse = await this._client.processSignoutResponse(url);
      logger2.debug("got signout response");
      return signoutResponse;
    }
    /**
     * Trigger a silent request (via an iframe) to the end session endpoint.
     *
     * @returns A promise
     */
    async signoutSilent(args = {}) {
      var _a;
      const logger2 = this._logger.create("signoutSilent");
      const {
        silentRequestTimeoutInSeconds,
        ...requestArgs
      } = args;
      const id_token_hint = this.settings.includeIdTokenInSilentSignout ? (_a = await this._loadUser()) == null ? void 0 : _a.id_token : void 0;
      const url = this.settings.popup_post_logout_redirect_uri;
      const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });
      await this._signout({
        request_type: "so:s",
        post_logout_redirect_uri: url,
        id_token_hint,
        ...requestArgs
      }, handle);
      logger2.info("success");
    }
    /**
     * Notify the parent window of response (callback) from the end session endpoint.
     * It is recommend to use {@link UserManager.signoutCallback} instead.
     *
     * @returns A promise
     *
     * @see {@link UserManager.signoutCallback}
     */
    async signoutSilentCallback(url = window.location.href) {
      const logger2 = this._logger.create("signoutSilentCallback");
      await this._iframeNavigator.callback(url);
      logger2.info("success");
    }
    async revokeTokens(types) {
      const user = await this._loadUser();
      await this._revokeInternal(user, types);
    }
    async _revokeInternal(user, types = this.settings.revokeTokenTypes) {
      const logger2 = this._logger.create("_revokeInternal");
      if (!user)
        return;
      const typesPresent = types.filter((type) => typeof user[type] === "string");
      if (!typesPresent.length) {
        logger2.debug("no need to revoke due to no token(s)");
        return;
      }
      for (const type of typesPresent) {
        await this._client.revokeToken(
          user[type],
          // eslint-disable-line @typescript-eslint/no-non-null-assertion
          type
        );
        logger2.info(`${type} revoked successfully`);
        if (type !== "access_token") {
          user[type] = null;
        }
      }
      await this.storeUser(user);
      logger2.debug("user stored");
      await this._events.load(user);
    }
    /**
     * Enables silent renew for the `UserManager`.
     */
    startSilentRenew() {
      this._logger.create("startSilentRenew");
      void this._silentRenewService.start();
    }
    /**
     * Disables silent renew for the `UserManager`.
     */
    stopSilentRenew() {
      this._silentRenewService.stop();
    }
    get _userStoreKey() {
      return `user:${this.settings.authority}:${this.settings.client_id}`;
    }
    async _loadUser() {
      const logger2 = this._logger.create("_loadUser");
      const storageString = await this.settings.userStore.get(this._userStoreKey);
      if (storageString) {
        logger2.debug("user storageString loaded");
        return User.fromStorageString(storageString);
      }
      logger2.debug("no user storageString");
      return null;
    }
    async storeUser(user) {
      const logger2 = this._logger.create("storeUser");
      if (user) {
        logger2.debug("storing user");
        const storageString = user.toStorageString();
        await this.settings.userStore.set(this._userStoreKey, storageString);
      } else {
        this._logger.debug("removing user");
        await this.settings.userStore.remove(this._userStoreKey);
      }
    }
    /**
     * Removes stale state entries in storage for incomplete authorize requests.
     */
    async clearStaleState() {
      await this._client.clearStaleState();
    }
  };

  var _a;
  var globalUpvSignalingBackendUrl = window.upvSignalingBackendUrl;
  var globalUpvBaseUrl = extractBaseUrl(globalUpvSignalingBackendUrl);
  var globalUpvApplicationsFolder = (_a = window.upvApplicationsFolder) !== null && _a !== void 0 ? _a : 'applications';
  /**
   * Retrieves the top path of all WebUPV end points, currently this has to be signaling.
   * @return 'signaling', will be configurable in the future.
   */
  function signalingBasePath() {
      return 'signaling';
  }
  /**
   * Configure the URL where WebUPV is running. This is usually called form UpvWebInterface contructor with the URL provided
   * as parameter.
   * @param signalingUrlString e.g. https://mywebupv.com/instance1/signaling or null ( current host will be taken).
   */
  function setUpvSignalingBackendUrl(signalingUrlString) {
      globalUpvSignalingBackendUrl = signalingUrlString;
      globalUpvBaseUrl = extractBaseUrl(globalUpvSignalingBackendUrl);
  }
  /**
   * Used to handle code located in folder /applications outside of /signaling. Checks if href has no signalingBasePath()
   * as parent and if so sets upvSignalingBackendUrl.
   * @param href optional URL, current location if null.
   * @return true if callled from /applications and upvSignalingBackendUrl was set.
   */
  function checkForApplicationsFolder(href) {
      if (!href) {
          href = window.location.href;
      }
      // suppress check if upvSignalingBackendUrl was set by user code.
      if (!globalUpvSignalingBackendUrl) {
          var loc = new URL(href);
          var pathname = loc.pathname;
          var signalingIndex = pathname.lastIndexOf("/".concat(signalingBasePath()));
          var applicationsIndex = pathname.lastIndexOf("/".concat(globalUpvApplicationsFolder));
          if (signalingIndex === -1 && applicationsIndex > 0) {
              globalUpvBaseUrl = extractBaseUrl(href, globalUpvApplicationsFolder);
              globalUpvSignalingBackendUrl = addUrlPath(globalUpvBaseUrl, signalingBasePath());
              window.upvSignalingBackendUrl = globalUpvSignalingBackendUrl;
              return true;
          }
      }
      return false;
  }
  /**
   * Retrieves the parent directory of WebUPV'S entry point e.g. https://myhost.com/somePath for
   * https://myhost.com/somePath/signaling/someMethod?param1=A
   * @param href URL to scan, the last occurence of 'signaling' is used to detect the parent.
   * @param baseFolderName optional string to use for determining end of base path, signalingBasePath() is used as fallback.
   * @return path cut before last '/signaling' or null if href is empty.
   */
  function extractBaseUrl(href, baseFolderName) {
      if (!href || href.length === 0) {
          return null;
      }
      try {
          var loc = new URL(href);
          // trim trailing /
          var pathname = loc.pathname.replace(/\/$/, '');
          if (!baseFolderName) {
              baseFolderName = signalingBasePath();
          }
          var path = pathname.substring(0, pathname.lastIndexOf("/".concat(baseFolderName)));
          return loc.protocol + '//' + loc.host + path.replace(/\/$/, '');
      }
      catch (e) {
          console.error("Error parsing URL ".concat(href), e);
          throw e;
      }
  }
  /**
   * Build signaling URL with method e.g. https://myhost.com/webupv/signaling/mymethodPath. The content of the signaling
   * URL depends on the run mdoe. Either a global URL was set by calling setUpvSignalingBackendUrl() at start (running
   * web part on a separate web server) or the current host is used.
   * @param methodPath to append.
   */
  function url(methodPath) {
      var resultUrl = !globalUpvSignalingBackendUrl ? "".concat(extractBaseUrl(location.href), "/").concat(signalingBasePath()) : globalUpvSignalingBackendUrl;
      resultUrl = addUrlPath(resultUrl, methodPath);
      return resultUrl;
  }
  /**
   * Like url() but with its parent directory as base.
   * @see url
   * @param methodPath to append.
   */
  function baseUrl(methodPath) {
      var resultUrl = !globalUpvBaseUrl ? extractBaseUrl(location.href) : globalUpvBaseUrl;
      return addUrlPath(resultUrl, methodPath);
  }
  function addUrlPath(hostUrl, methodPath) {
      var trimmedPath = methodPath === null || methodPath === void 0 ? void 0 : methodPath.replace(/^\/|\/$/g, '');
      if (trimmedPath && trimmedPath.length > 0) {
          var trimmedHostUrl = hostUrl.replace(/\/$/, '');
          return trimmedHostUrl + '/' + trimmedPath;
      }
      return hostUrl;
  }
  function hashCode(str) {
      return str.split('').reduce(function (prevHash, currVal) {
          // tslint:disable-next-line:no-bitwise
          return (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0;
      }, 0);
  }
  function uuidv4() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
          // tslint:disable-next-line:no-bitwise
          var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
      });
  }
  function createRandomInt32() {
      return Math.floor(Math.random() * 2147483647);
  }
  function clamp(num, min, max) {
      return num <= min ? min : num >= max ? max : num;
  }
  /**
   * Recursively traverses all properties and ensures that their keys comply with C# notation i.e. CamelCase with
   * first letter as upper case. Inspired by https://stackoverflow.com/a/36281036/437283.
   * @param obj to convert.
   * @return new object.
   */
  function convertKeysToCSharpStyle(obj) {
      if (!obj) {
          return undefined;
      }
      var output = {};
      for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
          var key = _a[_i];
          var current = obj[key];
          var newKey = key.charAt(0).toUpperCase();
          if (key.length > 1) {
              newKey += key.slice(1);
          }
          if (typeof current === 'object' || Array.isArray(current)) {
              output[newKey] = convertKeysToCSharpStyle(current);
          }
          else {
              output[newKey] = current;
          }
      }
      return output;
  }
  function getRequestParam(name, fallbackValue) {
      var reg = (new RegExp('[?&]' + encodeURIComponent(name) + '=([^&]*)')).exec(location.search);
      var s;
      if (reg) {
          s = decodeURIComponent(reg[1]);
      }
      if (s) {
          return s;
      }
      return fallbackValue;
  }
  /**
   * Converts a byte array of Base64 encoded characters into a blob.
   * @param base64Data as read by JSON.parse().
   * @param contentType MIME type.
   * @returns {Blob} of contentType.
   */
  function base64toBlob(base64Data, contentType) {
      contentType = contentType || '';
      var sliceSize = 1024;
      var byteCharacters = atob(base64Data);
      var bytesLength = byteCharacters.length;
      var slicesCount = Math.ceil(bytesLength / sliceSize);
      var byteArrays = new Array(slicesCount);
      for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
          var begin = sliceIndex * sliceSize;
          var end = Math.min(begin + sliceSize, bytesLength);
          var bytes = new Array(end - begin);
          for (var offset = begin, i = 0; offset < end; ++i, ++offset) {
              bytes[i] = byteCharacters[offset].charCodeAt(0);
          }
          byteArrays[sliceIndex] = new Uint8Array(bytes);
      }
      return new Blob(byteArrays, { type: contentType });
  }
  /**
   * Converts a blob to base64 encoded string.
   * Source https://stackoverflow.com/a/9458996/437283
   * @param blob to convert
   * @returns {string} as promise.
   */
  function blobToBase64(blob) {
      return __awaiter(this, void 0, void 0, function () {
          var reader;
          return __generator(this, function (_a) {
              reader = new FileReader();
              reader.readAsDataURL(blob);
              return [2 /*return*/, new Promise(function (resolve) {
                      reader.onloadend = function () {
                          var result = reader.result;
                          var base64result = result.substr(result.indexOf(',') + 1);
                          resolve(base64result);
                      };
                  })];
          });
      });
  }
  /**
   * Split a string into chunks of fix size.
   * Modified version of from https://stackoverflow.com/a/14349616/437283
   * @param str to split.
   * @param len of chunks.
   * @returns {any[]} maybe empty, never null
   */
  function chunkString(str, len) {
      var size = Math.ceil(str.length / len);
      var r = Array(size);
      var offset = 0;
      if (size === 1) {
          r[0] = str;
          return r;
      }
      for (var i = 0; i < size; i++) {
          r[i] = str.substr(offset, len);
          offset += len;
      }
      return r;
  }
  function clearChildren(element, elementToKeep) {
      var childArray = Array.from(element.children);
      childArray.forEach(function (value) {
          if (value.id !== elementToKeep) {
              element.removeChild(value);
          }
      });
  }
  function getWindowWidth() {
      return window.innerWidth || document.body.clientWidth;
  }
  function getWindowHeight() {
      return window.innerHeight || document.body.clientHeight;
  }
  function isUserAgentSafari() {
      var _a, _b, _c;
      return ((_a = navigator.userAgent.match(/iPad/i)) === null || _a === void 0 ? void 0 : _a.length) > 0 || ((_b = navigator.userAgent.match(/iPhone/i)) === null || _b === void 0 ? void 0 : _b.length) > 0
          || ((_c = navigator.userAgent.match(/Safari/i)) === null || _c === void 0 ? void 0 : _c.length) > 0 && !navigator.userAgent.match(/Chrome/i);
  }
  function isUserAgentAndroid() {
      return navigator.userAgent.toLowerCase().indexOf('android') > -1;
  }
  // Taken from https://stackoverflow.com/questions/9038625/detect-if-device-is-ios#9039885
  function isUserAgentIos() {
      return [
          'iPad Simulator',
          'iPhone Simulator',
          'iPod Simulator',
          'iPad',
          'iPhone',
          'iPod'
      ].includes(navigator.platform)
          // iPad on iOS 13 detection
          ||
              (navigator.userAgent.includes('Mac') && 'ontouchend' in document);
  }
  function isUserAgentChrome() {
      if (isUserAgentAndroid()) {
          return !!window.chrome;
      }
      return !!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime);
  }
  /**
   * true if the device supports touch input.
   * Based on https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
   */
  function hasTouchScreen() {
      var b = false;
      if ('maxTouchPoints' in navigator) {
          b = navigator.maxTouchPoints > 0;
      }
      else if ('msMaxTouchPoints' in navigator) {
          var msNav = navigator;
          b = msNav.msMaxTouchPoints > 0;
      }
      else {
          var mQ = matchMedia === null || matchMedia === void 0 ? void 0 : matchMedia('(pointer:coarse)');
          if ((mQ === null || mQ === void 0 ? void 0 : mQ.media) === '(pointer:coarse)') {
              b = !!mQ.matches;
          }
          else {
              if ('orientation' in window) {
                  b = true; // deprecated, but good fallback
              }
              else {
                  // Only as a last resort, fall back to user agent sniffing
                  var agent = window.navigator.userAgent;
                  b = /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(agent) ||
                      /\b(Android|Windows Phone|iPad|iPod)\b/i.test(agent);
              }
          }
      }
      return b;
  }
  /**
   * Prepares the specified blob to be downloaded for saving locally (or do the browser specific dfault action e.g. open, preview)
   * @param blob of type Blob to be downloaded.
   * @param filename taken for saving or as suggested file name in save as dialog.
   */
  function saveToDownload(blob, filename) {
      if ('msSaveOrOpenBlob' in window.navigator) /* IE10+*/ {
          window.navigator.msSaveOrOpenBlob(blob, filename);
      }
      else { // Others
          var a_1 = document.createElement('a');
          var objectURL_1 = URL.createObjectURL(blob);
          a_1.href = objectURL_1;
          a_1.download = filename;
          document.body.appendChild(a_1);
          a_1.click();
          setTimeout(function () {
              document.body.removeChild(a_1);
              window.URL.revokeObjectURL(objectURL_1);
          }, 0);
      }
  }
  // s. Stack Overflow https://stackoverflow.com/a/50782106/437283
  function clickElem(elem) {
      var eventMouse = document.createEvent('MouseEvents');
      eventMouse.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
      elem.dispatchEvent(eventMouse);
  }
  function openFile(extensions, callback) {
      var fileInput = document.getElementById('TempInput');
      var readFile = function (e) {
          var file = e.target.files[0];
          if (!file) {
              return;
          }
          var reader = new FileReader();
          reader.onload = function (progressEvent) {
              var contents = progressEvent.target.result;
              fileInput.func(file.name, file.size, contents);
              document.body.onclick = null;
              fileInput.parentNode.removeChild(fileInput);
          };
          reader.onerror = function (progressEvent) {
              alert("Failed to read file ".concat(file, ": ").concat(reader.error));
          };
          reader.onabort = function (progressEvent) {
              alert("Reading file aborted");
          };
          reader.readAsDataURL(file);
      };
      if (!fileInput) {
          fileInput = document.createElement('input');
          fileInput.id = 'TempInput';
          fileInput.type = 'file';
          fileInput.style.display = 'none';
          fileInput.onchange = readFile;
          // custom callback function
          fileInput.func = callback;
          document.body.appendChild(fileInput);
      }
      if (extensions) {
          fileInput.accept = extensions.join();
      }
      clickElem(fileInput);
      setTimeout(function () {
          document.body.onclick = function (ev) {
              document.body.onclick = null;
          };
      }, 1000);
  }

  var AuthenticationUtils = /** @class */ (function () {
      function AuthenticationUtils() {
      }
      //taken from legacy oidc-client codebase
      AuthenticationUtils.parseUrlFragment = function (value, delimiter) {
          if (delimiter === void 0) { delimiter = "#"; }
          if (typeof value !== 'string') {
              value = global.location.href;
          }
          var idx = value.lastIndexOf(delimiter);
          if (idx >= 0) {
              value = value.substr(idx + 1);
          }
          if (delimiter === "?") {
              // if we're doing query, then strip off hash fragment before we parse
              idx = value.indexOf('#');
              if (idx >= 0) {
                  value = value.substr(0, idx);
              }
          }
          var params = {}, regex = /([^&=]+)=([^&]*)/g, m;
          var counter = 0;
          while (m = regex.exec(value)) {
              params[decodeURIComponent(m[1])] = decodeURIComponent(m[2].replace(/\+/g, ' '));
              if (counter++ > 50) {
                  console.error("UrlUtility.parseUrlFragment: response exceeded expected number of parameters", value);
                  return {
                      error: "Response exceeded expected number of parameters"
                  };
              }
          }
          for (var prop in params) {
              return params;
          }
          return {};
      };
      return AuthenticationUtils;
  }());

  var AuthenticationService = /** @class */ (function () {
      function AuthenticationService() {
      }
      // needs to be called after IdentityProvider redirects user back to settings.redirectUri.
      AuthenticationService.handleSignInRedirect = function (url) {
          return __awaiter(this, void 0, void 0, function () {
              var state, stateKey, store, signinStateString, signinState, settings;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (!url) {
                              url = document.location.href;
                          }
                          stateKey = AuthenticationUtils.parseUrlFragment(url, '?').state;
                          if (!stateKey) return [3 /*break*/, 2];
                          store = new WebStorageStateStore({});
                          return [4 /*yield*/, store.get(stateKey)];
                      case 1:
                          signinStateString = _a.sent();
                          if (signinStateString) {
                              signinState = JSON.parse(signinStateString);
                              if (signinState.data) {
                                  state = signinState.data;
                              }
                          }
                          _a.label = 2;
                      case 2: return [4 /*yield*/, this.fetchConfig()];
                      case 3:
                          settings = _a.sent();
                          settings.response_mode = 'query';
                          return [2 /*return*/, new UserManager(settings).signinRedirectCallback(url)
                                  .then(function () {
                                  var storage = new RedirectStorage();
                                  // return original url from where the authentication was initiated -> consuming client should redirect to that location
                                  return storage.pop(state);
                              })];
                  }
              });
          });
      };
      AuthenticationService.fetchConfig = function () {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  return [2 /*return*/, new Promise(function (resolve) {
                          var storage = new RedirectStorage();
                          var settingsJson = storage.get('CAXperts.AuthSettings');
                          if (settingsJson) {
                              var settings = JSON.parse(settingsJson);
                              resolve(settings);
                          }
                          else {
                              console.error('settings missing');
                              //todo
                          }
                      })];
              });
          });
      };
      // trigger automatic token refresh
      AuthenticationService.handleAutomaticSilentRenew = function (url) {
          return __awaiter(this, void 0, void 0, function () {
              var userManager;
              return __generator(this, function (_a) {
                  userManager = new UserManager({});
                  userManager.signinSilentCallback(url).catch(function (err) {
                      console.error(err);
                  });
                  return [2 /*return*/];
              });
          });
      };
      AuthenticationService.handleSignInPopup = function () {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  return [2 /*return*/, new UserManager({ response_mode: 'query' }).signinPopupCallback()];
              });
          });
      };
      AuthenticationService.handleSignOutPopup = function () {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  return [2 /*return*/, new UserManager({ response_mode: 'query' }).signoutCallback()];
              });
          });
      };
      return AuthenticationService;
  }());
  var RedirectStorage = /** @class */ (function () {
      function RedirectStorage() {
      }
      RedirectStorage.prototype.push = function (key, value, secondsToExpiry) {
          window.sessionStorage.setItem(key, value);
      };
      RedirectStorage.prototype.pop = function (key) {
          var value = window.sessionStorage.getItem(key);
          window.sessionStorage.removeItem(key);
          return value;
      };
      RedirectStorage.prototype.get = function (key) {
          return window.sessionStorage.getItem(key);
      };
      return RedirectStorage;
  }());
  function signOutPopup(oidcConfig) {
      return __awaiter(this, void 0, void 0, function () {
          var settings, manager;
          return __generator(this, function (_a) {
              settings = JSON.parse(oidcConfig);
              manager = new UserManager(settings);
              return [2 /*return*/, manager.signoutPopup()];
          });
      });
  }
  function signInPopup(oidcConfig) {
      return __awaiter(this, void 0, void 0, function () {
          var settings, result, errors, manager, state;
          return __generator(this, function (_a) {
              settings = JSON.parse(oidcConfig);
              result = {
                  errorMessage: null,
                  user: null,
                  userManager: null
              };
              errors = [];
              if (settings.popup_redirect_uri == null) {
                  errors.push('Oidc config error: popup_redirect_uri required');
              }
              if (settings.redirect_uri) {
                  errors.push('Oidc config error: redirect_uri not supported - Only popup mode is supported');
              }
              if (errors.length > 0) {
                  result.errorMessage = errors.join('\r\n');
                  return [2 /*return*/, new Promise(function (resolve) {
                          resolve(result);
                      })];
              }
              manager = new UserManager(settings);
              result.userManager = manager;
              state = 'Popup-' + uuidv4();
              return [2 /*return*/, new Promise(function (resolve) {
                      manager.signinPopup({
                          state: state
                      }).then(function (user) {
                          result.user = user;
                          resolve(result);
                      }, function (error) {
                          result.errorMessage = error.message;
                          console.log('error callback signInPopup', error);
                          resolve(result);
                      });
                  })];
          });
      });
  }
  function signInRedirect(oidcConfig) {
      return __awaiter(this, void 0, void 0, function () {
          var settings, result, errors, settingsStore, manager, state, storage;
          return __generator(this, function (_a) {
              settings = JSON.parse(oidcConfig);
              result = {
                  errorMessage: null,
                  user: null,
                  userManager: null
              };
              errors = [];
              if (settings.popup_redirect_uri) {
                  errors.push('Oidc config error: popup_redirect_uri not supported - Only redirect mode is supported');
              }
              if (settings.redirect_uri == null) {
                  errors.push('Oidc config error: redirect_uri required');
              }
              if (errors.length > 0) {
                  result.errorMessage = errors.join('\r\n');
                  return [2 /*return*/, new Promise(function (resolve) {
                          resolve(result);
                      })];
              }
              settingsStore = new UserManagerSettingsStore(settings);
              manager = new UserManager(settingsStore);
              result.userManager = manager;
              state = 'Redirect-' + uuidv4();
              storage = new RedirectStorage();
              storage.push('CAXperts.AuthSettings', JSON.stringify(settings));
              storage.push(state, window.location.href);
              return [2 /*return*/, new Promise(function (resolve) {
                      manager.getUser().then(function (u) {
                          var alreadyAuthenticated = false;
                          if (u) {
                              // server restarts may lead to expired tokens
                              var duration = Math.round(u.expires_at - Date.now() / 1000);
                              alreadyAuthenticated = duration > 15;
                          }
                          if (alreadyAuthenticated) {
                              console.log("Success! Got user. Token valid for ".concat(Math.round(u.expires_at - Date.now() / 1000), " seconds, ends with ").concat(u.access_token.slice(u.access_token.length - 8)));
                              result.user = u;
                              resolve(result);
                          }
                          else {
                              manager.signinRedirect({
                                  state: state
                              }).then(function (user) {
                                  result.user = user;
                                  resolve(result);
                              }, function (error) {
                                  result.errorMessage = error.message;
                                  console.log('error callback signInRedirect', error);
                                  resolve(result);
                              });
                          }
                      });
                  })];
          });
      });
  }
  /**
   * Check if current user has a valid token and redirect to IDS's login page if not.
   * @param originBaseUrl e.g. https://myhost.com/myapp/
   * @param redirectUrl e.g. https://myhost.com/myapp/signaling/loginRedirect.html
   * @param signalingBackendUrl optional if using a WebUPV different from myhost.com .e.g https://backend.com/myapp/signaling
   */
  function quickSignIn(originBaseUrl, redirectUrl, signalingBackendUrl) {
      return __awaiter(this, void 0, void 0, function () {
          var signalingUrl, authSettingsUrl;
          return __generator(this, function (_a) {
              if (!signalingBackendUrl) {
                  signalingBackendUrl = originBaseUrl + signalingBasePath();
              }
              signalingUrl = addUrlPath(originBaseUrl, signalingBasePath());
              console.log("quickSignIn: signalingUrl = ".concat(signalingUrl, ", signalingBackendUrl = ").concat(signalingBackendUrl, ", originBaseUrl =").concat(originBaseUrl, ", redirectUrl =").concat(redirectUrl));
              authSettingsUrl = signalingBackendUrl + '/authenticationSettings';
              return [2 /*return*/, new Promise(function (resolve) {
                      fetch(authSettingsUrl).then(function (res) {
                          res.json().then(function (authSettings) {
                              if (authSettings && authSettings.authority) {
                                  // got URL from server so start authentication to get access token
                                  console.log("Got authentication settings, redirect URL is ".concat(redirectUrl));
                                  if (authSettings.licensingRedirectUrl) {
                                      console.warn("No valid license found redirecting to ".concat(authSettings.licensingRedirectUrl));
                                      window.location.href = authSettings.licensingRedirectUrl;
                                  }
                                  var settings = {
                                      authority: authSettings.authority,
                                      client_id: 'signaling',
                                      redirect_uri: redirectUrl,
                                      scope: 'openid profile wfs_api offline_access',
                                      post_logout_redirect_uri: addUrlPath(signalingUrl, 'logout.html'),
                                      automaticSilentRenew: true,
                                      silent_redirect_uri: addUrlPath(signalingUrl, 'silent-refresh.html'),
                                      response_type: 'code'
                                  };
                                  signInRedirect(JSON.stringify(settings)).then(function (signInResult) {
                                      if (signInResult.errorMessage) {
                                          console.warn('signInRedirect failed:', signInResult);
                                          if (confirm("Identity Server is either unavailable or has no valid certificate. Click 'yes' to visit Identity Server in a new tab to accept. Click 'no' if not sure")) {
                                              window.open(authSettings.authority, 'Accept Identity Server Certificate');
                                          }
                                          else {
                                              // Do nothing!
                                              console.log('Thing was not saved to the database.');
                                          }
                                          resolve({ 'error': true, 'message': signInResult.errorMessage });
                                      }
                                      else {
                                          resolve(signInResult.user);
                                      }
                                  });
                              }
                              else {
                                  // try without access token, maybe the server allows anonymous access
                                  console.log('No authentication required');
                                  resolve(undefined);
                              }
                          }).catch(function (authSettingsException) {
                              var msg = "Failed to read authSettings from ".concat(authSettingsUrl);
                              console.warn(msg, authSettingsException);
                              var resultError = { 'error': true, 'message': msg };
                              resolve(resultError);
                          });
                      }).catch(function (e) {
                          var msg = "Failed to request ".concat(authSettingsUrl);
                          console.error(msg, e);
                          var resultError = { 'error': true, 'message': msg };
                          resolve(resultError);
                      });
                  })];
          });
      });
  }

  class DummyBar {
      constructor(parentElement) {
          this.value = 0;
          const parentDiv = document.createElement('div');
          parentDiv.style.cssText = 'position: absolute; bottom: 10px; left: 0px; width: 100%; border: none; display: inline-block';
          parentElement.parentElement.appendChild(parentDiv);
          const ldBarDiv = document.createElement('div');
          ldBarDiv.style.cssText = 'position: relative; width: 100%; height: 19px';
          parentDiv.appendChild(ldBarDiv);
          this.loadingBarDiv = ldBarDiv;
          const ldBarLabel = document.createElement('div');
          ldBarLabel.style.cssText = 'color: darkgray; font-size: 1.0em; font-weight: 100; position: relative; bottom: 12px;';
          ldBarLabel.innerHTML = '0%';
          ldBarDiv.appendChild(ldBarLabel);
          this.dummyBar = ldBarLabel;
      }
      
      set(newValue, transition) {
          this.value = Math.round(newValue);
          this.dummyBar.innerHTML = `${this.value}%`;
      }
  }

  class StatusLine {
      constructor(parentElement, devMode) {
          this.fadeOutMode = false;
          const spanStatusLine = document.createElement('span');
          spanStatusLine.id = 'statusLine';
          parentElement.appendChild(spanStatusLine);

          this.statusLine1 = document.createTextNode('');
          spanStatusLine.appendChild(this.statusLine1);
          spanStatusLine.appendChild(document.createElement('br'));
          this.statusLine2 = document.createTextNode('');
          spanStatusLine.appendChild(this.statusLine2);
          this.lastStatusMessageTimestamp = Date.now();
          if (!devMode) {
              spanStatusLine.style.display = 'none'; // 'inline-block' to show
          }
          this.loadingBarDiv = document.getElementById('loadingBar');

          if (!this.loadingBarDiv) {
              this.loadingBar = this.createDummyBar(parentElement);
              this.loadingBarDiv = this.loadingBar.loadingBarDiv;
          } else {
              try {
                  this.loadingBar = new ldBar('#loadingBar');
              } catch (e) {
                  this.loadingBarDiv.parentElement.remove();
                  this.loadingBar = this.createDummyBar(parentElement);
                  this.loadingBarDiv = this.loadingBar.loadingBarDiv;
              }
          }
          this.showLoadingBar(devMode);
      }

      createDummyBar(parentElement) {
          return new DummyBar(parentElement);
      }
      
      isLoadingBarRunning() {
          return Date.now() < this.until;
      }

      showLoadingBar(show) {
          this.loadingBarDiv.parentNode.style.display = show ? 'inline-block' : 'none';
      }
      
      startLoadingBar(durationMillis, targetValue, reset) {
          if (isNaN(this.targetValue) || this.targetValue < targetValue) {
              this.targetValue = targetValue;
          }
          if (this.isLoadingBarRunning()) {
              this.until = Date.now() + durationMillis;
          } else {
              this.showLoadingBar(true);
              this.started = Date.now();
              this.until = this.started + durationMillis;
              this.runTimer(reset);
          }
      }

      stopLoadingBar(immediately) {
          this.until = Date.now() - 1;
          this.updateLoadingBar(100);
          if (immediately) {
              this.showLoadingBar(false);
          } else {
              new Promise(resolve => setTimeout(resolve, 100)).then(() =>
                  this.showLoadingBar(false)
              );
          }
      }

      async runTimer(reset) {
          function sleep(ms) {return new Promise(resolve => setTimeout(resolve, ms));}

          let sleepTime = 1;
          let lastUpdate = Date.now();
          if (reset) {
              this.updateLoadingBar(0);
          }
          let currentValue = this.loadingBar.value;
          while (this.isLoadingBarRunning()) {
              await sleep(sleepTime);
              let remainingMillis = this.until - Date.now();
              if (remainingMillis > 0) {
                  let spacePerMilli = (this.targetValue - currentValue) / remainingMillis;
                  let step = spacePerMilli * (Date.now() - lastUpdate);
                  // console.log(`${currentValue} to ${this.targetValue}, bar.value = ${this.getLoadingBarValue()}, step= ${step} -> ${spacePerMilli}/ms, remaining= ${remainingMillis}`);
                  currentValue += step;
                  if (currentValue < this.targetValue) {
                      this.updateLoadingBar(Math.round(currentValue * 100) / 100);
                  } else {
                      break;
                  }
              } else {
                  break;
              }
              lastUpdate = Date.now();
          }
          this.updateLoadingBar(this.targetValue);
          if (this.targetValue >= 100 && !reset) {
              sleep(100).then(() => {
                  this.showLoadingBar(false);
              });
          }
      }

      updateLoadingBar(pctValue) {
          let clampedValue = clamp(pctValue, 0, 100);
          this.loadingBar.set(clampedValue, false);
      }

      incrementLoadingBar(incValue) {
          let nextValue = this.loadingBar.value + (incValue ? incValue : 1);
          let clampedValue = clamp(nextValue, 0, 100);
          this.loadingBar.set(clampedValue, false);
      }

      updateStatus(msg, timeout) {
          if (this.statusLine1 && this.statusLine2) {
              if (this.statusLine2.nodeValue !== msg) {
                  this.statusLine1.nodeValue = this.statusLine2.nodeValue;
                  this.statusLine2.nodeValue = msg;
              }
              if (this.fadeOutMode) {
                  let sleepTime = timeout ? timeout : 1500;
                  let timerStarted = Date.now();
                  this.lastStatusMessageTimestamp = timerStarted;
                  new Promise(resolve => setTimeout(resolve, sleepTime)).then(() => {
                      if (timerStarted === this.lastStatusMessageTimestamp) {
                          this.clearMessages();
                      }
                  });
              }
          }
      }

      clearMessages() {
          if (this.statusLine2.nodeValue) {
              this.statusLine2.nodeValue = '';
              this.statusLine1.nodeValue = '';
          }
      }

      startFadeOutMode(val) {
          if (this.fadeOutMode != val) {
              this.fadeOutMode = val;
              if (this.fadeOutMode) {
                  this.updateStatus('');
              }
          }
      }
  }

  var InputEvent = {
      Keyboard: 0,
      Mouse: 1,
      MouseWheel: 2,
      Touch: 3,
      ButtonClick: 4
  };
  var KeyboardEventType = {
      Up: 0,
      Down: 1
  };
  var EventModifiers = {
      None: 0,
      Shift: 1,
      Control: 2,
      Alt: 4,
      Command: 8
  };
  var PointerPhase = {
      None: 0,
      Began: 1,
      Moved: 2,
      Ended: 3,
      Canceled: 4,
      Stationary: 5
  };
  var Keymap = {
      'Space': 1,
      'Enter': 2,
      'Tab': 3,
      'Backquote': 4,
      'Quote': 5,
      'Semicolon': 6,
      'Comma': 7,
      'Period': 8,
      'Slash': 9,
      'Backslash': 10,
      'LeftBracket': 11,
      'RightBracket': 12,
      'Minus': 13,
      'Equals': 14,
      'KeyA': 15,
      'KeyB': 16,
      'KeyC': 17,
      'KeyD': 18,
      'KeyE': 19,
      'KeyF': 20,
      'KeyG': 21,
      'KeyH': 22,
      'KeyI': 23,
      'KeyJ': 24,
      'KeyK': 25,
      'KeyL': 26,
      'KeyM': 27,
      'KeyN': 28,
      'KeyO': 29,
      'KeyP': 30,
      'KeyQ': 31,
      'KeyR': 32,
      'KeyS': 33,
      'KeyT': 34,
      'KeyU': 35,
      'KeyV': 36,
      'KeyW': 37,
      'KeyX': 38,
      'KeyY': 39,
      'KeyZ': 40,
      'Digit1': 41,
      'Digit2': 42,
      'Digit3': 43,
      'Digit4': 44,
      'Digit5': 45,
      'Digit6': 46,
      'Digit7': 47,
      'Digit8': 48,
      'Digit9': 49,
      'Digit0': 50,
      'ShiftLeft': 51,
      'ShiftRight': 52,
      'AltLeft': 53,
      'AltRight': 54,
      // "AltGr": 54,
      'ControlLeft': 55,
      'ControlRight': 56,
      'MetaLeft': 57,
      'MetaRight': 58,
      // "LeftWindows": 57,
      // "RightWindows": 58,
      // "LeftApple": 57,
      // "RightApple": 58,
      // "LeftCommand": 57,
      // "RightCommand": 58,
      'ContextMenu': 59,
      'Escape': 60,
      'ArrowLeft': 61,
      'ArrowRight': 62,
      'ArrowUp': 63,
      'ArrowDown': 64,
      'Backspace': 65,
      'PageDown': 66,
      'PageUp': 67,
      'Home': 68,
      'End': 69,
      'Insert': 70,
      'Delete': 71,
      'CapsLock': 72,
      'NumLock': 73,
      'PrintScreen': 74,
      'ScrollLock': 75,
      'Pause': 76,
      'NumpadEnter': 77,
      'NumpadDivide': 78,
      'NumpadMultiply': 79,
      'NumpadPlus': 80,
      'NumpadMinus': 81,
      'NumpadPeriod': 82,
      'NumpadEquals': 83,
      'Numpad0': 84,
      'Numpad1': 85,
      'Numpad2': 86,
      'Numpad3': 87,
      'Numpad4': 88,
      'Numpad5': 89,
      'Numpad6': 90,
      'Numpad7': 91,
      'Numpad8': 92,
      'Numpad9': 93,
      'F1': 94,
      'F2': 95,
      'F3': 96,
      'F4': 97,
      'F5': 98,
      'F6': 99,
      'F7': 100,
      'F8': 101,
      'F9': 102,
      'F10': 103,
      'F11': 104,
      'F12': 105,
      // "OEM1": 106,
      // "OEM2": 107,
      // "OEM3": 108,
      // "OEM4": 109,
      // "OEM5": 110,
      // "IMESelected": 111,
  };
  var UiFocusInfoMessage = /** @class */ (function () {
      function UiFocusInfoMessage() {
          this.text = '';
          this.x = 0;
          this.y = 0;
          this.width = 0;
          this.height = 0;
          this.timestampUtc = Date.now();
      }
      return UiFocusInfoMessage;
  }());
  var tempInputElementId = 'tempInputElementId';
  var iosTempInputElementId = 'tempInputElementId_Ios';
  var mouseWheelFactor = 1.25;
  var _previousKeyUpEventHandler;
  var _previousKeyDownEventHandler;
  var focusInfo = new UiFocusInfoMessage();
  var htmlVideoPlayer;
  var lastSingleTouchPhase = 0;
  function unregisterEvents(videoElement) {
      if (videoElement) {
          videoElement.removeEventListener('keydown', _previousKeyDownEventHandler);
          videoElement.removeEventListener('keyup', _previousKeyUpEventHandler);
      }
      window.removeEventListener('keydown', _previousKeyDownEventHandler);
      window.removeEventListener('keyup', _previousKeyUpEventHandler);
      _previousKeyDownEventHandler = null;
      _previousKeyUpEventHandler = null;
  }
  function registerKeyboardEvents(videoPlayer, playerElement) {
      if (isUserAgentChrome()) {
          var isWin = (navigator.appVersion.indexOf('Win') !== -1);
          mouseWheelFactor = isWin ? 0.5 : 1.0;
      }
      var _videoPlayer = videoPlayer;
      htmlVideoPlayer = playerElement;
      playerElement.tabIndex = 0;
      _previousKeyUpEventHandler = sendKeyUp;
      // Safari + Android keyboard does not send keyboard events to video elements, thus register them globally at window
      // strangely enough mouse and touch are working fine
      if (isUserAgentSafari() || isUserAgentAndroid()) {
          console.log('Mobile key event listeners added to window');
          window.addEventListener('keyup', sendKeyUp, false);
          window.addEventListener('keydown', sendKeyDown, false);
          _previousKeyDownEventHandler = sendKeyDown;
      }
      else {
          console.log('Non-mobile key event listeners added to video element');
          playerElement.addEventListener('keyup', sendKeyUp, false);
          playerElement.addEventListener('keydown', sendKeyDownVideo, false);
          _previousKeyDownEventHandler = sendKeyDownVideo;
      }
      function sendKeyUp(e) {
          sendKey(e, KeyboardEventType.Up, _videoPlayer);
      }
      function sendKeyDown(e) {
          if (e.key === 'Backspace' || e.key === 'Tab' || e.key === ' ') {
              e.preventDefault();
          }
          // Check ctrl c,x and v
          if (Keymap[e.code] === Keymap.KeyC && (e.ctrlKey || e.metaKey)) {
              var clipboardMessage = {
                  Id: 0
              };
              _videoPlayer === null || _videoPlayer === void 0 ? void 0 : _videoPlayer.clipboardChannelHandler.sendMessage(JSON.stringify(clipboardMessage), 'ClipboardMessage', null);
          }
          else if (Keymap[e.code] === Keymap.KeyX && (e.ctrlKey || e.metaKey)) {
              var clipboardMessage = {
                  Id: 2
              };
              _videoPlayer === null || _videoPlayer === void 0 ? void 0 : _videoPlayer.clipboardChannelHandler.sendMessage(JSON.stringify(clipboardMessage), 'ClipboardMessage', null);
          }
          else if (Keymap[e.code] === Keymap.KeyV && (e.ctrlKey || e.metaKey)) {
              var clipboard = navigator.clipboard;
              if (clipboard) {
                  clipboard.readText().then(function (value) {
                      var clipboardMessage = {
                          Id: 1,
                          text: value
                      };
                      _videoPlayer === null || _videoPlayer === void 0 ? void 0 : _videoPlayer.clipboardChannelHandler.sendMessage(JSON.stringify(clipboardMessage), 'ClipboardMessage', null);
                  }).catch(function (reason) {
                      var clipboardWarning = 'Access to clipboard is only available from secure origins or localhost';
                      alert(clipboardWarning);
                  });
              }
              else {
                  var clipboardWarning = 'Access to clipboard is only available from secure origins or localhost';
                  alert(clipboardWarning);
              }
          }
          else {
              sendKey(e, KeyboardEventType.Down, _videoPlayer);
          }
      }
      function sendKeyDownVideo(e) {
          var target = e.target;
          if (target.id === 'Video') {
              sendKeyDown(e);
          }
      }
  }
  function sendKey(e, type, player) {
      var _a, _b;
      var code = e.code;
      // Check for android
      if (isUserAgentAndroid()) {
          var target = e.target;
          // Android keyboard has taken control when Process is being sent. Send full text.
          // This is triggered on firefox
          if (e.key === 'Process' && target !== null && target !== undefined) {
              var text = target.value;
              var message = {
                  Text: text
              };
              (_a = player === null || player === void 0 ? void 0 : player.inputChannelHandlerHandler) === null || _a === void 0 ? void 0 : _a.sendMessage(JSON.stringify(message), 'UiSetFullTextMessage', null);
              return;
          }
          // This is for Enter
          if (e.code === null || e.code === '') {
              code = e.key;
          }
      }
      var key = Keymap[code];
      var character = e.key.length === 1 ? e.key.charCodeAt(0) : 0;
      var mod = (e.shiftKey ? EventModifiers.Shift : 0)
          + (e.ctrlKey ? EventModifiers.Control : 0)
          + (e.altKey ? EventModifiers.Alt : 0)
          + (e.metaKey ? EventModifiers.Command : 0);
      var enc = new TextEncoder(); // always utf-8
      var utf8Encoded = enc.encode(e.key);
      var data = new Uint8Array(7 + utf8Encoded.length);
      data.set([InputEvent.Keyboard, type, e.repeat, mod, key, character], 0);
      data.set(utf8Encoded, 6);
      // console.log(`key down ${key}, mod = ${mod}, utf.len = ${utf8Encoded.length}, data.len = ${data.length} key:${e.key}, encoded = ${utf8Encoded}, character = ${character}`, e);
      (_b = player === null || player === void 0 ? void 0 : player.inputChannelHandlerHandler) === null || _b === void 0 ? void 0 : _b.sendMsg(data.buffer);
      // Close keyboard if enter pressed.
      if (code === 'Enter') {
          closeTouchInputAndFocusBody();
      }
  }
  function registerMouseEvents(videoPlayer, playerElement) {
      var _videoPlayer = videoPlayer;
      // Listen to mouse events
      playerElement.addEventListener('click', sendMouse, false);
      playerElement.addEventListener('mousedown', sendMouse, false);
      playerElement.addEventListener('mouseup', sendMouse, false);
      playerElement.addEventListener('mousemove', sendMouse, false);
      playerElement.addEventListener('wheel', sendMouseWheel, false);
      // Touch event Level1 https://www.w3.org/TR/touch-events/
      // Touch event Level2 https://w3c.github.io/touch-events/
      //
      playerElement.addEventListener('touchend', sendTouchEnd, false);
      playerElement.addEventListener('touchstart', sendTouchStart, false);
      playerElement.addEventListener('touchcancel', sendTouchCancel, false);
      playerElement.addEventListener('touchmove', sendTouchMove, false);
      videoPlayer.inputChannelHandlerHandler.onfocusInfo = function (e) {
          focusInfo = e;
          if (lastSingleTouchPhase === PointerPhase.Ended) {
              if (e.isInputField) {
                  // IOS hack unfortunately without it, it won't focus on input element
                  var timeOut = isUserAgentIos() ? 100 : 0;
                  setTimeout(function (h) {
                      focusAndOpenKeyboard(_videoPlayer, e);
                  }, timeOut);
              }
              else {
                  closeTouchInputAndFocusBody();
              }
          }
          else {
              if (!e.isInputField) {
                  closeTouchInputAndFocusBody();
              }
          }
      };
      function sendTouch(e, phase) {
          var changedTouches = Array.from(e.changedTouches);
          var touches = Array.from(e.touches);
          var phrases = [];
          var _loop_1 = function (i) {
              if (touches.find(function (t) {
                  return t.identifier === changedTouches[i].identifier;
              }) === undefined) {
                  touches.push(changedTouches[i]);
              }
          };
          for (var i = 0; i < changedTouches.length; i++) {
              _loop_1(i);
          }
          var _loop_2 = function (i) {
              phrases[i] = changedTouches.find(function (t) {
                  return t.identifier === touches[i].identifier;
              }) === undefined ? PointerPhase.Stationary : phase;
          };
          for (var i = 0; i < touches.length; i++) {
              _loop_2(i);
          }
          var data = new DataView(new ArrayBuffer(2 + 13 * touches.length));
          data.setUint8(0, InputEvent.Touch);
          data.setUint8(1, touches.length);
          var byteOffset = 2;
          var x = 0;
          var y = 0;
          for (var i = 0; i < touches.length; i++) {
              var scale = _videoPlayer.videoScale;
              var originX = _videoPlayer.videoOriginX;
              var originY = _videoPlayer.videoOriginY;
              x = (touches[i].pageX - originX) / scale;
              y = _videoPlayer.videoHeight - (touches[i].pageY - originY) / scale;
              data.setInt32(byteOffset, touches[i].identifier, true);
              byteOffset += 4;
              data.setUint8(byteOffset, phrases[i]);
              byteOffset += 1;
              data.setInt16(byteOffset, x, true);
              byteOffset += 2;
              data.setInt16(byteOffset, y, true);
              byteOffset += 2;
              data.setFloat32(byteOffset, touches[i].force, true);
              byteOffset += 4;
          }
          if (_videoPlayer && _videoPlayer.inputChannelHandlerHandler) {
              _videoPlayer.inputChannelHandlerHandler.sendMsg(data.buffer);
          }
          // IOS hack unfortunately without it, it won't focus on input element
          if (touches.length === 1) {
              lastSingleTouchPhase = phase;
              if (phase === PointerPhase.Ended && focusInfo && focusInfo.isInputField) {
                  createTempIosInputElement();
              }
          }
          else {
              lastSingleTouchPhase = 0;
          }
      }
      function sendTouchMove(e) {
          sendTouch(e, PointerPhase.Moved);
          e.preventDefault();
      }
      function sendTouchStart(e) {
          sendTouch(e, PointerPhase.Began);
          e.preventDefault();
      }
      function sendTouchEnd(e) {
          sendTouch(e, PointerPhase.Ended);
          e.preventDefault();
      }
      function sendTouchCancel(e) {
          sendTouch(e, PointerPhase.Canceled);
          e.preventDefault();
      }
      function sendMouse(e) {
          var scale = _videoPlayer.videoScale;
          var originX = _videoPlayer.videoOriginX;
          var originY = _videoPlayer.videoOriginY;
          var x = (e.clientX - originX) / scale;
          // According to Unity Coordinate system
          // const y = (e.clientY - originY) / scale;
          var y = _videoPlayer.videoHeight - (e.clientY - originY) / scale;
          var data = new DataView(new ArrayBuffer(6));
          data.setUint8(0, InputEvent.Mouse);
          data.setInt16(1, x, true);
          data.setInt16(3, y, true);
          data.setUint8(5, e.buttons);
          if (_videoPlayer && _videoPlayer.inputChannelHandlerHandler) {
              _videoPlayer.inputChannelHandlerHandler.sendMsg(data.buffer);
          }
      }
      function sendMouseWheel(e) {
          var data = new DataView(new ArrayBuffer(9));
          data.setUint8(0, InputEvent.MouseWheel);
          var maxY = 30;
          var deltaY = mouseWheelFactor * Math.sign(e.deltaY) * Math.max(maxY, Math.abs(e.deltaY));
          data.setFloat32(1, e.deltaX, true);
          data.setFloat32(5, deltaY, true);
          if (_videoPlayer && _videoPlayer.inputChannelHandlerHandler) {
              _videoPlayer.inputChannelHandlerHandler.sendMsg(data.buffer);
          }
          if (e.ctrlKey) {
              e.preventDefault();
          }
      }
  }
  function registerClipboardEvent(videoPlayer) {
      videoPlayer.clipboardChannelHandler.onsetRemoteClipboardContent = function (e) {
          // set clipboard
          var clipboard = navigator.clipboard;
          if (clipboard) {
              clipboard.writeText(e.Text).catch(function (error) {
                  var warningMessage = "Failed to write body to clipboard. System does not allow access to clipboard";
                  console.warn(warningMessage, error);
                  alert(warningMessage);
              });
          }
          else {
              var clipboardWarning = 'Access to clipboard is only available from secure origins or localhost';
              alert(clipboardWarning);
          }
      };
  }
  /**
   * Inspired by https://stackoverflow.com/a/55425845/437283
   * @param parentElement e.g. video element.
   * @param focusMessage UiFocusInfoMessage
   */
  function focusAndOpenKeyboard(parentElement, focusMessage) {
      if (parentElement && !isInputTouchKeyboardOpen()) {
          console.log("Open keyboard, parent at ".concat(parentElement), focusMessage);
          // On android not resizing while opening keyboard, change css values.
          // See modelConnector.ts window.addEventListener('resize')
          var height_1 = htmlVideoPlayer.style.height;
          if (isUserAgentAndroid()) {
              htmlVideoPlayer.style.height = 'auto';
          }
          // Align temp input element approximately where the input element is
          // so the cursor doesn't jump around
          var tempInputElement_1 = document.createElement('input');
          tempInputElement_1.id = tempInputElementId;
          tempInputElement_1.value = focusMessage.text;
          tempInputElement_1.style.position = 'absolute'; // For auto scroll should be absolute
          tempInputElement_1.style.top = "".concat(getWindowHeight() - focusMessage.y - focusMessage.height, "px");
          tempInputElement_1.style.width = "".concat(focusMessage.width, "px");
          tempInputElement_1.style.left = "".concat(focusMessage.x, "px");
          tempInputElement_1.style.height = '16';
          tempInputElement_1.style.fontSize = '16px';
          tempInputElement_1.style.visibility = 'visible';
          tempInputElement_1.style.opacity = '0.01'; // Auto scroll to input element doesn't work with 0 opacity
          tempInputElement_1.style.caretColor = 'rgba(0,0,0,0)';
          // Put this temp element as a child of the page <body> and focus on it
          document.body.appendChild(tempInputElement_1);
          // Remove temp element for ios
          removeTempIosInputElement();
          tempInputElement_1.addEventListener('blur', function (event) {
              var element = (tempInputElement_1);
              console.log("blur event ".concat(element.value), event);
              if (!isUserAgentIos()) {
                  sendUiSetFullTextMessage(element, parentElement);
              }
              document.body.removeChild(tempInputElement_1);
              if (isUserAgentAndroid()) {
                  // Set back old values for android
                  htmlVideoPlayer.style.height = height_1;
              }
          });
          if (!isUserAgentIos()) {
              // iOS sends keys via the global listener of the window
              tempInputElement_1.addEventListener('input', function (e) {
                  // called on every single character input
                  var target = (e.target);
                  sendUiSetFullTextMessage(target, parentElement);
              });
          }
          tempInputElement_1.addEventListener('change', function (e) {
              // ensure that enter key is processed
              var target = (e.target);
              target.blur();
          });
          if (isUserAgentAndroid()) {
              // non-Android systems automatically overwride global key listener above which is blocking backspace thus a
              // workaround for Android needed to manipulate input field instantaneously otherwise the final
              // sendUiSetFullTextMessage would contain the deleted characters
              tempInputElement_1.addEventListener('keydown', function (evt) {
                  if (evt.key === 'Backspace') {
                      if (tempInputElement_1.value.length > 0) {
                          tempInputElement_1.value = tempInputElement_1.value.substring(0, tempInputElement_1.value.length - 1);
                      }
                  }
              });
          }
          tempInputElement_1.focus();
      }
  }
  function createTempIosInputElement() {
      if (!isUserAgentIos()) {
          return;
      }
      var tempEl = document.createElement('input');
      tempEl.id = iosTempInputElementId;
      tempEl.style.position = 'absolute';
      tempEl.style.bottom = '26px';
      tempEl.style.left = '0';
      tempEl.style.height = '16';
      tempEl.style.opacity = '0.0';
      document.body.appendChild(tempEl);
      tempEl.focus();
      tempEl.click();
  }
  function removeTempIosInputElement() {
      if (!isUserAgentIos()) {
          return;
      }
      var tempEl = document.getElementById(iosTempInputElementId);
      if (tempEl) {
          document.body.removeChild(tempEl);
      }
  }
  function sendUiSetFullTextMessage(target, player) {
      var _a;
      var text = target.value;
      var message = {
          Text: text
      };
      (_a = player === null || player === void 0 ? void 0 : player.inputChannelHandlerHandler) === null || _a === void 0 ? void 0 : _a.sendMessage(JSON.stringify(message), 'UiSetFullTextMessage', null);
  }
  function closeTouchInputAndFocusBody() {
      var element = document.getElementById(tempInputElementId);
      removeTempIosInputElement();
      if (element) {
          element.blur();
          document.body.focus();
      }
      focusInfo = null;
  }
  function isInputTouchKeyboardOpen() {
      return document.getElementById(tempInputElementId) !== null;
  }

  var UpvApiCookies = /** @class */ (function () {
      function UpvApiCookies() {
          this.keyNextClientId = 'nextClientId';
          this.keyClientId = 'clientId';
      }
      UpvApiCookies.prototype.getCookie = function (name) {
          var nameEQ = name + '=';
          var ca = document.cookie.split(';');
          for (var i = 0; i < ca.length; i++) {
              var c = ca[i];
              while (c.charAt(0) === ' ') {
                  c = c.substring(1, c.length);
              }
              if (c.indexOf(nameEQ) === 0) {
                  return c.substring(nameEQ.length, c.length);
              }
          }
          return null;
      };
      UpvApiCookies.prototype.setCookie = function (name, val) {
          document.cookie = "".concat(name, "=").concat(val, ";path=/");
      };
      UpvApiCookies.prototype.getCookieNameByValue = function (cookieValue, cookieNamePrefix) {
          var name;
          var pageCookies = this.getPageCookies();
          pageCookies.forEach(function (val, key) {
              if (key.startsWith(cookieNamePrefix) && val === cookieValue) {
                  if (!name) {
                      name = key;
                      console.log("cookie found ".concat(key, " = ").concat(val));
                  }
                  else {
                      console.warn("Found another matching cookie ".concat(key));
                  }
              }
          });
          return name;
      };
      UpvApiCookies.prototype.updateClientIdCookieFromNextId = function (clientId) {
          var nextIdName = this.getCookieNameByValue(clientId, this.keyNextClientId);
          if (nextIdName) {
              var idName = nextIdName.replace(this.keyNextClientId, this.keyClientId);
              this.setCookie(idName, clientId);
          }
      };
      UpvApiCookies.prototype.eraseCookie = function (name) {
          document.cookie = name + '=; path=/; Max-Age=-99999999;';
      };
      UpvApiCookies.prototype.cleanupCookie = function (cookieNamePrefix, clientId) {
          var _this = this;
          var pageCookies = this.getPageCookies();
          pageCookies.forEach(function (val, key) {
              // usually only one cookie should be found
              if (key.startsWith(cookieNamePrefix) && val === clientId) {
                  _this.eraseCookie(key);
                  console.log("".concat(key, " cookie cleared"));
              }
          });
      };
      UpvApiCookies.prototype.cleanupAllCookies = function (clientId) {
          this.cleanupCookie(this.keyClientId, clientId);
          this.cleanupCookie(this.keyNextClientId, clientId);
      };
      /**
       * Get all cookies as map of {name; value} pairs, s. https://stackoverflow.com/a/53641866/437283
       */
      UpvApiCookies.prototype.getPageCookies = function () {
          // cookie is a string containing a semicolon-separated list, this split puts it into an array
          var cookieArr = document.cookie.split(';');
          // This object will hold all of the key value pairs
          var cookieMap = new Map();
          // Iterate the array of flat cookies to get their key value pair
          for (var i = 0; i < cookieArr.length; i++) {
              // Remove the standardized whitespace
              var cookieSeg = cookieArr[i].trim();
              // Index of the split between key and value
              var firstEq = cookieSeg.indexOf('=');
              // Assignments
              var name_1 = cookieSeg.substr(0, firstEq);
              cookieMap.set(name_1, cookieSeg.substr(firstEq + 1));
          }
          return cookieMap;
      };
      return UpvApiCookies;
  }());

  /**
   * Base implementation of TypedEmitter. Sub-class sample for 'connected' event with boolean parameter:
   * export class SignalStateEventTarget extends GenericEmitter<{ connected: boolean }> {}
   */
  var GenericEmitter = /** @class */ (function () {
      function GenericEmitter() {
          this.listeners = {};
      }
      GenericEmitter.prototype.emit = function (eventName, params) {
          (this.listeners[eventName] || []).forEach(function (fn) {
              fn(params);
          });
      };
      GenericEmitter.prototype.off = function (eventName, fn) {
          this.listeners[eventName] = (this.listeners[eventName] || []).filter(function (f) { return f !== fn; });
      };
      GenericEmitter.prototype.on = function (eventName, fn) {
          this.listeners[eventName] = (this.listeners[eventName] || []).concat(fn);
      };
      GenericEmitter.prototype.once = function (eventName, fn) {
          var _this = this;
          var wrapper = function (params) {
              _this.off(eventName, wrapper);
              fn(params);
          };
          this.on(eventName, wrapper);
      };
      GenericEmitter.prototype.numberOfListeners = function (eventName) {
          var _a, _b;
          return (_b = (_a = this.listeners[eventName]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      };
      return GenericEmitter;
  }());

  var StatusLogLevel;
  (function (StatusLogLevel) {
      StatusLogLevel[StatusLogLevel["Error"] = 0] = "Error";
      StatusLogLevel[StatusLogLevel["Warning"] = 1] = "Warning";
      StatusLogLevel[StatusLogLevel["Info"] = 2] = "Info";
      StatusLogLevel[StatusLogLevel["Debug"] = 3] = "Debug";
  })(StatusLogLevel || (StatusLogLevel = {}));
  var ConnectedEventEmitter = /** @class */ (function (_super) {
      __extends(ConnectedEventEmitter, _super);
      function ConnectedEventEmitter() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      return ConnectedEventEmitter;
  }(GenericEmitter));
  var Connector = /** @class */ (function () {
      function Connector() {
          this.weblauncherCookieExpireDateUtc = new Date();
          this.upvCookies = new UpvApiCookies();
          window.setInterval(this.checkWeblauncherCookie.bind(this), 5000);
      }
      Object.defineProperty(Connector.prototype, "userInfo", {
          get: function () {
              return this._userInfo;
          },
          set: function (value) {
              this._userInfo = value;
          },
          enumerable: false,
          configurable: true
      });
      Connector.prototype.checkWeblauncherCookie = function () {
          return __awaiter(this, void 0, void 0, function () {
              var modelHeaders;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (!(this.hasAccessToken() && this.weblauncherCookieExpireDateUtc < new Date())) return [3 /*break*/, 2];
                          return [4 /*yield*/, this.headers()];
                      case 1:
                          modelHeaders = _a.sent();
                          fetch(url("upvapi/SetAuthenticationCookie"), { method: 'POST', headers: modelHeaders }).then(function (r) { return __awaiter(_this, void 0, void 0, function () {
                              var json, MS_PER_MINUTE;
                              return __generator(this, function (_a) {
                                  switch (_a.label) {
                                      case 0: return [4 /*yield*/, r.json()];
                                      case 1:
                                          json = _a.sent();
                                          MS_PER_MINUTE = 60000;
                                          this.weblauncherCookieExpireDateUtc = new Date(new Date(json.expiresUtc).getTime() - 10 * MS_PER_MINUTE);
                                          console.log('WebLauncher cookie set - next request at', this.weblauncherCookieExpireDateUtc);
                                          return [2 /*return*/];
                                  }
                              });
                          }); });
                          _a.label = 2;
                      case 2: return [2 /*return*/];
                  }
              });
          });
      };
      Connector.prototype.recreateClientId = function () {
          var nextClientId;
          var searchParams = (new URL(document.location.href)).searchParams;
          if (searchParams.has('clientId')) {
              nextClientId = searchParams.get('clientId');
              console.log("using clientId from parameter: ".concat(nextClientId));
              this.upvCookies.updateClientIdCookieFromNextId(nextClientId);
          }
          else {
              // for backward compatibility with Unifier
              nextClientId = this.upvCookies.getCookie('nextClientId');
              if (nextClientId) {
                  console.log("using nextClientId from cookie: ".concat(nextClientId));
              }
          }
          if (nextClientId != null) {
              this.clientId = nextClientId;
          }
          else {
              this.clientId = uuidv4();
              console.log("ClientId recreated: ".concat(this.clientId));
          }
          // for backward compatibility with Unifier
          document.cookie = 'clientId=' + this.clientId + ';path=/';
      };
      Connector.prototype.setAccessTokenCall = function (accessTokenFn) {
          this.initialized = true;
          this.accessTokenFn = accessTokenFn;
      };
      Connector.prototype.setUserInfo = function (info) {
          var _this = this;
          this.initialized = true;
          this._userInfo = info;
          window.addEventListener('beforeunload', function (e) {
              console.log('connector received unload event');
              _this.shutdown();
          });
          // TODO kay: find a way to have the hub connection pre-initialised; in case of connection errors init() turned out as dangerous
          // this.init().catch(e => console.error(`connector.setUserInfo failed to pre-start hub connection`));
          if (!this._userInfo) {
              console.log('setUserInfo called for anonymous access');
              return;
          }
          var storage = new RedirectStorage();
          this.authSettings = JSON.parse(storage.pop('CAXperts.AuthSettings'));
          console.log("Got authSettings from RedirectStorage");
          this.authService = new UserManager(this.authSettings);
          // decomment the following event handler for debugging access token issues
          // userManager.events.addAccessTokenExpiring((args) => {
          //     console.log(`AccessTokenExpiring in ${this.userInfo?.expires_at - Date.now() / 1000} secs`);
          // });
          this.authService.events.addAccessTokenExpired(function (args) {
              var _a;
              var duration = Date.now() / 1000 - ((_a = _this.userInfo) === null || _a === void 0 ? void 0 : _a.expires_at);
              console.log("AccessTokenExpired before ".concat(duration, " secs, auto-renewal = ").concat(_this.authSettings.automaticSilentRenew));
              if (duration < 300) { // silent renewal by refresh token does not work after token expired, thus try manual refresh
                  _this.authService.signinSilent().then(function (u) {
                      console.log('Manual signin successful, access token renewed');
                      _this._userInfo = u;
                  }).catch(function (error) {
                      console.log("Failed to sign in manually in order to renew access token: ".concat(error.message));
                  });
              }
              else {
                  // longer outage, reload page
                  window.location.reload();
              }
          });
          this.authService.events.addSilentRenewError(function (error) {
              var _a;
              return console.warn("Silent token renewal failed: ".concat(error.message, "! ")
                  + "Access token will expire in ".concat(((_a = _this.userInfo) === null || _a === void 0 ? void 0 : _a.expires_at) - Date.now() / 1000, " secs"));
          });
          this.authService.events.addUserSignedOut(function () { return console.log('User signed out'); });
      };
      Connector.prototype.hasAccessToken = function () {
          if (this._userInfo) {
              return this._userInfo.access_token && this._userInfo.access_token !== '';
          }
          return false;
      };
      Connector.prototype.headers = function () {
          return __awaiter(this, arguments, void 0, function (sessionId) {
              var allHeaders, u, e_1;
              if (sessionId === void 0) { sessionId = null; }
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          allHeaders = { 'Content-Type': 'application/json' };
                          if (sessionId !== null) {
                              allHeaders['Session-Id'] = sessionId;
                          }
                          if (!this.accessTokenFn) return [3 /*break*/, 1];
                          allHeaders['Authorization'] = 'Bearer ' + this.accessTokenFn();
                          return [2 /*return*/, allHeaders];
                      case 1:
                          if (!this.hasAccessToken()) return [3 /*break*/, 6];
                          _a.label = 2;
                      case 2:
                          _a.trys.push([2, 4, , 5]);
                          return [4 /*yield*/, this.refreshUserInfo()];
                      case 3:
                          u = _a.sent();
                          allHeaders['Authorization'] = 'Bearer ' + u.access_token;
                          return [2 /*return*/, allHeaders];
                      case 4:
                          e_1 = _a.sent();
                          console.error("Exception when getting user", e_1);
                          return [2 /*return*/, allHeaders];
                      case 5: return [3 /*break*/, 7];
                      case 6: return [2 /*return*/, allHeaders];
                      case 7: return [2 /*return*/];
                  }
              });
          });
      };
      Connector.prototype.refreshUserInfo = function () {
          return __awaiter(this, void 0, void 0, function () {
              var u;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this.authService.getUser()];
                      case 1:
                          u = _a.sent();
                          if (u.access_token !== this.userInfo.access_token) {
                              console.log("renewing access token");
                              this.userInfo = u;
                          }
                          return [2 /*return*/, u];
                  }
              });
          });
      };
      // TODO delete when cleaning sse from typescript
      Connector.prototype.signalingUrl = function (method) {
          var s = signalingBasePath();
          if (method && method.length > 0) {
              s = s + '/' + method;
          }
          return url(s);
      };
      Connector.prototype.getModels = function (sessionId_1) {
          return __awaiter(this, arguments, void 0, function (sessionId, fromTime) {
              var modelHeaders;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this.headers()];
                      case 1:
                          modelHeaders = _a.sent();
                          return [2 /*return*/, fetch(url("models"), { method: 'GET', headers: modelHeaders })];
                  }
              });
          });
      };
      Connector.prototype.getIceServersConfig = function () {
          return __awaiter(this, void 0, void 0, function () {
              var headers, url1;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this.headers()];
                      case 1:
                          headers = _a.sent();
                          url1 = url('iceServers');
                          return [2 /*return*/, fetch(url1, { method: 'GET', headers: headers })];
                  }
              });
          });
      };
      Connector.prototype.sendWindowClosed = function (sessionId, targetId) {
          var urlClientWindowClosed = url('clientWindowClosed');
          var session = { sessionId: sessionId, targetId: targetId };
          var blob = new Blob([JSON.stringify(session)], { type: 'application/json; charset=UTF-8' });
          this.upvCookies.cleanupAllCookies(this.clientId);
          // Queue beacon request
          console.log("sending clientWindowClosed to URL: ".concat(urlClientWindowClosed), blob);
          var status = navigator.sendBeacon(urlClientWindowClosed, blob);
          this.shutdown();
          console.log('clientWindowClosed sent ' + status);
      };
      return Connector;
  }());

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  /** Error thrown when an HTTP request fails. */
  class HttpError extends Error {
      /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.
       *
       * @param {string} errorMessage A descriptive error message.
       * @param {number} statusCode The HTTP status code represented by this error.
       */
      constructor(errorMessage, statusCode) {
          const trueProto = new.target.prototype;
          super(`${errorMessage}: Status code '${statusCode}'`);
          this.statusCode = statusCode;
          // Workaround issue in Typescript compiler
          // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
          this.__proto__ = trueProto;
      }
  }
  /** Error thrown when a timeout elapses. */
  class TimeoutError extends Error {
      /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.
       *
       * @param {string} errorMessage A descriptive error message.
       */
      constructor(errorMessage = "A timeout occurred.") {
          const trueProto = new.target.prototype;
          super(errorMessage);
          // Workaround issue in Typescript compiler
          // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
          this.__proto__ = trueProto;
      }
  }
  /** Error thrown when an action is aborted. */
  class AbortError extends Error {
      /** Constructs a new instance of {@link AbortError}.
       *
       * @param {string} errorMessage A descriptive error message.
       */
      constructor(errorMessage = "An abort occurred.") {
          const trueProto = new.target.prototype;
          super(errorMessage);
          // Workaround issue in Typescript compiler
          // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
          this.__proto__ = trueProto;
      }
  }
  /** Error thrown when the selected transport is unsupported by the browser. */
  /** @private */
  class UnsupportedTransportError extends Error {
      /** Constructs a new instance of {@link @microsoft/signalr.UnsupportedTransportError}.
       *
       * @param {string} message A descriptive error message.
       * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.
       */
      constructor(message, transport) {
          const trueProto = new.target.prototype;
          super(message);
          this.transport = transport;
          this.errorType = 'UnsupportedTransportError';
          // Workaround issue in Typescript compiler
          // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
          this.__proto__ = trueProto;
      }
  }
  /** Error thrown when the selected transport is disabled by the browser. */
  /** @private */
  class DisabledTransportError extends Error {
      /** Constructs a new instance of {@link @microsoft/signalr.DisabledTransportError}.
       *
       * @param {string} message A descriptive error message.
       * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.
       */
      constructor(message, transport) {
          const trueProto = new.target.prototype;
          super(message);
          this.transport = transport;
          this.errorType = 'DisabledTransportError';
          // Workaround issue in Typescript compiler
          // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
          this.__proto__ = trueProto;
      }
  }
  /** Error thrown when the selected transport cannot be started. */
  /** @private */
  class FailedToStartTransportError extends Error {
      /** Constructs a new instance of {@link @microsoft/signalr.FailedToStartTransportError}.
       *
       * @param {string} message A descriptive error message.
       * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.
       */
      constructor(message, transport) {
          const trueProto = new.target.prototype;
          super(message);
          this.transport = transport;
          this.errorType = 'FailedToStartTransportError';
          // Workaround issue in Typescript compiler
          // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
          this.__proto__ = trueProto;
      }
  }
  /** Error thrown when the negotiation with the server failed to complete. */
  /** @private */
  class FailedToNegotiateWithServerError extends Error {
      /** Constructs a new instance of {@link @microsoft/signalr.FailedToNegotiateWithServerError}.
       *
       * @param {string} message A descriptive error message.
       */
      constructor(message) {
          const trueProto = new.target.prototype;
          super(message);
          this.errorType = 'FailedToNegotiateWithServerError';
          // Workaround issue in Typescript compiler
          // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
          this.__proto__ = trueProto;
      }
  }
  /** Error thrown when multiple errors have occurred. */
  /** @private */
  class AggregateErrors extends Error {
      /** Constructs a new instance of {@link @microsoft/signalr.AggregateErrors}.
       *
       * @param {string} message A descriptive error message.
       * @param {Error[]} innerErrors The collection of errors this error is aggregating.
       */
      constructor(message, innerErrors) {
          const trueProto = new.target.prototype;
          super(message);
          this.innerErrors = innerErrors;
          // Workaround issue in Typescript compiler
          // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
          this.__proto__ = trueProto;
      }
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  /** Represents an HTTP response. */
  class HttpResponse {
      constructor(statusCode, statusText, content) {
          this.statusCode = statusCode;
          this.statusText = statusText;
          this.content = content;
      }
  }
  /** Abstraction over an HTTP client.
   *
   * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.
   */
  class HttpClient {
      get(url, options) {
          return this.send({
              ...options,
              method: "GET",
              url,
          });
      }
      post(url, options) {
          return this.send({
              ...options,
              method: "POST",
              url,
          });
      }
      delete(url, options) {
          return this.send({
              ...options,
              method: "DELETE",
              url,
          });
      }
      /** Gets all cookies that apply to the specified URL.
       *
       * @param url The URL that the cookies are valid for.
       * @returns {string} A string containing all the key-value cookie pairs for the specified URL.
       */
      // @ts-ignore
      getCookieString(url) {
          return "";
      }
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  // These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.
  /** Indicates the severity of a log message.
   *
   * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.
   */
  var LogLevel;
  (function (LogLevel) {
      /** Log level for very low severity diagnostic messages. */
      LogLevel[LogLevel["Trace"] = 0] = "Trace";
      /** Log level for low severity diagnostic messages. */
      LogLevel[LogLevel["Debug"] = 1] = "Debug";
      /** Log level for informational diagnostic messages. */
      LogLevel[LogLevel["Information"] = 2] = "Information";
      /** Log level for diagnostic messages that indicate a non-fatal problem. */
      LogLevel[LogLevel["Warning"] = 3] = "Warning";
      /** Log level for diagnostic messages that indicate a failure in the current operation. */
      LogLevel[LogLevel["Error"] = 4] = "Error";
      /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */
      LogLevel[LogLevel["Critical"] = 5] = "Critical";
      /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */
      LogLevel[LogLevel["None"] = 6] = "None";
  })(LogLevel || (LogLevel = {}));

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  /** A logger that does nothing when log messages are sent to it. */
  class NullLogger {
      constructor() { }
      /** @inheritDoc */
      // eslint-disable-next-line
      log(_logLevel, _message) {
      }
  }
  /** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */
  NullLogger.instance = new NullLogger();

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  // Version token that will be replaced by the prepack command
  /** The version of the SignalR client. */
  const VERSION = "8.0.7";
  /** @private */
  class Arg {
      static isRequired(val, name) {
          if (val === null || val === undefined) {
              throw new Error(`The '${name}' argument is required.`);
          }
      }
      static isNotEmpty(val, name) {
          if (!val || val.match(/^\s*$/)) {
              throw new Error(`The '${name}' argument should not be empty.`);
          }
      }
      static isIn(val, values, name) {
          // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.
          if (!(val in values)) {
              throw new Error(`Unknown ${name} value: ${val}.`);
          }
      }
  }
  /** @private */
  class Platform {
      // react-native has a window but no document so we should check both
      static get isBrowser() {
          return !Platform.isNode && typeof window === "object" && typeof window.document === "object";
      }
      // WebWorkers don't have a window object so the isBrowser check would fail
      static get isWebWorker() {
          return !Platform.isNode && typeof self === "object" && "importScripts" in self;
      }
      // react-native has a window but no document
      static get isReactNative() {
          return !Platform.isNode && typeof window === "object" && typeof window.document === "undefined";
      }
      // Node apps shouldn't have a window object, but WebWorkers don't either
      // so we need to check for both WebWorker and window
      static get isNode() {
          return typeof process !== "undefined" && process.release && process.release.name === "node";
      }
  }
  /** @private */
  function getDataDetail(data, includeContent) {
      let detail = "";
      if (isArrayBuffer(data)) {
          detail = `Binary data of length ${data.byteLength}`;
          if (includeContent) {
              detail += `. Content: '${formatArrayBuffer(data)}'`;
          }
      }
      else if (typeof data === "string") {
          detail = `String data of length ${data.length}`;
          if (includeContent) {
              detail += `. Content: '${data}'`;
          }
      }
      return detail;
  }
  /** @private */
  function formatArrayBuffer(data) {
      const view = new Uint8Array(data);
      // Uint8Array.map only supports returning another Uint8Array?
      let str = "";
      view.forEach((num) => {
          const pad = num < 16 ? "0" : "";
          str += `0x${pad}${num.toString(16)} `;
      });
      // Trim of trailing space.
      return str.substr(0, str.length - 1);
  }
  // Also in signalr-protocol-msgpack/Utils.ts
  /** @private */
  function isArrayBuffer(val) {
      return val && typeof ArrayBuffer !== "undefined" &&
          (val instanceof ArrayBuffer ||
              // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof
              (val.constructor && val.constructor.name === "ArrayBuffer"));
  }
  /** @private */
  async function sendMessage(logger, transportName, httpClient, url, content, options) {
      const headers = {};
      const [name, value] = getUserAgentHeader();
      headers[name] = value;
      logger.log(LogLevel.Trace, `(${transportName} transport) sending data. ${getDataDetail(content, options.logMessageContent)}.`);
      const responseType = isArrayBuffer(content) ? "arraybuffer" : "text";
      const response = await httpClient.post(url, {
          content,
          headers: { ...headers, ...options.headers },
          responseType,
          timeout: options.timeout,
          withCredentials: options.withCredentials,
      });
      logger.log(LogLevel.Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);
  }
  /** @private */
  function createLogger(logger) {
      if (logger === undefined) {
          return new ConsoleLogger(LogLevel.Information);
      }
      if (logger === null) {
          return NullLogger.instance;
      }
      if (logger.log !== undefined) {
          return logger;
      }
      return new ConsoleLogger(logger);
  }
  /** @private */
  class SubjectSubscription {
      constructor(subject, observer) {
          this._subject = subject;
          this._observer = observer;
      }
      dispose() {
          const index = this._subject.observers.indexOf(this._observer);
          if (index > -1) {
              this._subject.observers.splice(index, 1);
          }
          if (this._subject.observers.length === 0 && this._subject.cancelCallback) {
              this._subject.cancelCallback().catch((_) => { });
          }
      }
  }
  /** @private */
  class ConsoleLogger {
      constructor(minimumLogLevel) {
          this._minLevel = minimumLogLevel;
          this.out = console;
      }
      log(logLevel, message) {
          if (logLevel >= this._minLevel) {
              const msg = `[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`;
              switch (logLevel) {
                  case LogLevel.Critical:
                  case LogLevel.Error:
                      this.out.error(msg);
                      break;
                  case LogLevel.Warning:
                      this.out.warn(msg);
                      break;
                  case LogLevel.Information:
                      this.out.info(msg);
                      break;
                  default:
                      // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug
                      this.out.log(msg);
                      break;
              }
          }
      }
  }
  /** @private */
  function getUserAgentHeader() {
      let userAgentHeaderName = "X-SignalR-User-Agent";
      if (Platform.isNode) {
          userAgentHeaderName = "User-Agent";
      }
      return [userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion())];
  }
  /** @private */
  function constructUserAgent(version, os, runtime, runtimeVersion) {
      // Microsoft SignalR/[Version] ([Detailed Version]; [Operating System]; [Runtime]; [Runtime Version])
      let userAgent = "Microsoft SignalR/";
      const majorAndMinor = version.split(".");
      userAgent += `${majorAndMinor[0]}.${majorAndMinor[1]}`;
      userAgent += ` (${version}; `;
      if (os && os !== "") {
          userAgent += `${os}; `;
      }
      else {
          userAgent += "Unknown OS; ";
      }
      userAgent += `${runtime}`;
      if (runtimeVersion) {
          userAgent += `; ${runtimeVersion}`;
      }
      else {
          userAgent += "; Unknown Runtime Version";
      }
      userAgent += ")";
      return userAgent;
  }
  // eslint-disable-next-line spaced-comment
   function getOsName() {
      if (Platform.isNode) {
          switch (process.platform) {
              case "win32":
                  return "Windows NT";
              case "darwin":
                  return "macOS";
              case "linux":
                  return "Linux";
              default:
                  return process.platform;
          }
      }
      else {
          return "";
      }
  }
  // eslint-disable-next-line spaced-comment
   function getRuntimeVersion() {
      if (Platform.isNode) {
          return process.versions.node;
      }
      return undefined;
  }
  function getRuntime() {
      if (Platform.isNode) {
          return "NodeJS";
      }
      else {
          return "Browser";
      }
  }
  /** @private */
  function getErrorString(e) {
      if (e.stack) {
          return e.stack;
      }
      else if (e.message) {
          return e.message;
      }
      return `${e}`;
  }
  /** @private */
  function getGlobalThis() {
      // globalThis is semi-new and not available in Node until v12
      if (typeof globalThis !== "undefined") {
          return globalThis;
      }
      if (typeof self !== "undefined") {
          return self;
      }
      if (typeof window !== "undefined") {
          return window;
      }
      if (typeof global !== "undefined") {
          return global;
      }
      throw new Error("could not find global");
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  class FetchHttpClient extends HttpClient {
      constructor(logger) {
          super();
          this._logger = logger;
          // Node added a fetch implementation to the global scope starting in v18.
          // We need to add a cookie jar in node to be able to share cookies with WebSocket
          if (typeof fetch === "undefined" || Platform.isNode) {
              // In order to ignore the dynamic require in webpack builds we need to do this magic
              // @ts-ignore: TS doesn't know about these names
              const requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
              // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests
              this._jar = new (requireFunc("tough-cookie")).CookieJar();
              if (typeof fetch === "undefined") {
                  this._fetchType = requireFunc("node-fetch");
              }
              else {
                  // Use fetch from Node if available
                  this._fetchType = fetch;
              }
              // node-fetch doesn't have a nice API for getting and setting cookies
              // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one
              this._fetchType = requireFunc("fetch-cookie")(this._fetchType, this._jar);
          }
          else {
              this._fetchType = fetch.bind(getGlobalThis());
          }
          if (typeof AbortController === "undefined") {
              // In order to ignore the dynamic require in webpack builds we need to do this magic
              // @ts-ignore: TS doesn't know about these names
              const requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
              // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide
              this._abortControllerType = requireFunc("abort-controller");
          }
          else {
              this._abortControllerType = AbortController;
          }
      }
      /** @inheritDoc */
      async send(request) {
          // Check that abort was not signaled before calling send
          if (request.abortSignal && request.abortSignal.aborted) {
              throw new AbortError();
          }
          if (!request.method) {
              throw new Error("No method defined.");
          }
          if (!request.url) {
              throw new Error("No url defined.");
          }
          const abortController = new this._abortControllerType();
          let error;
          // Hook our abortSignal into the abort controller
          if (request.abortSignal) {
              request.abortSignal.onabort = () => {
                  abortController.abort();
                  error = new AbortError();
              };
          }
          // If a timeout has been passed in, setup a timeout to call abort
          // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout
          let timeoutId = null;
          if (request.timeout) {
              const msTimeout = request.timeout;
              timeoutId = setTimeout(() => {
                  abortController.abort();
                  this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);
                  error = new TimeoutError();
              }, msTimeout);
          }
          if (request.content === "") {
              request.content = undefined;
          }
          if (request.content) {
              // Explicitly setting the Content-Type header for React Native on Android platform.
              request.headers = request.headers || {};
              if (isArrayBuffer(request.content)) {
                  request.headers["Content-Type"] = "application/octet-stream";
              }
              else {
                  request.headers["Content-Type"] = "text/plain;charset=UTF-8";
              }
          }
          let response;
          try {
              response = await this._fetchType(request.url, {
                  body: request.content,
                  cache: "no-cache",
                  credentials: request.withCredentials === true ? "include" : "same-origin",
                  headers: {
                      "X-Requested-With": "XMLHttpRequest",
                      ...request.headers,
                  },
                  method: request.method,
                  mode: "cors",
                  redirect: "follow",
                  signal: abortController.signal,
              });
          }
          catch (e) {
              if (error) {
                  throw error;
              }
              this._logger.log(LogLevel.Warning, `Error from HTTP request. ${e}.`);
              throw e;
          }
          finally {
              if (timeoutId) {
                  clearTimeout(timeoutId);
              }
              if (request.abortSignal) {
                  request.abortSignal.onabort = null;
              }
          }
          if (!response.ok) {
              const errorMessage = await deserializeContent(response, "text");
              throw new HttpError(errorMessage || response.statusText, response.status);
          }
          const content = deserializeContent(response, request.responseType);
          const payload = await content;
          return new HttpResponse(response.status, response.statusText, payload);
      }
      getCookieString(url) {
          let cookies = "";
          if (Platform.isNode && this._jar) {
              // @ts-ignore: unused variable
              this._jar.getCookies(url, (e, c) => cookies = c.join("; "));
          }
          return cookies;
      }
  }
  function deserializeContent(response, responseType) {
      let content;
      switch (responseType) {
          case "arraybuffer":
              content = response.arrayBuffer();
              break;
          case "text":
              content = response.text();
              break;
          case "blob":
          case "document":
          case "json":
              throw new Error(`${responseType} is not supported.`);
          default:
              content = response.text();
              break;
      }
      return content;
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  class XhrHttpClient extends HttpClient {
      constructor(logger) {
          super();
          this._logger = logger;
      }
      /** @inheritDoc */
      send(request) {
          // Check that abort was not signaled before calling send
          if (request.abortSignal && request.abortSignal.aborted) {
              return Promise.reject(new AbortError());
          }
          if (!request.method) {
              return Promise.reject(new Error("No method defined."));
          }
          if (!request.url) {
              return Promise.reject(new Error("No url defined."));
          }
          return new Promise((resolve, reject) => {
              const xhr = new XMLHttpRequest();
              xhr.open(request.method, request.url, true);
              xhr.withCredentials = request.withCredentials === undefined ? true : request.withCredentials;
              xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
              if (request.content === "") {
                  request.content = undefined;
              }
              if (request.content) {
                  // Explicitly setting the Content-Type header for React Native on Android platform.
                  if (isArrayBuffer(request.content)) {
                      xhr.setRequestHeader("Content-Type", "application/octet-stream");
                  }
                  else {
                      xhr.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
                  }
              }
              const headers = request.headers;
              if (headers) {
                  Object.keys(headers)
                      .forEach((header) => {
                      xhr.setRequestHeader(header, headers[header]);
                  });
              }
              if (request.responseType) {
                  xhr.responseType = request.responseType;
              }
              if (request.abortSignal) {
                  request.abortSignal.onabort = () => {
                      xhr.abort();
                      reject(new AbortError());
                  };
              }
              if (request.timeout) {
                  xhr.timeout = request.timeout;
              }
              xhr.onload = () => {
                  if (request.abortSignal) {
                      request.abortSignal.onabort = null;
                  }
                  if (xhr.status >= 200 && xhr.status < 300) {
                      resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));
                  }
                  else {
                      reject(new HttpError(xhr.response || xhr.responseText || xhr.statusText, xhr.status));
                  }
              };
              xhr.onerror = () => {
                  this._logger.log(LogLevel.Warning, `Error from HTTP request. ${xhr.status}: ${xhr.statusText}.`);
                  reject(new HttpError(xhr.statusText, xhr.status));
              };
              xhr.ontimeout = () => {
                  this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);
                  reject(new TimeoutError());
              };
              xhr.send(request.content);
          });
      }
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  /** Default implementation of {@link @microsoft/signalr.HttpClient}. */
  class DefaultHttpClient extends HttpClient {
      /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */
      constructor(logger) {
          super();
          if (typeof fetch !== "undefined" || Platform.isNode) {
              this._httpClient = new FetchHttpClient(logger);
          }
          else if (typeof XMLHttpRequest !== "undefined") {
              this._httpClient = new XhrHttpClient(logger);
          }
          else {
              throw new Error("No usable HttpClient found.");
          }
      }
      /** @inheritDoc */
      send(request) {
          // Check that abort was not signaled before calling send
          if (request.abortSignal && request.abortSignal.aborted) {
              return Promise.reject(new AbortError());
          }
          if (!request.method) {
              return Promise.reject(new Error("No method defined."));
          }
          if (!request.url) {
              return Promise.reject(new Error("No url defined."));
          }
          return this._httpClient.send(request);
      }
      getCookieString(url) {
          return this._httpClient.getCookieString(url);
      }
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  // Not exported from index
  /** @private */
  class TextMessageFormat {
      static write(output) {
          return `${output}${TextMessageFormat.RecordSeparator}`;
      }
      static parse(input) {
          if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {
              throw new Error("Message is incomplete.");
          }
          const messages = input.split(TextMessageFormat.RecordSeparator);
          messages.pop();
          return messages;
      }
  }
  TextMessageFormat.RecordSeparatorCode = 0x1e;
  TextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  /** @private */
  class HandshakeProtocol {
      // Handshake request is always JSON
      writeHandshakeRequest(handshakeRequest) {
          return TextMessageFormat.write(JSON.stringify(handshakeRequest));
      }
      parseHandshakeResponse(data) {
          let messageData;
          let remainingData;
          if (isArrayBuffer(data)) {
              // Format is binary but still need to read JSON text from handshake response
              const binaryData = new Uint8Array(data);
              const separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);
              if (separatorIndex === -1) {
                  throw new Error("Message is incomplete.");
              }
              // content before separator is handshake response
              // optional content after is additional messages
              const responseLength = separatorIndex + 1;
              messageData = String.fromCharCode.apply(null, Array.prototype.slice.call(binaryData.slice(0, responseLength)));
              remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;
          }
          else {
              const textData = data;
              const separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);
              if (separatorIndex === -1) {
                  throw new Error("Message is incomplete.");
              }
              // content before separator is handshake response
              // optional content after is additional messages
              const responseLength = separatorIndex + 1;
              messageData = textData.substring(0, responseLength);
              remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;
          }
          // At this point we should have just the single handshake message
          const messages = TextMessageFormat.parse(messageData);
          const response = JSON.parse(messages[0]);
          if (response.type) {
              throw new Error("Expected a handshake response from the server.");
          }
          const responseMessage = response;
          // multiple messages could have arrived with handshake
          // return additional data to be parsed as usual, or null if all parsed
          return [remainingData, responseMessage];
      }
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  /** Defines the type of a Hub Message. */
  var MessageType;
  (function (MessageType) {
      /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */
      MessageType[MessageType["Invocation"] = 1] = "Invocation";
      /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */
      MessageType[MessageType["StreamItem"] = 2] = "StreamItem";
      /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */
      MessageType[MessageType["Completion"] = 3] = "Completion";
      /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */
      MessageType[MessageType["StreamInvocation"] = 4] = "StreamInvocation";
      /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */
      MessageType[MessageType["CancelInvocation"] = 5] = "CancelInvocation";
      /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */
      MessageType[MessageType["Ping"] = 6] = "Ping";
      /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */
      MessageType[MessageType["Close"] = 7] = "Close";
      MessageType[MessageType["Ack"] = 8] = "Ack";
      MessageType[MessageType["Sequence"] = 9] = "Sequence";
  })(MessageType || (MessageType = {}));

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  /** Stream implementation to stream items to the server. */
  class Subject {
      constructor() {
          this.observers = [];
      }
      next(item) {
          for (const observer of this.observers) {
              observer.next(item);
          }
      }
      error(err) {
          for (const observer of this.observers) {
              if (observer.error) {
                  observer.error(err);
              }
          }
      }
      complete() {
          for (const observer of this.observers) {
              if (observer.complete) {
                  observer.complete();
              }
          }
      }
      subscribe(observer) {
          this.observers.push(observer);
          return new SubjectSubscription(this, observer);
      }
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  /** @private */
  class MessageBuffer {
      constructor(protocol, connection, bufferSize) {
          this._bufferSize = 100000;
          this._messages = [];
          this._totalMessageCount = 0;
          this._waitForSequenceMessage = false;
          // Message IDs start at 1 and always increment by 1
          this._nextReceivingSequenceId = 1;
          this._latestReceivedSequenceId = 0;
          this._bufferedByteCount = 0;
          this._reconnectInProgress = false;
          this._protocol = protocol;
          this._connection = connection;
          this._bufferSize = bufferSize;
      }
      async _send(message) {
          const serializedMessage = this._protocol.writeMessage(message);
          let backpressurePromise = Promise.resolve();
          // Only count invocation messages. Acks, pings, etc. don't need to be resent on reconnect
          if (this._isInvocationMessage(message)) {
              this._totalMessageCount++;
              let backpressurePromiseResolver = () => { };
              let backpressurePromiseRejector = () => { };
              if (isArrayBuffer(serializedMessage)) {
                  this._bufferedByteCount += serializedMessage.byteLength;
              }
              else {
                  this._bufferedByteCount += serializedMessage.length;
              }
              if (this._bufferedByteCount >= this._bufferSize) {
                  backpressurePromise = new Promise((resolve, reject) => {
                      backpressurePromiseResolver = resolve;
                      backpressurePromiseRejector = reject;
                  });
              }
              this._messages.push(new BufferedItem(serializedMessage, this._totalMessageCount, backpressurePromiseResolver, backpressurePromiseRejector));
          }
          try {
              // If this is set it means we are reconnecting or resending
              // We don't want to send on a disconnected connection
              // And we don't want to send if resend is running since that would mean sending
              // this message twice
              if (!this._reconnectInProgress) {
                  await this._connection.send(serializedMessage);
              }
          }
          catch {
              this._disconnected();
          }
          await backpressurePromise;
      }
      _ack(ackMessage) {
          let newestAckedMessage = -1;
          // Find index of newest message being acked
          for (let index = 0; index < this._messages.length; index++) {
              const element = this._messages[index];
              if (element._id <= ackMessage.sequenceId) {
                  newestAckedMessage = index;
                  if (isArrayBuffer(element._message)) {
                      this._bufferedByteCount -= element._message.byteLength;
                  }
                  else {
                      this._bufferedByteCount -= element._message.length;
                  }
                  // resolve items that have already been sent and acked
                  element._resolver();
              }
              else if (this._bufferedByteCount < this._bufferSize) {
                  // resolve items that now fall under the buffer limit but haven't been acked
                  element._resolver();
              }
              else {
                  break;
              }
          }
          if (newestAckedMessage !== -1) {
              // We're removing everything including the message pointed to, so add 1
              this._messages = this._messages.slice(newestAckedMessage + 1);
          }
      }
      _shouldProcessMessage(message) {
          if (this._waitForSequenceMessage) {
              if (message.type !== MessageType.Sequence) {
                  return false;
              }
              else {
                  this._waitForSequenceMessage = false;
                  return true;
              }
          }
          // No special processing for acks, pings, etc.
          if (!this._isInvocationMessage(message)) {
              return true;
          }
          const currentId = this._nextReceivingSequenceId;
          this._nextReceivingSequenceId++;
          if (currentId <= this._latestReceivedSequenceId) {
              if (currentId === this._latestReceivedSequenceId) {
                  // Should only hit this if we just reconnected and the server is sending
                  // Messages it has buffered, which would mean it hasn't seen an Ack for these messages
                  this._ackTimer();
              }
              // Ignore, this is a duplicate message
              return false;
          }
          this._latestReceivedSequenceId = currentId;
          // Only start the timer for sending an Ack message when we have a message to ack. This also conveniently solves
          // timer throttling by not having a recursive timer, and by starting the timer via a network call (recv)
          this._ackTimer();
          return true;
      }
      _resetSequence(message) {
          if (message.sequenceId > this._nextReceivingSequenceId) {
              // eslint-disable-next-line @typescript-eslint/no-floating-promises
              this._connection.stop(new Error("Sequence ID greater than amount of messages we've received."));
              return;
          }
          this._nextReceivingSequenceId = message.sequenceId;
      }
      _disconnected() {
          this._reconnectInProgress = true;
          this._waitForSequenceMessage = true;
      }
      async _resend() {
          const sequenceId = this._messages.length !== 0
              ? this._messages[0]._id
              : this._totalMessageCount + 1;
          await this._connection.send(this._protocol.writeMessage({ type: MessageType.Sequence, sequenceId }));
          // Get a local variable to the _messages, just in case messages are acked while resending
          // Which would slice the _messages array (which creates a new copy)
          const messages = this._messages;
          for (const element of messages) {
              await this._connection.send(element._message);
          }
          this._reconnectInProgress = false;
      }
      _dispose(error) {
          error !== null && error !== void 0 ? error : (error = new Error("Unable to reconnect to server."));
          // Unblock backpressure if any
          for (const element of this._messages) {
              element._rejector(error);
          }
      }
      _isInvocationMessage(message) {
          // There is no way to check if something implements an interface.
          // So we individually check the messages in a switch statement.
          // To make sure we don't miss any message types we rely on the compiler
          // seeing the function returns a value and it will do the
          // exhaustive check for us on the switch statement, since we don't use 'case default'
          switch (message.type) {
              case MessageType.Invocation:
              case MessageType.StreamItem:
              case MessageType.Completion:
              case MessageType.StreamInvocation:
              case MessageType.CancelInvocation:
                  return true;
              case MessageType.Close:
              case MessageType.Sequence:
              case MessageType.Ping:
              case MessageType.Ack:
                  return false;
          }
      }
      _ackTimer() {
          if (this._ackTimerHandle === undefined) {
              this._ackTimerHandle = setTimeout(async () => {
                  try {
                      if (!this._reconnectInProgress) {
                          await this._connection.send(this._protocol.writeMessage({ type: MessageType.Ack, sequenceId: this._latestReceivedSequenceId }));
                      }
                      // Ignore errors, that means the connection is closed and we don't care about the Ack message anymore.
                  }
                  catch { }
                  clearTimeout(this._ackTimerHandle);
                  this._ackTimerHandle = undefined;
                  // 1 second delay so we don't spam Ack messages if there are many messages being received at once.
              }, 1000);
          }
      }
  }
  class BufferedItem {
      constructor(message, id, resolver, rejector) {
          this._message = message;
          this._id = id;
          this._resolver = resolver;
          this._rejector = rejector;
      }
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  const DEFAULT_TIMEOUT_IN_MS = 30 * 1000;
  const DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;
  const DEFAULT_STATEFUL_RECONNECT_BUFFER_SIZE = 100000;
  /** Describes the current state of the {@link HubConnection} to the server. */
  var HubConnectionState;
  (function (HubConnectionState) {
      /** The hub connection is disconnected. */
      HubConnectionState["Disconnected"] = "Disconnected";
      /** The hub connection is connecting. */
      HubConnectionState["Connecting"] = "Connecting";
      /** The hub connection is connected. */
      HubConnectionState["Connected"] = "Connected";
      /** The hub connection is disconnecting. */
      HubConnectionState["Disconnecting"] = "Disconnecting";
      /** The hub connection is reconnecting. */
      HubConnectionState["Reconnecting"] = "Reconnecting";
  })(HubConnectionState || (HubConnectionState = {}));
  /** Represents a connection to a SignalR Hub. */
  class HubConnection {
      /** @internal */
      // Using a public static factory method means we can have a private constructor and an _internal_
      // create method that can be used by HubConnectionBuilder. An "internal" constructor would just
      // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a
      // public parameter-less constructor.
      static create(connection, logger, protocol, reconnectPolicy, serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize) {
          return new HubConnection(connection, logger, protocol, reconnectPolicy, serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize);
      }
      constructor(connection, logger, protocol, reconnectPolicy, serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize) {
          this._nextKeepAlive = 0;
          this._freezeEventListener = () => {
              this._logger.log(LogLevel.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep");
          };
          Arg.isRequired(connection, "connection");
          Arg.isRequired(logger, "logger");
          Arg.isRequired(protocol, "protocol");
          this.serverTimeoutInMilliseconds = serverTimeoutInMilliseconds !== null && serverTimeoutInMilliseconds !== void 0 ? serverTimeoutInMilliseconds : DEFAULT_TIMEOUT_IN_MS;
          this.keepAliveIntervalInMilliseconds = keepAliveIntervalInMilliseconds !== null && keepAliveIntervalInMilliseconds !== void 0 ? keepAliveIntervalInMilliseconds : DEFAULT_PING_INTERVAL_IN_MS;
          this._statefulReconnectBufferSize = statefulReconnectBufferSize !== null && statefulReconnectBufferSize !== void 0 ? statefulReconnectBufferSize : DEFAULT_STATEFUL_RECONNECT_BUFFER_SIZE;
          this._logger = logger;
          this._protocol = protocol;
          this.connection = connection;
          this._reconnectPolicy = reconnectPolicy;
          this._handshakeProtocol = new HandshakeProtocol();
          this.connection.onreceive = (data) => this._processIncomingData(data);
          this.connection.onclose = (error) => this._connectionClosed(error);
          this._callbacks = {};
          this._methods = {};
          this._closedCallbacks = [];
          this._reconnectingCallbacks = [];
          this._reconnectedCallbacks = [];
          this._invocationId = 0;
          this._receivedHandshakeResponse = false;
          this._connectionState = HubConnectionState.Disconnected;
          this._connectionStarted = false;
          this._cachedPingMessage = this._protocol.writeMessage({ type: MessageType.Ping });
      }
      /** Indicates the state of the {@link HubConnection} to the server. */
      get state() {
          return this._connectionState;
      }
      /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either
       *  in the disconnected state or if the negotiation step was skipped.
       */
      get connectionId() {
          return this.connection ? (this.connection.connectionId || null) : null;
      }
      /** Indicates the url of the {@link HubConnection} to the server. */
      get baseUrl() {
          return this.connection.baseUrl || "";
      }
      /**
       * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or
       * Reconnecting states.
       * @param {string} url The url to connect to.
       */
      set baseUrl(url) {
          if (this._connectionState !== HubConnectionState.Disconnected && this._connectionState !== HubConnectionState.Reconnecting) {
              throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
          }
          if (!url) {
              throw new Error("The HubConnection url must be a valid url.");
          }
          this.connection.baseUrl = url;
      }
      /** Starts the connection.
       *
       * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.
       */
      start() {
          this._startPromise = this._startWithStateTransitions();
          return this._startPromise;
      }
      async _startWithStateTransitions() {
          if (this._connectionState !== HubConnectionState.Disconnected) {
              return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));
          }
          this._connectionState = HubConnectionState.Connecting;
          this._logger.log(LogLevel.Debug, "Starting HubConnection.");
          try {
              await this._startInternal();
              if (Platform.isBrowser) {
                  // Log when the browser freezes the tab so users know why their connection unexpectedly stopped working
                  window.document.addEventListener("freeze", this._freezeEventListener);
              }
              this._connectionState = HubConnectionState.Connected;
              this._connectionStarted = true;
              this._logger.log(LogLevel.Debug, "HubConnection connected successfully.");
          }
          catch (e) {
              this._connectionState = HubConnectionState.Disconnected;
              this._logger.log(LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`);
              return Promise.reject(e);
          }
      }
      async _startInternal() {
          this._stopDuringStartError = undefined;
          this._receivedHandshakeResponse = false;
          // Set up the promise before any connection is (re)started otherwise it could race with received messages
          const handshakePromise = new Promise((resolve, reject) => {
              this._handshakeResolver = resolve;
              this._handshakeRejecter = reject;
          });
          await this.connection.start(this._protocol.transferFormat);
          try {
              let version = this._protocol.version;
              if (!this.connection.features.reconnect) {
                  // Stateful Reconnect starts with HubProtocol version 2, newer clients connecting to older servers will fail to connect due to
                  // the handshake only supporting version 1, so we will try to send version 1 during the handshake to keep old servers working.
                  version = 1;
              }
              const handshakeRequest = {
                  protocol: this._protocol.name,
                  version,
              };
              this._logger.log(LogLevel.Debug, "Sending handshake request.");
              await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(handshakeRequest));
              this._logger.log(LogLevel.Information, `Using HubProtocol '${this._protocol.name}'.`);
              // defensively cleanup timeout in case we receive a message from the server before we finish start
              this._cleanupTimeout();
              this._resetTimeoutPeriod();
              this._resetKeepAliveInterval();
              await handshakePromise;
              // It's important to check the stopDuringStartError instead of just relying on the handshakePromise
              // being rejected on close, because this continuation can run after both the handshake completed successfully
              // and the connection was closed.
              if (this._stopDuringStartError) {
                  // It's important to throw instead of returning a rejected promise, because we don't want to allow any state
                  // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise
                  // will cause the calling continuation to get scheduled to run later.
                  // eslint-disable-next-line @typescript-eslint/no-throw-literal
                  throw this._stopDuringStartError;
              }
              const useStatefulReconnect = this.connection.features.reconnect || false;
              if (useStatefulReconnect) {
                  this._messageBuffer = new MessageBuffer(this._protocol, this.connection, this._statefulReconnectBufferSize);
                  this.connection.features.disconnected = this._messageBuffer._disconnected.bind(this._messageBuffer);
                  this.connection.features.resend = () => {
                      if (this._messageBuffer) {
                          return this._messageBuffer._resend();
                      }
                  };
              }
              if (!this.connection.features.inherentKeepAlive) {
                  await this._sendMessage(this._cachedPingMessage);
              }
          }
          catch (e) {
              this._logger.log(LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`);
              this._cleanupTimeout();
              this._cleanupPingTimer();
              // HttpConnection.stop() should not complete until after the onclose callback is invoked.
              // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.
              await this.connection.stop(e);
              throw e;
          }
      }
      /** Stops the connection.
       *
       * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.
       */
      async stop() {
          // Capture the start promise before the connection might be restarted in an onclose callback.
          const startPromise = this._startPromise;
          this.connection.features.reconnect = false;
          this._stopPromise = this._stopInternal();
          await this._stopPromise;
          try {
              // Awaiting undefined continues immediately
              await startPromise;
          }
          catch (e) {
              // This exception is returned to the user as a rejected Promise from the start method.
          }
      }
      _stopInternal(error) {
          if (this._connectionState === HubConnectionState.Disconnected) {
              this._logger.log(LogLevel.Debug, `Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`);
              return Promise.resolve();
          }
          if (this._connectionState === HubConnectionState.Disconnecting) {
              this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);
              return this._stopPromise;
          }
          const state = this._connectionState;
          this._connectionState = HubConnectionState.Disconnecting;
          this._logger.log(LogLevel.Debug, "Stopping HubConnection.");
          if (this._reconnectDelayHandle) {
              // We're in a reconnect delay which means the underlying connection is currently already stopped.
              // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and
              // fire the onclose callbacks.
              this._logger.log(LogLevel.Debug, "Connection stopped during reconnect delay. Done reconnecting.");
              clearTimeout(this._reconnectDelayHandle);
              this._reconnectDelayHandle = undefined;
              this._completeClose();
              return Promise.resolve();
          }
          if (state === HubConnectionState.Connected) {
              // eslint-disable-next-line @typescript-eslint/no-floating-promises
              this._sendCloseMessage();
          }
          this._cleanupTimeout();
          this._cleanupPingTimer();
          this._stopDuringStartError = error || new AbortError("The connection was stopped before the hub handshake could complete.");
          // HttpConnection.stop() should not complete until after either HttpConnection.start() fails
          // or the onclose callback is invoked. The onclose callback will transition the HubConnection
          // to the disconnected state if need be before HttpConnection.stop() completes.
          return this.connection.stop(error);
      }
      async _sendCloseMessage() {
          try {
              await this._sendWithProtocol(this._createCloseMessage());
          }
          catch {
              // Ignore, this is a best effort attempt to let the server know the client closed gracefully.
          }
      }
      /** Invokes a streaming hub method on the server using the specified name and arguments.
       *
       * @typeparam T The type of the items returned by the server.
       * @param {string} methodName The name of the server method to invoke.
       * @param {any[]} args The arguments used to invoke the server method.
       * @returns {IStreamResult<T>} An object that yields results from the server as they are received.
       */
      stream(methodName, ...args) {
          const [streams, streamIds] = this._replaceStreamingParams(args);
          const invocationDescriptor = this._createStreamInvocation(methodName, args, streamIds);
          // eslint-disable-next-line prefer-const
          let promiseQueue;
          const subject = new Subject();
          subject.cancelCallback = () => {
              const cancelInvocation = this._createCancelInvocation(invocationDescriptor.invocationId);
              delete this._callbacks[invocationDescriptor.invocationId];
              return promiseQueue.then(() => {
                  return this._sendWithProtocol(cancelInvocation);
              });
          };
          this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {
              if (error) {
                  subject.error(error);
                  return;
              }
              else if (invocationEvent) {
                  // invocationEvent will not be null when an error is not passed to the callback
                  if (invocationEvent.type === MessageType.Completion) {
                      if (invocationEvent.error) {
                          subject.error(new Error(invocationEvent.error));
                      }
                      else {
                          subject.complete();
                      }
                  }
                  else {
                      subject.next((invocationEvent.item));
                  }
              }
          };
          promiseQueue = this._sendWithProtocol(invocationDescriptor)
              .catch((e) => {
              subject.error(e);
              delete this._callbacks[invocationDescriptor.invocationId];
          });
          this._launchStreams(streams, promiseQueue);
          return subject;
      }
      _sendMessage(message) {
          this._resetKeepAliveInterval();
          return this.connection.send(message);
      }
      /**
       * Sends a js object to the server.
       * @param message The js object to serialize and send.
       */
      _sendWithProtocol(message) {
          if (this._messageBuffer) {
              return this._messageBuffer._send(message);
          }
          else {
              return this._sendMessage(this._protocol.writeMessage(message));
          }
      }
      /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.
       *
       * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still
       * be processing the invocation.
       *
       * @param {string} methodName The name of the server method to invoke.
       * @param {any[]} args The arguments used to invoke the server method.
       * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.
       */
      send(methodName, ...args) {
          const [streams, streamIds] = this._replaceStreamingParams(args);
          const sendPromise = this._sendWithProtocol(this._createInvocation(methodName, args, true, streamIds));
          this._launchStreams(streams, sendPromise);
          return sendPromise;
      }
      /** Invokes a hub method on the server using the specified name and arguments.
       *
       * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise
       * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of
       * resolving the Promise.
       *
       * @typeparam T The expected return type.
       * @param {string} methodName The name of the server method to invoke.
       * @param {any[]} args The arguments used to invoke the server method.
       * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.
       */
      invoke(methodName, ...args) {
          const [streams, streamIds] = this._replaceStreamingParams(args);
          const invocationDescriptor = this._createInvocation(methodName, args, false, streamIds);
          const p = new Promise((resolve, reject) => {
              // invocationId will always have a value for a non-blocking invocation
              this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {
                  if (error) {
                      reject(error);
                      return;
                  }
                  else if (invocationEvent) {
                      // invocationEvent will not be null when an error is not passed to the callback
                      if (invocationEvent.type === MessageType.Completion) {
                          if (invocationEvent.error) {
                              reject(new Error(invocationEvent.error));
                          }
                          else {
                              resolve(invocationEvent.result);
                          }
                      }
                      else {
                          reject(new Error(`Unexpected message type: ${invocationEvent.type}`));
                      }
                  }
              };
              const promiseQueue = this._sendWithProtocol(invocationDescriptor)
                  .catch((e) => {
                  reject(e);
                  // invocationId will always have a value for a non-blocking invocation
                  delete this._callbacks[invocationDescriptor.invocationId];
              });
              this._launchStreams(streams, promiseQueue);
          });
          return p;
      }
      on(methodName, newMethod) {
          if (!methodName || !newMethod) {
              return;
          }
          methodName = methodName.toLowerCase();
          if (!this._methods[methodName]) {
              this._methods[methodName] = [];
          }
          // Preventing adding the same handler multiple times.
          if (this._methods[methodName].indexOf(newMethod) !== -1) {
              return;
          }
          this._methods[methodName].push(newMethod);
      }
      off(methodName, method) {
          if (!methodName) {
              return;
          }
          methodName = methodName.toLowerCase();
          const handlers = this._methods[methodName];
          if (!handlers) {
              return;
          }
          if (method) {
              const removeIdx = handlers.indexOf(method);
              if (removeIdx !== -1) {
                  handlers.splice(removeIdx, 1);
                  if (handlers.length === 0) {
                      delete this._methods[methodName];
                  }
              }
          }
          else {
              delete this._methods[methodName];
          }
      }
      /** Registers a handler that will be invoked when the connection is closed.
       *
       * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).
       */
      onclose(callback) {
          if (callback) {
              this._closedCallbacks.push(callback);
          }
      }
      /** Registers a handler that will be invoked when the connection starts reconnecting.
       *
       * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).
       */
      onreconnecting(callback) {
          if (callback) {
              this._reconnectingCallbacks.push(callback);
          }
      }
      /** Registers a handler that will be invoked when the connection successfully reconnects.
       *
       * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.
       */
      onreconnected(callback) {
          if (callback) {
              this._reconnectedCallbacks.push(callback);
          }
      }
      _processIncomingData(data) {
          this._cleanupTimeout();
          if (!this._receivedHandshakeResponse) {
              data = this._processHandshakeResponse(data);
              this._receivedHandshakeResponse = true;
          }
          // Data may have all been read when processing handshake response
          if (data) {
              // Parse the messages
              const messages = this._protocol.parseMessages(data, this._logger);
              for (const message of messages) {
                  if (this._messageBuffer && !this._messageBuffer._shouldProcessMessage(message)) {
                      // Don't process the message, we are either waiting for a SequenceMessage or received a duplicate message
                      continue;
                  }
                  switch (message.type) {
                      case MessageType.Invocation:
                          this._invokeClientMethod(message)
                              .catch((e) => {
                              this._logger.log(LogLevel.Error, `Invoke client method threw error: ${getErrorString(e)}`);
                          });
                          break;
                      case MessageType.StreamItem:
                      case MessageType.Completion: {
                          const callback = this._callbacks[message.invocationId];
                          if (callback) {
                              if (message.type === MessageType.Completion) {
                                  delete this._callbacks[message.invocationId];
                              }
                              try {
                                  callback(message);
                              }
                              catch (e) {
                                  this._logger.log(LogLevel.Error, `Stream callback threw error: ${getErrorString(e)}`);
                              }
                          }
                          break;
                      }
                      case MessageType.Ping:
                          // Don't care about pings
                          break;
                      case MessageType.Close: {
                          this._logger.log(LogLevel.Information, "Close message received from server.");
                          const error = message.error ? new Error("Server returned an error on close: " + message.error) : undefined;
                          if (message.allowReconnect === true) {
                              // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,
                              // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.
                              // eslint-disable-next-line @typescript-eslint/no-floating-promises
                              this.connection.stop(error);
                          }
                          else {
                              // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.
                              this._stopPromise = this._stopInternal(error);
                          }
                          break;
                      }
                      case MessageType.Ack:
                          if (this._messageBuffer) {
                              this._messageBuffer._ack(message);
                          }
                          break;
                      case MessageType.Sequence:
                          if (this._messageBuffer) {
                              this._messageBuffer._resetSequence(message);
                          }
                          break;
                      default:
                          this._logger.log(LogLevel.Warning, `Invalid message type: ${message.type}.`);
                          break;
                  }
              }
          }
          this._resetTimeoutPeriod();
      }
      _processHandshakeResponse(data) {
          let responseMessage;
          let remainingData;
          try {
              [remainingData, responseMessage] = this._handshakeProtocol.parseHandshakeResponse(data);
          }
          catch (e) {
              const message = "Error parsing handshake response: " + e;
              this._logger.log(LogLevel.Error, message);
              const error = new Error(message);
              this._handshakeRejecter(error);
              throw error;
          }
          if (responseMessage.error) {
              const message = "Server returned handshake error: " + responseMessage.error;
              this._logger.log(LogLevel.Error, message);
              const error = new Error(message);
              this._handshakeRejecter(error);
              throw error;
          }
          else {
              this._logger.log(LogLevel.Debug, "Server handshake complete.");
          }
          this._handshakeResolver();
          return remainingData;
      }
      _resetKeepAliveInterval() {
          if (this.connection.features.inherentKeepAlive) {
              return;
          }
          // Set the time we want the next keep alive to be sent
          // Timer will be setup on next message receive
          this._nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;
          this._cleanupPingTimer();
      }
      _resetTimeoutPeriod() {
          if (!this.connection.features || !this.connection.features.inherentKeepAlive) {
              // Set the timeout timer
              this._timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);
              // Set keepAlive timer if there isn't one
              if (this._pingServerHandle === undefined) {
                  let nextPing = this._nextKeepAlive - new Date().getTime();
                  if (nextPing < 0) {
                      nextPing = 0;
                  }
                  // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute
                  this._pingServerHandle = setTimeout(async () => {
                      if (this._connectionState === HubConnectionState.Connected) {
                          try {
                              await this._sendMessage(this._cachedPingMessage);
                          }
                          catch {
                              // We don't care about the error. It should be seen elsewhere in the client.
                              // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering
                              this._cleanupPingTimer();
                          }
                      }
                  }, nextPing);
              }
          }
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      serverTimeout() {
          // The server hasn't talked to us in a while. It doesn't like us anymore ... :(
          // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.
          // eslint-disable-next-line @typescript-eslint/no-floating-promises
          this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
      }
      async _invokeClientMethod(invocationMessage) {
          const methodName = invocationMessage.target.toLowerCase();
          const methods = this._methods[methodName];
          if (!methods) {
              this._logger.log(LogLevel.Warning, `No client method with the name '${methodName}' found.`);
              // No handlers provided by client but the server is expecting a response still, so we send an error
              if (invocationMessage.invocationId) {
                  this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);
                  await this._sendWithProtocol(this._createCompletionMessage(invocationMessage.invocationId, "Client didn't provide a result.", null));
              }
              return;
          }
          // Avoid issues with handlers removing themselves thus modifying the list while iterating through it
          const methodsCopy = methods.slice();
          // Server expects a response
          const expectsResponse = invocationMessage.invocationId ? true : false;
          // We preserve the last result or exception but still call all handlers
          let res;
          let exception;
          let completionMessage;
          for (const m of methodsCopy) {
              try {
                  const prevRes = res;
                  res = await m.apply(this, invocationMessage.arguments);
                  if (expectsResponse && res && prevRes) {
                      this._logger.log(LogLevel.Error, `Multiple results provided for '${methodName}'. Sending error to server.`);
                      completionMessage = this._createCompletionMessage(invocationMessage.invocationId, `Client provided multiple results.`, null);
                  }
                  // Ignore exception if we got a result after, the exception will be logged
                  exception = undefined;
              }
              catch (e) {
                  exception = e;
                  this._logger.log(LogLevel.Error, `A callback for the method '${methodName}' threw error '${e}'.`);
              }
          }
          if (completionMessage) {
              await this._sendWithProtocol(completionMessage);
          }
          else if (expectsResponse) {
              // If there is an exception that means either no result was given or a handler after a result threw
              if (exception) {
                  completionMessage = this._createCompletionMessage(invocationMessage.invocationId, `${exception}`, null);
              }
              else if (res !== undefined) {
                  completionMessage = this._createCompletionMessage(invocationMessage.invocationId, null, res);
              }
              else {
                  this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);
                  // Client didn't provide a result or throw from a handler, server expects a response so we send an error
                  completionMessage = this._createCompletionMessage(invocationMessage.invocationId, "Client didn't provide a result.", null);
              }
              await this._sendWithProtocol(completionMessage);
          }
          else {
              if (res) {
                  this._logger.log(LogLevel.Error, `Result given for '${methodName}' method but server is not expecting a result.`);
              }
          }
      }
      _connectionClosed(error) {
          this._logger.log(LogLevel.Debug, `HubConnection.connectionClosed(${error}) called while in state ${this._connectionState}.`);
          // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.
          this._stopDuringStartError = this._stopDuringStartError || error || new AbortError("The underlying connection was closed before the hub handshake could complete.");
          // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.
          // If it has already completed, this should just noop.
          if (this._handshakeResolver) {
              this._handshakeResolver();
          }
          this._cancelCallbacksWithError(error || new Error("Invocation canceled due to the underlying connection being closed."));
          this._cleanupTimeout();
          this._cleanupPingTimer();
          if (this._connectionState === HubConnectionState.Disconnecting) {
              this._completeClose(error);
          }
          else if (this._connectionState === HubConnectionState.Connected && this._reconnectPolicy) {
              // eslint-disable-next-line @typescript-eslint/no-floating-promises
              this._reconnect(error);
          }
          else if (this._connectionState === HubConnectionState.Connected) {
              this._completeClose(error);
          }
          // If none of the above if conditions were true were called the HubConnection must be in either:
          // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.
          // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt
          //    and potentially continue the reconnect() loop.
          // 3. The Disconnected state in which case we're already done.
      }
      _completeClose(error) {
          if (this._connectionStarted) {
              this._connectionState = HubConnectionState.Disconnected;
              this._connectionStarted = false;
              if (this._messageBuffer) {
                  this._messageBuffer._dispose(error !== null && error !== void 0 ? error : new Error("Connection closed."));
                  this._messageBuffer = undefined;
              }
              if (Platform.isBrowser) {
                  window.document.removeEventListener("freeze", this._freezeEventListener);
              }
              try {
                  this._closedCallbacks.forEach((c) => c.apply(this, [error]));
              }
              catch (e) {
                  this._logger.log(LogLevel.Error, `An onclose callback called with error '${error}' threw error '${e}'.`);
              }
          }
      }
      async _reconnect(error) {
          const reconnectStartTime = Date.now();
          let previousReconnectAttempts = 0;
          let retryError = error !== undefined ? error : new Error("Attempting to reconnect due to a unknown error.");
          let nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, 0, retryError);
          if (nextRetryDelay === null) {
              this._logger.log(LogLevel.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.");
              this._completeClose(error);
              return;
          }
          this._connectionState = HubConnectionState.Reconnecting;
          if (error) {
              this._logger.log(LogLevel.Information, `Connection reconnecting because of error '${error}'.`);
          }
          else {
              this._logger.log(LogLevel.Information, "Connection reconnecting.");
          }
          if (this._reconnectingCallbacks.length !== 0) {
              try {
                  this._reconnectingCallbacks.forEach((c) => c.apply(this, [error]));
              }
              catch (e) {
                  this._logger.log(LogLevel.Error, `An onreconnecting callback called with error '${error}' threw error '${e}'.`);
              }
              // Exit early if an onreconnecting callback called connection.stop().
              if (this._connectionState !== HubConnectionState.Reconnecting) {
                  this._logger.log(LogLevel.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");
                  return;
              }
          }
          while (nextRetryDelay !== null) {
              this._logger.log(LogLevel.Information, `Reconnect attempt number ${previousReconnectAttempts} will start in ${nextRetryDelay} ms.`);
              await new Promise((resolve) => {
                  this._reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);
              });
              this._reconnectDelayHandle = undefined;
              if (this._connectionState !== HubConnectionState.Reconnecting) {
                  this._logger.log(LogLevel.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
                  return;
              }
              try {
                  await this._startInternal();
                  this._connectionState = HubConnectionState.Connected;
                  this._logger.log(LogLevel.Information, "HubConnection reconnected successfully.");
                  if (this._reconnectedCallbacks.length !== 0) {
                      try {
                          this._reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));
                      }
                      catch (e) {
                          this._logger.log(LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`);
                      }
                  }
                  return;
              }
              catch (e) {
                  this._logger.log(LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`);
                  if (this._connectionState !== HubConnectionState.Reconnecting) {
                      this._logger.log(LogLevel.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`);
                      // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.
                      if (this._connectionState === HubConnectionState.Disconnecting) {
                          this._completeClose();
                      }
                      return;
                  }
                  retryError = e instanceof Error ? e : new Error(e.toString());
                  nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);
              }
          }
          this._logger.log(LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`);
          this._completeClose();
      }
      _getNextRetryDelay(previousRetryCount, elapsedMilliseconds, retryReason) {
          try {
              return this._reconnectPolicy.nextRetryDelayInMilliseconds({
                  elapsedMilliseconds,
                  previousRetryCount,
                  retryReason,
              });
          }
          catch (e) {
              this._logger.log(LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`);
              return null;
          }
      }
      _cancelCallbacksWithError(error) {
          const callbacks = this._callbacks;
          this._callbacks = {};
          Object.keys(callbacks)
              .forEach((key) => {
              const callback = callbacks[key];
              try {
                  callback(null, error);
              }
              catch (e) {
                  this._logger.log(LogLevel.Error, `Stream 'error' callback called with '${error}' threw error: ${getErrorString(e)}`);
              }
          });
      }
      _cleanupPingTimer() {
          if (this._pingServerHandle) {
              clearTimeout(this._pingServerHandle);
              this._pingServerHandle = undefined;
          }
      }
      _cleanupTimeout() {
          if (this._timeoutHandle) {
              clearTimeout(this._timeoutHandle);
          }
      }
      _createInvocation(methodName, args, nonblocking, streamIds) {
          if (nonblocking) {
              if (streamIds.length !== 0) {
                  return {
                      arguments: args,
                      streamIds,
                      target: methodName,
                      type: MessageType.Invocation,
                  };
              }
              else {
                  return {
                      arguments: args,
                      target: methodName,
                      type: MessageType.Invocation,
                  };
              }
          }
          else {
              const invocationId = this._invocationId;
              this._invocationId++;
              if (streamIds.length !== 0) {
                  return {
                      arguments: args,
                      invocationId: invocationId.toString(),
                      streamIds,
                      target: methodName,
                      type: MessageType.Invocation,
                  };
              }
              else {
                  return {
                      arguments: args,
                      invocationId: invocationId.toString(),
                      target: methodName,
                      type: MessageType.Invocation,
                  };
              }
          }
      }
      _launchStreams(streams, promiseQueue) {
          if (streams.length === 0) {
              return;
          }
          // Synchronize stream data so they arrive in-order on the server
          if (!promiseQueue) {
              promiseQueue = Promise.resolve();
          }
          // We want to iterate over the keys, since the keys are the stream ids
          // eslint-disable-next-line guard-for-in
          for (const streamId in streams) {
              streams[streamId].subscribe({
                  complete: () => {
                      promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId)));
                  },
                  error: (err) => {
                      let message;
                      if (err instanceof Error) {
                          message = err.message;
                      }
                      else if (err && err.toString) {
                          message = err.toString();
                      }
                      else {
                          message = "Unknown error";
                      }
                      promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId, message)));
                  },
                  next: (item) => {
                      promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createStreamItemMessage(streamId, item)));
                  },
              });
          }
      }
      _replaceStreamingParams(args) {
          const streams = [];
          const streamIds = [];
          for (let i = 0; i < args.length; i++) {
              const argument = args[i];
              if (this._isObservable(argument)) {
                  const streamId = this._invocationId;
                  this._invocationId++;
                  // Store the stream for later use
                  streams[streamId] = argument;
                  streamIds.push(streamId.toString());
                  // remove stream from args
                  args.splice(i, 1);
              }
          }
          return [streams, streamIds];
      }
      _isObservable(arg) {
          // This allows other stream implementations to just work (like rxjs)
          return arg && arg.subscribe && typeof arg.subscribe === "function";
      }
      _createStreamInvocation(methodName, args, streamIds) {
          const invocationId = this._invocationId;
          this._invocationId++;
          if (streamIds.length !== 0) {
              return {
                  arguments: args,
                  invocationId: invocationId.toString(),
                  streamIds,
                  target: methodName,
                  type: MessageType.StreamInvocation,
              };
          }
          else {
              return {
                  arguments: args,
                  invocationId: invocationId.toString(),
                  target: methodName,
                  type: MessageType.StreamInvocation,
              };
          }
      }
      _createCancelInvocation(id) {
          return {
              invocationId: id,
              type: MessageType.CancelInvocation,
          };
      }
      _createStreamItemMessage(id, item) {
          return {
              invocationId: id,
              item,
              type: MessageType.StreamItem,
          };
      }
      _createCompletionMessage(id, error, result) {
          if (error) {
              return {
                  error,
                  invocationId: id,
                  type: MessageType.Completion,
              };
          }
          return {
              invocationId: id,
              result,
              type: MessageType.Completion,
          };
      }
      _createCloseMessage() {
          return { type: MessageType.Close };
      }
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  // 0, 2, 10, 30 second delays before reconnect attempts.
  const DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];
  /** @private */
  class DefaultReconnectPolicy {
      constructor(retryDelays) {
          this._retryDelays = retryDelays !== undefined ? [...retryDelays, null] : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;
      }
      nextRetryDelayInMilliseconds(retryContext) {
          return this._retryDelays[retryContext.previousRetryCount];
      }
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  class HeaderNames {
  }
  HeaderNames.Authorization = "Authorization";
  HeaderNames.Cookie = "Cookie";

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  /** @private */
  class AccessTokenHttpClient extends HttpClient {
      constructor(innerClient, accessTokenFactory) {
          super();
          this._innerClient = innerClient;
          this._accessTokenFactory = accessTokenFactory;
      }
      async send(request) {
          let allowRetry = true;
          if (this._accessTokenFactory && (!this._accessToken || (request.url && request.url.indexOf("/negotiate?") > 0))) {
              // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory
              allowRetry = false;
              this._accessToken = await this._accessTokenFactory();
          }
          this._setAuthorizationHeader(request);
          const response = await this._innerClient.send(request);
          if (allowRetry && response.statusCode === 401 && this._accessTokenFactory) {
              this._accessToken = await this._accessTokenFactory();
              this._setAuthorizationHeader(request);
              return await this._innerClient.send(request);
          }
          return response;
      }
      _setAuthorizationHeader(request) {
          if (!request.headers) {
              request.headers = {};
          }
          if (this._accessToken) {
              request.headers[HeaderNames.Authorization] = `Bearer ${this._accessToken}`;
          }
          // don't remove the header if there isn't an access token factory, the user manually added the header in this case
          else if (this._accessTokenFactory) {
              if (request.headers[HeaderNames.Authorization]) {
                  delete request.headers[HeaderNames.Authorization];
              }
          }
      }
      getCookieString(url) {
          return this._innerClient.getCookieString(url);
      }
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  // This will be treated as a bit flag in the future, so we keep it using power-of-two values.
  /** Specifies a specific HTTP transport type. */
  var HttpTransportType;
  (function (HttpTransportType) {
      /** Specifies no transport preference. */
      HttpTransportType[HttpTransportType["None"] = 0] = "None";
      /** Specifies the WebSockets transport. */
      HttpTransportType[HttpTransportType["WebSockets"] = 1] = "WebSockets";
      /** Specifies the Server-Sent Events transport. */
      HttpTransportType[HttpTransportType["ServerSentEvents"] = 2] = "ServerSentEvents";
      /** Specifies the Long Polling transport. */
      HttpTransportType[HttpTransportType["LongPolling"] = 4] = "LongPolling";
  })(HttpTransportType || (HttpTransportType = {}));
  /** Specifies the transfer format for a connection. */
  var TransferFormat;
  (function (TransferFormat) {
      /** Specifies that only text data will be transmitted over the connection. */
      TransferFormat[TransferFormat["Text"] = 1] = "Text";
      /** Specifies that binary data will be transmitted over the connection. */
      TransferFormat[TransferFormat["Binary"] = 2] = "Binary";
  })(TransferFormat || (TransferFormat = {}));

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  // Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController
  // We don't actually ever use the API being polyfilled, we always use the polyfill because
  // it's a very new API right now.
  // Not exported from index.
  /** @private */
  let AbortController$1 = class AbortController {
      constructor() {
          this._isAborted = false;
          this.onabort = null;
      }
      abort() {
          if (!this._isAborted) {
              this._isAborted = true;
              if (this.onabort) {
                  this.onabort();
              }
          }
      }
      get signal() {
          return this;
      }
      get aborted() {
          return this._isAborted;
      }
  };

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  // Not exported from 'index', this type is internal.
  /** @private */
  class LongPollingTransport {
      // This is an internal type, not exported from 'index' so this is really just internal.
      get pollAborted() {
          return this._pollAbort.aborted;
      }
      constructor(httpClient, logger, options) {
          this._httpClient = httpClient;
          this._logger = logger;
          this._pollAbort = new AbortController$1();
          this._options = options;
          this._running = false;
          this.onreceive = null;
          this.onclose = null;
      }
      async connect(url, transferFormat) {
          Arg.isRequired(url, "url");
          Arg.isRequired(transferFormat, "transferFormat");
          Arg.isIn(transferFormat, TransferFormat, "transferFormat");
          this._url = url;
          this._logger.log(LogLevel.Trace, "(LongPolling transport) Connecting.");
          // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)
          if (transferFormat === TransferFormat.Binary &&
              (typeof XMLHttpRequest !== "undefined" && typeof new XMLHttpRequest().responseType !== "string")) {
              throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
          }
          const [name, value] = getUserAgentHeader();
          const headers = { [name]: value, ...this._options.headers };
          const pollOptions = {
              abortSignal: this._pollAbort.signal,
              headers,
              timeout: 100000,
              withCredentials: this._options.withCredentials,
          };
          if (transferFormat === TransferFormat.Binary) {
              pollOptions.responseType = "arraybuffer";
          }
          // Make initial long polling request
          // Server uses first long polling request to finish initializing connection and it returns without data
          const pollUrl = `${url}&_=${Date.now()}`;
          this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);
          const response = await this._httpClient.get(pollUrl, pollOptions);
          if (response.statusCode !== 200) {
              this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);
              // Mark running as false so that the poll immediately ends and runs the close logic
              this._closeError = new HttpError(response.statusText || "", response.statusCode);
              this._running = false;
          }
          else {
              this._running = true;
          }
          this._receiving = this._poll(this._url, pollOptions);
      }
      async _poll(url, pollOptions) {
          try {
              while (this._running) {
                  try {
                      const pollUrl = `${url}&_=${Date.now()}`;
                      this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);
                      const response = await this._httpClient.get(pollUrl, pollOptions);
                      if (response.statusCode === 204) {
                          this._logger.log(LogLevel.Information, "(LongPolling transport) Poll terminated by server.");
                          this._running = false;
                      }
                      else if (response.statusCode !== 200) {
                          this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);
                          // Unexpected status code
                          this._closeError = new HttpError(response.statusText || "", response.statusCode);
                          this._running = false;
                      }
                      else {
                          // Process the response
                          if (response.content) {
                              this._logger.log(LogLevel.Trace, `(LongPolling transport) data received. ${getDataDetail(response.content, this._options.logMessageContent)}.`);
                              if (this.onreceive) {
                                  this.onreceive(response.content);
                              }
                          }
                          else {
                              // This is another way timeout manifest.
                              this._logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.");
                          }
                      }
                  }
                  catch (e) {
                      if (!this._running) {
                          // Log but disregard errors that occur after stopping
                          this._logger.log(LogLevel.Trace, `(LongPolling transport) Poll errored after shutdown: ${e.message}`);
                      }
                      else {
                          if (e instanceof TimeoutError) {
                              // Ignore timeouts and reissue the poll.
                              this._logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.");
                          }
                          else {
                              // Close the connection with the error as the result.
                              this._closeError = e;
                              this._running = false;
                          }
                      }
                  }
              }
          }
          finally {
              this._logger.log(LogLevel.Trace, "(LongPolling transport) Polling complete.");
              // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.
              // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.
              if (!this.pollAborted) {
                  this._raiseOnClose();
              }
          }
      }
      async send(data) {
          if (!this._running) {
              return Promise.reject(new Error("Cannot send until the transport is connected"));
          }
          return sendMessage(this._logger, "LongPolling", this._httpClient, this._url, data, this._options);
      }
      async stop() {
          this._logger.log(LogLevel.Trace, "(LongPolling transport) Stopping polling.");
          // Tell receiving loop to stop, abort any current request, and then wait for it to finish
          this._running = false;
          this._pollAbort.abort();
          try {
              await this._receiving;
              // Send DELETE to clean up long polling on the server
              this._logger.log(LogLevel.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`);
              const headers = {};
              const [name, value] = getUserAgentHeader();
              headers[name] = value;
              const deleteOptions = {
                  headers: { ...headers, ...this._options.headers },
                  timeout: this._options.timeout,
                  withCredentials: this._options.withCredentials,
              };
              let error;
              try {
                  await this._httpClient.delete(this._url, deleteOptions);
              }
              catch (err) {
                  error = err;
              }
              if (error) {
                  if (error instanceof HttpError) {
                      if (error.statusCode === 404) {
                          this._logger.log(LogLevel.Trace, "(LongPolling transport) A 404 response was returned from sending a DELETE request.");
                      }
                      else {
                          this._logger.log(LogLevel.Trace, `(LongPolling transport) Error sending a DELETE request: ${error}`);
                      }
                  }
              }
              else {
                  this._logger.log(LogLevel.Trace, "(LongPolling transport) DELETE request accepted.");
              }
          }
          finally {
              this._logger.log(LogLevel.Trace, "(LongPolling transport) Stop finished.");
              // Raise close event here instead of in polling
              // It needs to happen after the DELETE request is sent
              this._raiseOnClose();
          }
      }
      _raiseOnClose() {
          if (this.onclose) {
              let logMessage = "(LongPolling transport) Firing onclose event.";
              if (this._closeError) {
                  logMessage += " Error: " + this._closeError;
              }
              this._logger.log(LogLevel.Trace, logMessage);
              this.onclose(this._closeError);
          }
      }
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  /** @private */
  class ServerSentEventsTransport {
      constructor(httpClient, accessToken, logger, options) {
          this._httpClient = httpClient;
          this._accessToken = accessToken;
          this._logger = logger;
          this._options = options;
          this.onreceive = null;
          this.onclose = null;
      }
      async connect(url, transferFormat) {
          Arg.isRequired(url, "url");
          Arg.isRequired(transferFormat, "transferFormat");
          Arg.isIn(transferFormat, TransferFormat, "transferFormat");
          this._logger.log(LogLevel.Trace, "(SSE transport) Connecting.");
          // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send
          this._url = url;
          if (this._accessToken) {
              url += (url.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(this._accessToken)}`;
          }
          return new Promise((resolve, reject) => {
              let opened = false;
              if (transferFormat !== TransferFormat.Text) {
                  reject(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
                  return;
              }
              let eventSource;
              if (Platform.isBrowser || Platform.isWebWorker) {
                  eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials });
              }
              else {
                  // Non-browser passes cookies via the dictionary
                  const cookies = this._httpClient.getCookieString(url);
                  const headers = {};
                  headers.Cookie = cookies;
                  const [name, value] = getUserAgentHeader();
                  headers[name] = value;
                  eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers } });
              }
              try {
                  eventSource.onmessage = (e) => {
                      if (this.onreceive) {
                          try {
                              this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent)}.`);
                              this.onreceive(e.data);
                          }
                          catch (error) {
                              this._close(error);
                              return;
                          }
                      }
                  };
                  // @ts-ignore: not using event on purpose
                  eventSource.onerror = (e) => {
                      // EventSource doesn't give any useful information about server side closes.
                      if (opened) {
                          this._close();
                      }
                      else {
                          reject(new Error("EventSource failed to connect. The connection could not be found on the server,"
                              + " either the connection ID is not present on the server, or a proxy is refusing/buffering the connection."
                              + " If you have multiple servers check that sticky sessions are enabled."));
                      }
                  };
                  eventSource.onopen = () => {
                      this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);
                      this._eventSource = eventSource;
                      opened = true;
                      resolve();
                  };
              }
              catch (e) {
                  reject(e);
                  return;
              }
          });
      }
      async send(data) {
          if (!this._eventSource) {
              return Promise.reject(new Error("Cannot send until the transport is connected"));
          }
          return sendMessage(this._logger, "SSE", this._httpClient, this._url, data, this._options);
      }
      stop() {
          this._close();
          return Promise.resolve();
      }
      _close(e) {
          if (this._eventSource) {
              this._eventSource.close();
              this._eventSource = undefined;
              if (this.onclose) {
                  this.onclose(e);
              }
          }
      }
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  /** @private */
  class WebSocketTransport {
      constructor(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {
          this._logger = logger;
          this._accessTokenFactory = accessTokenFactory;
          this._logMessageContent = logMessageContent;
          this._webSocketConstructor = webSocketConstructor;
          this._httpClient = httpClient;
          this.onreceive = null;
          this.onclose = null;
          this._headers = headers;
      }
      async connect(url, transferFormat) {
          Arg.isRequired(url, "url");
          Arg.isRequired(transferFormat, "transferFormat");
          Arg.isIn(transferFormat, TransferFormat, "transferFormat");
          this._logger.log(LogLevel.Trace, "(WebSockets transport) Connecting.");
          let token;
          if (this._accessTokenFactory) {
              token = await this._accessTokenFactory();
          }
          return new Promise((resolve, reject) => {
              url = url.replace(/^http/, "ws");
              let webSocket;
              const cookies = this._httpClient.getCookieString(url);
              let opened = false;
              if (Platform.isNode || Platform.isReactNative) {
                  const headers = {};
                  const [name, value] = getUserAgentHeader();
                  headers[name] = value;
                  if (token) {
                      headers[HeaderNames.Authorization] = `Bearer ${token}`;
                  }
                  if (cookies) {
                      headers[HeaderNames.Cookie] = cookies;
                  }
                  // Only pass headers when in non-browser environments
                  webSocket = new this._webSocketConstructor(url, undefined, {
                      headers: { ...headers, ...this._headers },
                  });
              }
              else {
                  if (token) {
                      url += (url.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(token)}`;
                  }
              }
              if (!webSocket) {
                  // Chrome is not happy with passing 'undefined' as protocol
                  webSocket = new this._webSocketConstructor(url);
              }
              if (transferFormat === TransferFormat.Binary) {
                  webSocket.binaryType = "arraybuffer";
              }
              webSocket.onopen = (_event) => {
                  this._logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);
                  this._webSocket = webSocket;
                  opened = true;
                  resolve();
              };
              webSocket.onerror = (event) => {
                  let error = null;
                  // ErrorEvent is a browser only type we need to check if the type exists before using it
                  if (typeof ErrorEvent !== "undefined" && event instanceof ErrorEvent) {
                      error = event.error;
                  }
                  else {
                      error = "There was an error with the transport";
                  }
                  this._logger.log(LogLevel.Information, `(WebSockets transport) ${error}.`);
              };
              webSocket.onmessage = (message) => {
                  this._logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this._logMessageContent)}.`);
                  if (this.onreceive) {
                      try {
                          this.onreceive(message.data);
                      }
                      catch (error) {
                          this._close(error);
                          return;
                      }
                  }
              };
              webSocket.onclose = (event) => {
                  // Don't call close handler if connection was never established
                  // We'll reject the connect call instead
                  if (opened) {
                      this._close(event);
                  }
                  else {
                      let error = null;
                      // ErrorEvent is a browser only type we need to check if the type exists before using it
                      if (typeof ErrorEvent !== "undefined" && event instanceof ErrorEvent) {
                          error = event.error;
                      }
                      else {
                          error = "WebSocket failed to connect. The connection could not be found on the server,"
                              + " either the endpoint may not be a SignalR endpoint,"
                              + " the connection ID is not present on the server, or there is a proxy blocking WebSockets."
                              + " If you have multiple servers check that sticky sessions are enabled.";
                      }
                      reject(new Error(error));
                  }
              };
          });
      }
      send(data) {
          if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {
              this._logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this._logMessageContent)}.`);
              this._webSocket.send(data);
              return Promise.resolve();
          }
          return Promise.reject("WebSocket is not in the OPEN state");
      }
      stop() {
          if (this._webSocket) {
              // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning
              // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects
              this._close(undefined);
          }
          return Promise.resolve();
      }
      _close(event) {
          // webSocket will be null if the transport did not start successfully
          if (this._webSocket) {
              // Clear websocket handlers because we are considering the socket closed now
              this._webSocket.onclose = () => { };
              this._webSocket.onmessage = () => { };
              this._webSocket.onerror = () => { };
              this._webSocket.close();
              this._webSocket = undefined;
          }
          this._logger.log(LogLevel.Trace, "(WebSockets transport) socket closed.");
          if (this.onclose) {
              if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {
                  this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || "no reason given"}).`));
              }
              else if (event instanceof Error) {
                  this.onclose(event);
              }
              else {
                  this.onclose();
              }
          }
      }
      _isCloseEvent(event) {
          return event && typeof event.wasClean === "boolean" && typeof event.code === "number";
      }
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  const MAX_REDIRECTS = 100;
  /** @private */
  class HttpConnection {
      constructor(url, options = {}) {
          this._stopPromiseResolver = () => { };
          this.features = {};
          this._negotiateVersion = 1;
          Arg.isRequired(url, "url");
          this._logger = createLogger(options.logger);
          this.baseUrl = this._resolveUrl(url);
          options = options || {};
          options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;
          if (typeof options.withCredentials === "boolean" || options.withCredentials === undefined) {
              options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;
          }
          else {
              throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");
          }
          options.timeout = options.timeout === undefined ? 100 * 1000 : options.timeout;
          let webSocketModule = null;
          let eventSourceModule = null;
          if (Platform.isNode && typeof require !== "undefined") {
              // In order to ignore the dynamic require in webpack builds we need to do this magic
              // @ts-ignore: TS doesn't know about these names
              const requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
              webSocketModule = requireFunc("ws");
              eventSourceModule = requireFunc("eventsource");
          }
          if (!Platform.isNode && typeof WebSocket !== "undefined" && !options.WebSocket) {
              options.WebSocket = WebSocket;
          }
          else if (Platform.isNode && !options.WebSocket) {
              if (webSocketModule) {
                  options.WebSocket = webSocketModule;
              }
          }
          if (!Platform.isNode && typeof EventSource !== "undefined" && !options.EventSource) {
              options.EventSource = EventSource;
          }
          else if (Platform.isNode && !options.EventSource) {
              if (typeof eventSourceModule !== "undefined") {
                  options.EventSource = eventSourceModule;
              }
          }
          this._httpClient = new AccessTokenHttpClient(options.httpClient || new DefaultHttpClient(this._logger), options.accessTokenFactory);
          this._connectionState = "Disconnected" /* ConnectionState.Disconnected */;
          this._connectionStarted = false;
          this._options = options;
          this.onreceive = null;
          this.onclose = null;
      }
      async start(transferFormat) {
          transferFormat = transferFormat || TransferFormat.Binary;
          Arg.isIn(transferFormat, TransferFormat, "transferFormat");
          this._logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);
          if (this._connectionState !== "Disconnected" /* ConnectionState.Disconnected */) {
              return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));
          }
          this._connectionState = "Connecting" /* ConnectionState.Connecting */;
          this._startInternalPromise = this._startInternal(transferFormat);
          await this._startInternalPromise;
          // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.
          if (this._connectionState === "Disconnecting" /* ConnectionState.Disconnecting */) {
              // stop() was called and transitioned the client into the Disconnecting state.
              const message = "Failed to start the HttpConnection before stop() was called.";
              this._logger.log(LogLevel.Error, message);
              // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.
              await this._stopPromise;
              return Promise.reject(new AbortError(message));
          }
          else if (this._connectionState !== "Connected" /* ConnectionState.Connected */) {
              // stop() was called and transitioned the client into the Disconnecting state.
              const message = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
              this._logger.log(LogLevel.Error, message);
              return Promise.reject(new AbortError(message));
          }
          this._connectionStarted = true;
      }
      send(data) {
          if (this._connectionState !== "Connected" /* ConnectionState.Connected */) {
              return Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State."));
          }
          if (!this._sendQueue) {
              this._sendQueue = new TransportSendQueue(this.transport);
          }
          // Transport will not be null if state is connected
          return this._sendQueue.send(data);
      }
      async stop(error) {
          if (this._connectionState === "Disconnected" /* ConnectionState.Disconnected */) {
              this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);
              return Promise.resolve();
          }
          if (this._connectionState === "Disconnecting" /* ConnectionState.Disconnecting */) {
              this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);
              return this._stopPromise;
          }
          this._connectionState = "Disconnecting" /* ConnectionState.Disconnecting */;
          this._stopPromise = new Promise((resolve) => {
              // Don't complete stop() until stopConnection() completes.
              this._stopPromiseResolver = resolve;
          });
          // stopInternal should never throw so just observe it.
          await this._stopInternal(error);
          await this._stopPromise;
      }
      async _stopInternal(error) {
          // Set error as soon as possible otherwise there is a race between
          // the transport closing and providing an error and the error from a close message
          // We would prefer the close message error.
          this._stopError = error;
          try {
              await this._startInternalPromise;
          }
          catch (e) {
              // This exception is returned to the user as a rejected Promise from the start method.
          }
          // The transport's onclose will trigger stopConnection which will run our onclose event.
          // The transport should always be set if currently connected. If it wasn't set, it's likely because
          // stop was called during start() and start() failed.
          if (this.transport) {
              try {
                  await this.transport.stop();
              }
              catch (e) {
                  this._logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);
                  this._stopConnection();
              }
              this.transport = undefined;
          }
          else {
              this._logger.log(LogLevel.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.");
          }
      }
      async _startInternal(transferFormat) {
          // Store the original base url and the access token factory since they may change
          // as part of negotiating
          let url = this.baseUrl;
          this._accessTokenFactory = this._options.accessTokenFactory;
          this._httpClient._accessTokenFactory = this._accessTokenFactory;
          try {
              if (this._options.skipNegotiation) {
                  if (this._options.transport === HttpTransportType.WebSockets) {
                      // No need to add a connection ID in this case
                      this.transport = this._constructTransport(HttpTransportType.WebSockets);
                      // We should just call connect directly in this case.
                      // No fallback or negotiate in this case.
                      await this._startTransport(url, transferFormat);
                  }
                  else {
                      throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");
                  }
              }
              else {
                  let negotiateResponse = null;
                  let redirects = 0;
                  do {
                      negotiateResponse = await this._getNegotiationResponse(url);
                      // the user tries to stop the connection when it is being started
                      if (this._connectionState === "Disconnecting" /* ConnectionState.Disconnecting */ || this._connectionState === "Disconnected" /* ConnectionState.Disconnected */) {
                          throw new AbortError("The connection was stopped during negotiation.");
                      }
                      if (negotiateResponse.error) {
                          throw new Error(negotiateResponse.error);
                      }
                      if (negotiateResponse.ProtocolVersion) {
                          throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                      }
                      if (negotiateResponse.url) {
                          url = negotiateResponse.url;
                      }
                      if (negotiateResponse.accessToken) {
                          // Replace the current access token factory with one that uses
                          // the returned access token
                          const accessToken = negotiateResponse.accessToken;
                          this._accessTokenFactory = () => accessToken;
                          // set the factory to undefined so the AccessTokenHttpClient won't retry with the same token, since we know it won't change until a connection restart
                          this._httpClient._accessToken = accessToken;
                          this._httpClient._accessTokenFactory = undefined;
                      }
                      redirects++;
                  } while (negotiateResponse.url && redirects < MAX_REDIRECTS);
                  if (redirects === MAX_REDIRECTS && negotiateResponse.url) {
                      throw new Error("Negotiate redirection limit exceeded.");
                  }
                  await this._createTransport(url, this._options.transport, negotiateResponse, transferFormat);
              }
              if (this.transport instanceof LongPollingTransport) {
                  this.features.inherentKeepAlive = true;
              }
              if (this._connectionState === "Connecting" /* ConnectionState.Connecting */) {
                  // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.
                  // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.
                  this._logger.log(LogLevel.Debug, "The HttpConnection connected successfully.");
                  this._connectionState = "Connected" /* ConnectionState.Connected */;
              }
              // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.
              // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()
              // will transition to the disconnected state. start() will wait for the transition using the stopPromise.
          }
          catch (e) {
              this._logger.log(LogLevel.Error, "Failed to start the connection: " + e);
              this._connectionState = "Disconnected" /* ConnectionState.Disconnected */;
              this.transport = undefined;
              // if start fails, any active calls to stop assume that start will complete the stop promise
              this._stopPromiseResolver();
              return Promise.reject(e);
          }
      }
      async _getNegotiationResponse(url) {
          const headers = {};
          const [name, value] = getUserAgentHeader();
          headers[name] = value;
          const negotiateUrl = this._resolveNegotiateUrl(url);
          this._logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);
          try {
              const response = await this._httpClient.post(negotiateUrl, {
                  content: "",
                  headers: { ...headers, ...this._options.headers },
                  timeout: this._options.timeout,
                  withCredentials: this._options.withCredentials,
              });
              if (response.statusCode !== 200) {
                  return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));
              }
              const negotiateResponse = JSON.parse(response.content);
              if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {
                  // Negotiate version 0 doesn't use connectionToken
                  // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version
                  negotiateResponse.connectionToken = negotiateResponse.connectionId;
              }
              if (negotiateResponse.useStatefulReconnect && this._options._useStatefulReconnect !== true) {
                  return Promise.reject(new FailedToNegotiateWithServerError("Client didn't negotiate Stateful Reconnect but the server did."));
              }
              return negotiateResponse;
          }
          catch (e) {
              let errorMessage = "Failed to complete negotiation with the server: " + e;
              if (e instanceof HttpError) {
                  if (e.statusCode === 404) {
                      errorMessage = errorMessage + " Either this is not a SignalR endpoint or there is a proxy blocking the connection.";
                  }
              }
              this._logger.log(LogLevel.Error, errorMessage);
              return Promise.reject(new FailedToNegotiateWithServerError(errorMessage));
          }
      }
      _createConnectUrl(url, connectionToken) {
          if (!connectionToken) {
              return url;
          }
          return url + (url.indexOf("?") === -1 ? "?" : "&") + `id=${connectionToken}`;
      }
      async _createTransport(url, requestedTransport, negotiateResponse, requestedTransferFormat) {
          let connectUrl = this._createConnectUrl(url, negotiateResponse.connectionToken);
          if (this._isITransport(requestedTransport)) {
              this._logger.log(LogLevel.Debug, "Connection was provided an instance of ITransport, using that directly.");
              this.transport = requestedTransport;
              await this._startTransport(connectUrl, requestedTransferFormat);
              this.connectionId = negotiateResponse.connectionId;
              return;
          }
          const transportExceptions = [];
          const transports = negotiateResponse.availableTransports || [];
          let negotiate = negotiateResponse;
          for (const endpoint of transports) {
              const transportOrError = this._resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat, (negotiate === null || negotiate === void 0 ? void 0 : negotiate.useStatefulReconnect) === true);
              if (transportOrError instanceof Error) {
                  // Store the error and continue, we don't want to cause a re-negotiate in these cases
                  transportExceptions.push(`${endpoint.transport} failed:`);
                  transportExceptions.push(transportOrError);
              }
              else if (this._isITransport(transportOrError)) {
                  this.transport = transportOrError;
                  if (!negotiate) {
                      try {
                          negotiate = await this._getNegotiationResponse(url);
                      }
                      catch (ex) {
                          return Promise.reject(ex);
                      }
                      connectUrl = this._createConnectUrl(url, negotiate.connectionToken);
                  }
                  try {
                      await this._startTransport(connectUrl, requestedTransferFormat);
                      this.connectionId = negotiate.connectionId;
                      return;
                  }
                  catch (ex) {
                      this._logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);
                      negotiate = undefined;
                      transportExceptions.push(new FailedToStartTransportError(`${endpoint.transport} failed: ${ex}`, HttpTransportType[endpoint.transport]));
                      if (this._connectionState !== "Connecting" /* ConnectionState.Connecting */) {
                          const message = "Failed to select transport before stop() was called.";
                          this._logger.log(LogLevel.Debug, message);
                          return Promise.reject(new AbortError(message));
                      }
                  }
              }
          }
          if (transportExceptions.length > 0) {
              return Promise.reject(new AggregateErrors(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(" ")}`, transportExceptions));
          }
          return Promise.reject(new Error("None of the transports supported by the client are supported by the server."));
      }
      _constructTransport(transport) {
          switch (transport) {
              case HttpTransportType.WebSockets:
                  if (!this._options.WebSocket) {
                      throw new Error("'WebSocket' is not supported in your environment.");
                  }
                  return new WebSocketTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.WebSocket, this._options.headers || {});
              case HttpTransportType.ServerSentEvents:
                  if (!this._options.EventSource) {
                      throw new Error("'EventSource' is not supported in your environment.");
                  }
                  return new ServerSentEventsTransport(this._httpClient, this._httpClient._accessToken, this._logger, this._options);
              case HttpTransportType.LongPolling:
                  return new LongPollingTransport(this._httpClient, this._logger, this._options);
              default:
                  throw new Error(`Unknown transport: ${transport}.`);
          }
      }
      _startTransport(url, transferFormat) {
          this.transport.onreceive = this.onreceive;
          if (this.features.reconnect) {
              this.transport.onclose = async (e) => {
                  let callStop = false;
                  if (this.features.reconnect) {
                      try {
                          this.features.disconnected();
                          await this.transport.connect(url, transferFormat);
                          await this.features.resend();
                      }
                      catch {
                          callStop = true;
                      }
                  }
                  else {
                      this._stopConnection(e);
                      return;
                  }
                  if (callStop) {
                      this._stopConnection(e);
                  }
              };
          }
          else {
              this.transport.onclose = (e) => this._stopConnection(e);
          }
          return this.transport.connect(url, transferFormat);
      }
      _resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat, useStatefulReconnect) {
          const transport = HttpTransportType[endpoint.transport];
          if (transport === null || transport === undefined) {
              this._logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);
              return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);
          }
          else {
              if (transportMatches(requestedTransport, transport)) {
                  const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);
                  if (transferFormats.indexOf(requestedTransferFormat) >= 0) {
                      if ((transport === HttpTransportType.WebSockets && !this._options.WebSocket) ||
                          (transport === HttpTransportType.ServerSentEvents && !this._options.EventSource)) {
                          this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);
                          return new UnsupportedTransportError(`'${HttpTransportType[transport]}' is not supported in your environment.`, transport);
                      }
                      else {
                          this._logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);
                          try {
                              this.features.reconnect = transport === HttpTransportType.WebSockets ? useStatefulReconnect : undefined;
                              return this._constructTransport(transport);
                          }
                          catch (ex) {
                              return ex;
                          }
                      }
                  }
                  else {
                      this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);
                      return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);
                  }
              }
              else {
                  this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);
                  return new DisabledTransportError(`'${HttpTransportType[transport]}' is disabled by the client.`, transport);
              }
          }
      }
      _isITransport(transport) {
          return transport && typeof (transport) === "object" && "connect" in transport;
      }
      _stopConnection(error) {
          this._logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this._connectionState}.`);
          this.transport = undefined;
          // If we have a stopError, it takes precedence over the error from the transport
          error = this._stopError || error;
          this._stopError = undefined;
          if (this._connectionState === "Disconnected" /* ConnectionState.Disconnected */) {
              this._logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);
              return;
          }
          if (this._connectionState === "Connecting" /* ConnectionState.Connecting */) {
              this._logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);
              throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);
          }
          if (this._connectionState === "Disconnecting" /* ConnectionState.Disconnecting */) {
              // A call to stop() induced this call to stopConnection and needs to be completed.
              // Any stop() awaiters will be scheduled to continue after the onclose callback fires.
              this._stopPromiseResolver();
          }
          if (error) {
              this._logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);
          }
          else {
              this._logger.log(LogLevel.Information, "Connection disconnected.");
          }
          if (this._sendQueue) {
              this._sendQueue.stop().catch((e) => {
                  this._logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);
              });
              this._sendQueue = undefined;
          }
          this.connectionId = undefined;
          this._connectionState = "Disconnected" /* ConnectionState.Disconnected */;
          if (this._connectionStarted) {
              this._connectionStarted = false;
              try {
                  if (this.onclose) {
                      this.onclose(error);
                  }
              }
              catch (e) {
                  this._logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);
              }
          }
      }
      _resolveUrl(url) {
          // startsWith is not supported in IE
          if (url.lastIndexOf("https://", 0) === 0 || url.lastIndexOf("http://", 0) === 0) {
              return url;
          }
          if (!Platform.isBrowser) {
              throw new Error(`Cannot resolve '${url}'.`);
          }
          // Setting the url to the href propery of an anchor tag handles normalization
          // for us. There are 3 main cases.
          // 1. Relative path normalization e.g "b" -> "http://localhost:5000/a/b"
          // 2. Absolute path normalization e.g "/a/b" -> "http://localhost:5000/a/b"
          // 3. Networkpath reference normalization e.g "//localhost:5000/a/b" -> "http://localhost:5000/a/b"
          const aTag = window.document.createElement("a");
          aTag.href = url;
          this._logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);
          return aTag.href;
      }
      _resolveNegotiateUrl(url) {
          const negotiateUrl = new URL(url);
          if (negotiateUrl.pathname.endsWith('/')) {
              negotiateUrl.pathname += "negotiate";
          }
          else {
              negotiateUrl.pathname += "/negotiate";
          }
          const searchParams = new URLSearchParams(negotiateUrl.searchParams);
          if (!searchParams.has("negotiateVersion")) {
              searchParams.append("negotiateVersion", this._negotiateVersion.toString());
          }
          if (searchParams.has("useStatefulReconnect")) {
              if (searchParams.get("useStatefulReconnect") === "true") {
                  this._options._useStatefulReconnect = true;
              }
          }
          else if (this._options._useStatefulReconnect === true) {
              searchParams.append("useStatefulReconnect", "true");
          }
          negotiateUrl.search = searchParams.toString();
          return negotiateUrl.toString();
      }
  }
  function transportMatches(requestedTransport, actualTransport) {
      return !requestedTransport || ((actualTransport & requestedTransport) !== 0);
  }
  /** @private */
  class TransportSendQueue {
      constructor(_transport) {
          this._transport = _transport;
          this._buffer = [];
          this._executing = true;
          this._sendBufferedData = new PromiseSource();
          this._transportResult = new PromiseSource();
          this._sendLoopPromise = this._sendLoop();
      }
      send(data) {
          this._bufferData(data);
          if (!this._transportResult) {
              this._transportResult = new PromiseSource();
          }
          return this._transportResult.promise;
      }
      stop() {
          this._executing = false;
          this._sendBufferedData.resolve();
          return this._sendLoopPromise;
      }
      _bufferData(data) {
          if (this._buffer.length && typeof (this._buffer[0]) !== typeof (data)) {
              throw new Error(`Expected data to be of type ${typeof (this._buffer)} but was of type ${typeof (data)}`);
          }
          this._buffer.push(data);
          this._sendBufferedData.resolve();
      }
      async _sendLoop() {
          while (true) {
              await this._sendBufferedData.promise;
              if (!this._executing) {
                  if (this._transportResult) {
                      this._transportResult.reject("Connection stopped.");
                  }
                  break;
              }
              this._sendBufferedData = new PromiseSource();
              const transportResult = this._transportResult;
              this._transportResult = undefined;
              const data = typeof (this._buffer[0]) === "string" ?
                  this._buffer.join("") :
                  TransportSendQueue._concatBuffers(this._buffer);
              this._buffer.length = 0;
              try {
                  await this._transport.send(data);
                  transportResult.resolve();
              }
              catch (error) {
                  transportResult.reject(error);
              }
          }
      }
      static _concatBuffers(arrayBuffers) {
          const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);
          const result = new Uint8Array(totalLength);
          let offset = 0;
          for (const item of arrayBuffers) {
              result.set(new Uint8Array(item), offset);
              offset += item.byteLength;
          }
          return result.buffer;
      }
  }
  class PromiseSource {
      constructor() {
          this.promise = new Promise((resolve, reject) => [this._resolver, this._rejecter] = [resolve, reject]);
      }
      resolve() {
          this._resolver();
      }
      reject(reason) {
          this._rejecter(reason);
      }
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  const JSON_HUB_PROTOCOL_NAME = "json";
  /** Implements the JSON Hub Protocol. */
  class JsonHubProtocol {
      constructor() {
          /** @inheritDoc */
          this.name = JSON_HUB_PROTOCOL_NAME;
          /** @inheritDoc */
          this.version = 2;
          /** @inheritDoc */
          this.transferFormat = TransferFormat.Text;
      }
      /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.
       *
       * @param {string} input A string containing the serialized representation.
       * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.
       */
      parseMessages(input, logger) {
          // The interface does allow "ArrayBuffer" to be passed in, but this implementation does not. So let's throw a useful error.
          if (typeof input !== "string") {
              throw new Error("Invalid input for JSON hub protocol. Expected a string.");
          }
          if (!input) {
              return [];
          }
          if (logger === null) {
              logger = NullLogger.instance;
          }
          // Parse the messages
          const messages = TextMessageFormat.parse(input);
          const hubMessages = [];
          for (const message of messages) {
              const parsedMessage = JSON.parse(message);
              if (typeof parsedMessage.type !== "number") {
                  throw new Error("Invalid payload.");
              }
              switch (parsedMessage.type) {
                  case MessageType.Invocation:
                      this._isInvocationMessage(parsedMessage);
                      break;
                  case MessageType.StreamItem:
                      this._isStreamItemMessage(parsedMessage);
                      break;
                  case MessageType.Completion:
                      this._isCompletionMessage(parsedMessage);
                      break;
                  case MessageType.Ping:
                      // Single value, no need to validate
                      break;
                  case MessageType.Close:
                      // All optional values, no need to validate
                      break;
                  case MessageType.Ack:
                      this._isAckMessage(parsedMessage);
                      break;
                  case MessageType.Sequence:
                      this._isSequenceMessage(parsedMessage);
                      break;
                  default:
                      // Future protocol changes can add message types, old clients can ignore them
                      logger.log(LogLevel.Information, "Unknown message type '" + parsedMessage.type + "' ignored.");
                      continue;
              }
              hubMessages.push(parsedMessage);
          }
          return hubMessages;
      }
      /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.
       *
       * @param {HubMessage} message The message to write.
       * @returns {string} A string containing the serialized representation of the message.
       */
      writeMessage(message) {
          return TextMessageFormat.write(JSON.stringify(message));
      }
      _isInvocationMessage(message) {
          this._assertNotEmptyString(message.target, "Invalid payload for Invocation message.");
          if (message.invocationId !== undefined) {
              this._assertNotEmptyString(message.invocationId, "Invalid payload for Invocation message.");
          }
      }
      _isStreamItemMessage(message) {
          this._assertNotEmptyString(message.invocationId, "Invalid payload for StreamItem message.");
          if (message.item === undefined) {
              throw new Error("Invalid payload for StreamItem message.");
          }
      }
      _isCompletionMessage(message) {
          if (message.result && message.error) {
              throw new Error("Invalid payload for Completion message.");
          }
          if (!message.result && message.error) {
              this._assertNotEmptyString(message.error, "Invalid payload for Completion message.");
          }
          this._assertNotEmptyString(message.invocationId, "Invalid payload for Completion message.");
      }
      _isAckMessage(message) {
          if (typeof message.sequenceId !== 'number') {
              throw new Error("Invalid SequenceId for Ack message.");
          }
      }
      _isSequenceMessage(message) {
          if (typeof message.sequenceId !== 'number') {
              throw new Error("Invalid SequenceId for Sequence message.");
          }
      }
      _assertNotEmptyString(value, errorMessage) {
          if (typeof value !== "string" || value === "") {
              throw new Error(errorMessage);
          }
      }
  }

  // Licensed to the .NET Foundation under one or more agreements.
  // The .NET Foundation licenses this file to you under the MIT license.
  const LogLevelNameMapping = {
      trace: LogLevel.Trace,
      debug: LogLevel.Debug,
      info: LogLevel.Information,
      information: LogLevel.Information,
      warn: LogLevel.Warning,
      warning: LogLevel.Warning,
      error: LogLevel.Error,
      critical: LogLevel.Critical,
      none: LogLevel.None,
  };
  function parseLogLevel(name) {
      // Case-insensitive matching via lower-casing
      // Yes, I know case-folding is a complicated problem in Unicode, but we only support
      // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.
      const mapping = LogLevelNameMapping[name.toLowerCase()];
      if (typeof mapping !== "undefined") {
          return mapping;
      }
      else {
          throw new Error(`Unknown log level: ${name}`);
      }
  }
  /** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */
  class HubConnectionBuilder {
      configureLogging(logging) {
          Arg.isRequired(logging, "logging");
          if (isLogger(logging)) {
              this.logger = logging;
          }
          else if (typeof logging === "string") {
              const logLevel = parseLogLevel(logging);
              this.logger = new ConsoleLogger(logLevel);
          }
          else {
              this.logger = new ConsoleLogger(logging);
          }
          return this;
      }
      withUrl(url, transportTypeOrOptions) {
          Arg.isRequired(url, "url");
          Arg.isNotEmpty(url, "url");
          this.url = url;
          // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed
          // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.
          if (typeof transportTypeOrOptions === "object") {
              this.httpConnectionOptions = { ...this.httpConnectionOptions, ...transportTypeOrOptions };
          }
          else {
              this.httpConnectionOptions = {
                  ...this.httpConnectionOptions,
                  transport: transportTypeOrOptions,
              };
          }
          return this;
      }
      /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.
       *
       * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.
       */
      withHubProtocol(protocol) {
          Arg.isRequired(protocol, "protocol");
          this.protocol = protocol;
          return this;
      }
      withAutomaticReconnect(retryDelaysOrReconnectPolicy) {
          if (this.reconnectPolicy) {
              throw new Error("A reconnectPolicy has already been set.");
          }
          if (!retryDelaysOrReconnectPolicy) {
              this.reconnectPolicy = new DefaultReconnectPolicy();
          }
          else if (Array.isArray(retryDelaysOrReconnectPolicy)) {
              this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);
          }
          else {
              this.reconnectPolicy = retryDelaysOrReconnectPolicy;
          }
          return this;
      }
      /** Configures {@link @microsoft/signalr.HubConnection.serverTimeoutInMilliseconds} for the {@link @microsoft/signalr.HubConnection}.
       *
       * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.
       */
      withServerTimeout(milliseconds) {
          Arg.isRequired(milliseconds, "milliseconds");
          this._serverTimeoutInMilliseconds = milliseconds;
          return this;
      }
      /** Configures {@link @microsoft/signalr.HubConnection.keepAliveIntervalInMilliseconds} for the {@link @microsoft/signalr.HubConnection}.
       *
       * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.
       */
      withKeepAliveInterval(milliseconds) {
          Arg.isRequired(milliseconds, "milliseconds");
          this._keepAliveIntervalInMilliseconds = milliseconds;
          return this;
      }
      /** Enables and configures options for the Stateful Reconnect feature.
       *
       * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.
       */
      withStatefulReconnect(options) {
          if (this.httpConnectionOptions === undefined) {
              this.httpConnectionOptions = {};
          }
          this.httpConnectionOptions._useStatefulReconnect = true;
          this._statefulReconnectBufferSize = options === null || options === void 0 ? void 0 : options.bufferSize;
          return this;
      }
      /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.
       *
       * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.
       */
      build() {
          // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one
          // provided to configureLogger
          const httpConnectionOptions = this.httpConnectionOptions || {};
          // If it's 'null', the user **explicitly** asked for null, don't mess with it.
          if (httpConnectionOptions.logger === undefined) {
              // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.
              httpConnectionOptions.logger = this.logger;
          }
          // Now create the connection
          if (!this.url) {
              throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
          }
          const connection = new HttpConnection(this.url, httpConnectionOptions);
          return HubConnection.create(connection, this.logger || NullLogger.instance, this.protocol || new JsonHubProtocol(), this.reconnectPolicy, this._serverTimeoutInMilliseconds, this._keepAliveIntervalInMilliseconds, this._statefulReconnectBufferSize);
      }
  }
  function isLogger(logger) {
      return logger.log !== undefined;
  }

  var RetryPolicy = /** @class */ (function () {
      function RetryPolicy(conn) {
          this.connector = conn;
      }
      RetryPolicy.prototype.nextRetryDelayInMilliseconds = function (retryContext) {
          if (retryContext.previousRetryCount > 2) {
              if (retryContext.previousRetryCount > 5) {
                  if (retryContext.previousRetryCount > 10) {
                      if (retryContext.previousRetryCount > 20) {
                          return 30000;
                      }
                      return 15000;
                  }
                  return 10000;
              }
              return 5000;
          }
          return 1000;
      };
      return RetryPolicy;
  }());
  var SignalRConnector = /** @class */ (function (_super) {
      __extends(SignalRConnector, _super);
      function SignalRConnector() {
          var _this = _super.call(this) || this;
          _this.recreateClientId();
          _this.userInfo = null;
          console.log('SignalRConnector ctor');
          _this._connectedEvent = new ConnectedEventEmitter();
          return _this;
      }
      Object.defineProperty(SignalRConnector.prototype, "connectedEvent", {
          get: function () {
              return this._connectedEvent;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(SignalRConnector.prototype, "isConnected", {
          get: function () {
              var _a;
              return this.initialized && ((_a = this.hub) === null || _a === void 0 ? void 0 : _a.state) === HubConnectionState.Connected;
          },
          enumerable: false,
          configurable: true
      });
      SignalRConnector.prototype.init = function () {
          var _this = this;
          return new Promise(function (resolve, reject) {
              var _a, _b, _c;
              console.log("SignalRConnector.init() initialized = ".concat(_this.initialized, ", state = ").concat((_a = _this.hub) === null || _a === void 0 ? void 0 : _a.state));
              if (_this.initialized) {
                  // TODO kay: what if in state connecting ? !!!
                  if (((_b = _this.hub) === null || _b === void 0 ? void 0 : _b.state) !== HubConnectionState.Connected) {
                      var options = {
                          accessTokenFactory: function () {
                              var _a;
                              if (_this.accessTokenFn) {
                                  return _this.accessTokenFn();
                              }
                              if ((_a = _this.userInfo) === null || _a === void 0 ? void 0 : _a.access_token) {
                                  return _this.userInfo.access_token;
                              }
                              return null;
                          },
                          transport: SignalRConnector.transportType
                      };
                      var hubUrl = _this.getHubUrl();
                      _this.hub = new HubConnectionBuilder()
                          .withUrl(hubUrl, options)
                          .withAutomaticReconnect(new RetryPolicy(_this))
                          .configureLogging(SignalRConnector.logLevel)
                          .build();
                      _this.hub.serverTimeoutInMilliseconds = 120000;
                      _this.hub.on('GetRemoteLogMessage', function (statusUpdateDto) {
                          var message = ">>> Remote: ".concat(statusUpdateDto.message);
                          switch (statusUpdateDto.logLevel) {
                              case 0:
                                  console.error(message);
                                  break;
                              case 1:
                                  console.warn(message);
                                  break;
                              default:
                                  console.log(message);
                          }
                      });
                      _this.hub.onreconnecting(function (error) {
                          console.log("onreconnecting started due to ".concat(error.message));
                          _this._connectedEvent.emit('connected', false);
                      });
                      _this.hub.onclose(function (error) {
                          console.log("hub connection onclose");
                          _this._connectedEvent.emit('connected', false);
                      });
                      _this.hub.onreconnected(function (id) {
                          console.log("reconnected successfully, connection ID = ".concat(id));
                          _this._connectedEvent.emit('connected', true);
                          // Server might be shutdown, re-create session again
                          // Added for licensing concurrent user check:
                          // If we don't register clients again server can be restarted and concurrent user count will be reset.
                          _this.reCreateSession();
                      });
                      console.log("starting hub connection to ".concat(hubUrl));
                      _this.hub.start()
                          .then(function (res) {
                          console.log("--- HubConnection.start(): ".concat(_this.hub.state, ", ").concat(_this.hub.baseUrl));
                          _this.registerClientId()
                              .then(function (registerSuccess) {
                              console.log('Client registration successful');
                              _this._connectedEvent.emit('connected', true);
                              return;
                          })
                              .catch(function (registerExc) {
                              console.error("--- Client registration error:");
                              _this._connectedEvent.emit('connected', false);
                          });
                      })
                          .catch(function (exc) {
                          console.error("--- Hub error");
                          _this.hub = null;
                          _this._connectedEvent.emit('connected', false);
                      });
                  }
                  else {
                      reject("SignalRConnector is in wrong state: ".concat((_c = _this.hub) === null || _c === void 0 ? void 0 : _c.state));
                  }
              }
              else {
                  resolve();
              }
          });
      };
      SignalRConnector.prototype.reCreateSession = function () {
          var _this = this;
          this.registerClientId()
              .then(function () {
              console.log('Client registered again after reconnect');
              // When connected already try to re initialize session
              // Currently done for single client setup!
              if (_this.targetId) {
                  _this.create(_this.targetId).then(function (value) {
                      console.log("reconnected, re-creating session for ".concat(_this.targetId, ", error:"), value.errorMessage);
                      if (value.errorMessage) {
                          setTimeout(function () {
                              // Try again recursively since sometimes upv might take more time to reconnect.
                              _this.reCreateSession();
                          }, 1000);
                      }
                  });
              }
              return;
          })
              .catch(function (registerExc) {
              console.error("--- Client registration error:");
              _this._connectedEvent.emit('connected', false);
          });
      };
      SignalRConnector.prototype.getHubUrl = function () {
          var hubUrl = baseUrl('/sighub/upv');
          console.log("Hub URL is ".concat(hubUrl));
          return hubUrl;
      };
      SignalRConnector.prototype.hubRequest = function () {
          return __awaiter(this, void 0, void 0, function () {
              var _loop_1, this_1, retries, state_1;
              var _this = this;
              var _a, _b, _c;
              return __generator(this, function (_d) {
                  switch (_d.label) {
                      case 0:
                          if (((_a = this.hub) === null || _a === void 0 ? void 0 : _a.state) === HubConnectionState.Connected) {
                              return [2 /*return*/, this.hub];
                          }
                          _loop_1 = function (retries) {
                              var promise, needsInit, message, e_1;
                              return __generator(this, function (_e) {
                                  switch (_e.label) {
                                      case 0:
                                          promise = void 0;
                                          needsInit = true;
                                          if (this_1.hub) {
                                              if (this_1.hub.state === HubConnectionState.Connecting || this_1.hub.state === HubConnectionState.Reconnecting) {
                                                  needsInit = false;
                                              }
                                              else if (this_1.hub.state === HubConnectionState.Disconnected) {
                                                  console.log("Hub disconnected, calling init()");
                                              }
                                              else {
                                                  message = "Hub connection not ready, state: ".concat(this_1.hub.state);
                                                  console.log(message);
                                                  return [2 /*return*/, { value: Promise.reject(message) }];
                                              }
                                          }
                                          else {
                                              console.log("Hub is null, calling init()");
                                          }
                                          if (needsInit) {
                                              promise = new Promise(function (resolve) {
                                                  var _a;
                                                  console.log("Waiting for connection, state: ".concat((_a = _this.hub) === null || _a === void 0 ? void 0 : _a.state));
                                                  _this._connectedEvent.once('connected', function (success) {
                                                      var _a;
                                                      console.log("hubRequest() onconnected after needsInit: ".concat(success, ", state = ").concat((_a = _this.hub) === null || _a === void 0 ? void 0 : _a.state));
                                                      needsInit = !success;
                                                      resolve(_this.hub);
                                                  });
                                                  _this.init();
                                              });
                                          }
                                          else {
                                              promise = new Promise(function (resolve) {
                                                  var _a;
                                                  console.log("Waiting for connection, state: ".concat((_a = _this.hub) === null || _a === void 0 ? void 0 : _a.state));
                                                  _this._connectedEvent.once('connected', function (success) {
                                                      var _a;
                                                      console.log("hubRequest() onconnected after connecting: ".concat(success, ", state = ").concat((_a = _this.hub) === null || _a === void 0 ? void 0 : _a.state));
                                                      needsInit = !success;
                                                      resolve(_this.hub);
                                                  });
                                              });
                                          }
                                          _e.label = 1;
                                      case 1:
                                          _e.trys.push([1, 4, , 5]);
                                          return [4 /*yield*/, promise];
                                      case 2:
                                          _e.sent();
                                          console.log("init() returned, hub state = ".concat((_b = this_1.hub) === null || _b === void 0 ? void 0 : _b.state));
                                          if (this_1.isConnected) {
                                              return [2 /*return*/, "break"];
                                          }
                                          return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, 1000); })];
                                      case 3:
                                          _e.sent();
                                          return [3 /*break*/, 5];
                                      case 4:
                                          e_1 = _e.sent();
                                          console.log("#".concat(retries, " Failed to set up hub connection (").concat((_c = this_1.hub) === null || _c === void 0 ? void 0 : _c.state, "): ").concat(e_1 === null || e_1 === void 0 ? void 0 : e_1.message));
                                          return [3 /*break*/, 5];
                                      case 5: return [2 /*return*/];
                                  }
                              });
                          };
                          this_1 = this;
                          retries = 1;
                          _d.label = 1;
                      case 1:
                          if (!(retries < 20)) return [3 /*break*/, 4];
                          return [5 /*yield**/, _loop_1(retries)];
                      case 2:
                          state_1 = _d.sent();
                          if (typeof state_1 === "object")
                              return [2 /*return*/, state_1.value];
                          if (state_1 === "break")
                              return [3 /*break*/, 4];
                          _d.label = 3;
                      case 3:
                          retries++;
                          return [3 /*break*/, 1];
                      case 4: return [2 /*return*/, this.hub];
                  }
              });
          });
      };
      SignalRConnector.prototype.registerClientId = function () {
          return __awaiter(this, void 0, void 0, function () {
              var reqDto;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (!this.isConnected) return [3 /*break*/, 2];
                          reqDto = { 'SessionId': this.clientId };
                          return [4 /*yield*/, this.hub.invoke('RegisterClientId', reqDto)];
                      case 1:
                          _a.sent();
                          this.upvCookies.cleanupCookie('nextClientId', this.clientId);
                          _a.label = 2;
                      case 2: return [2 /*return*/];
                  }
              });
          });
      };
      SignalRConnector.prototype.create = function (targetId) {
          return __awaiter(this, void 0, void 0, function () {
              var reqDto, hubConnectionPromise, e_2;
              var _a;
              return __generator(this, function (_b) {
                  switch (_b.label) {
                      case 0:
                          this.targetId = targetId;
                          reqDto = { 'streamingConnectionId': this.clientId, 'targetSessionId': targetId, 'streamingConnectionType': 'client' };
                          _b.label = 1;
                      case 1:
                          _b.trys.push([1, 3, , 5]);
                          return [4 /*yield*/, this.hubRequest()];
                      case 2:
                          hubConnectionPromise = _b.sent();
                          return [3 /*break*/, 5];
                      case 3:
                          e_2 = _b.sent();
                          console.warn("Cannot set hub connection, trying again", e_2);
                          return [4 /*yield*/, this.hubRequest()];
                      case 4:
                          hubConnectionPromise = _b.sent();
                          return [3 /*break*/, 5];
                      case 5:
                          console.log("Got hub connection for create session ".concat((_a = this.hub) === null || _a === void 0 ? void 0 : _a.state));
                          return [2 /*return*/, hubConnectionPromise.invoke('CreateSession', reqDto)];
                  }
              });
          });
      };
      SignalRConnector.prototype.delete = function (sessionId, willReconnect) {
          return __awaiter(this, void 0, void 0, function () {
              var reqDto;
              return __generator(this, function (_a) {
                  reqDto = { 'sessionId': sessionId, 'reInit': willReconnect };
                  this.targetId = null;
                  return [2 /*return*/, this.hubRequest().then(function (h) { return h.send('DeleteSession', reqDto); })];
              });
          });
      };
      SignalRConnector.prototype.cancelLoading = function (clientId, targetId) {
          return __awaiter(this, void 0, void 0, function () {
              var reqDto;
              return __generator(this, function (_a) {
                  reqDto = { 'clientId': clientId, 'targetId': targetId };
                  return [2 /*return*/, this.hubRequest().then(function (h) { return h.send('CancelLoading', reqDto); })];
              });
          });
      };
      SignalRConnector.prototype.createConnection = function (sessionId) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  return [2 /*return*/, this.hubRequest().then(function (h) { return h.invoke('CreateConnection', sessionId); })];
              });
          });
      };
      SignalRConnector.prototype.sendOffer = function (sessionId, connectionId, sdp, upvInstanceId) {
          return __awaiter(this, void 0, void 0, function () {
              var reqDto;
              return __generator(this, function (_a) {
                  reqDto = { 'sdp': sdp, 'connectionId': connectionId, 'targetSessionId': upvInstanceId };
                  return [2 /*return*/, this.hubRequest().then(function (h) { return h.invoke('PostOffer', sessionId, reqDto); })];
              });
          });
      };
      SignalRConnector.prototype.sendCandidate = function (sessionId, connectionId, candidate, sdpMid, sdpMLineIndex) {
          return __awaiter(this, void 0, void 0, function () {
              var reqDto;
              return __generator(this, function (_a) {
                  reqDto = {
                      'candidate': candidate,
                      'sdpMLineIndex': sdpMLineIndex,
                      'sdpMid': sdpMid,
                      'connectionId': connectionId
                  };
                  return [2 /*return*/, this.hubRequest().then(function (h) { return h.invoke('PostCandidate', sessionId, reqDto); })];
              });
          });
      };
      SignalRConnector.prototype.getAnswer = function (sessionId, callback) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  this.hubRequest().then(function (h) {
                      if (callback) {
                          h.on('GetAnswer', function (args) { return callback(args); });
                      }
                      else {
                          h.off('GetAnswer');
                      }
                  });
                  return [2 /*return*/];
              });
          });
      };
      SignalRConnector.prototype.getCandidate = function (sessionId, callback) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  this.hubRequest().then(function (h) {
                      if (callback) {
                          h.on('GetCandidate', function (args) { return callback(args); });
                      }
                      else {
                          h.off('GetCandidate');
                      }
                  });
                  return [2 /*return*/];
              });
          });
      };
      SignalRConnector.prototype.getServerListUpdate = function (callback) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  this.hubRequest().then(function (h) {
                      if (callback) {
                          h.on('GetServerListUpdate', function (args) { return callback(args); });
                      }
                      else {
                          // h.off raises warnings, thus register an empty listener
                          h.on('GetServerListUpdate', function (args) { });
                      }
                  });
                  return [2 /*return*/];
              });
          });
      };
      SignalRConnector.prototype.getStartingProgress = function (callback) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  this.hubRequest().then(function (h) {
                      if (callback) {
                          // TODO kay: simplify data structure when SSE is removed
                          h.on('GetStartingProgress', function (args) { return callback({ 'data': JSON.stringify(args) }); });
                      }
                      else {
                          h.off('GetStartingProgress');
                      }
                  });
                  return [2 /*return*/];
              });
          });
      };
      SignalRConnector.prototype.onResizeFinished = function (callback) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  this.hubRequest().then(function (h) {
                      if (callback) {
                          h.on('ResizeFinished', function (args) { return callback(args); });
                      }
                      else {
                          h.off('ResizeFinished');
                      }
                  });
                  return [2 /*return*/];
              });
          });
      };
      SignalRConnector.prototype.sendPing = function (sessionId, connectionId) {
          return __awaiter(this, void 0, void 0, function () {
              var reqDto;
              return __generator(this, function (_a) {
                  reqDto = { 'sessionId': sessionId, 'connectionId': connectionId };
                  return [2 /*return*/, this.hubRequest().then(function (h) { return h.invoke('Ping', reqDto); })];
              });
          });
      };
      SignalRConnector.prototype.requestResizing = function (resizeReqData) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  return [2 /*return*/, this.hubRequest().then(function (h) { return h.invoke('SendResizeRequest', resizeReqData); })];
              });
          });
      };
      SignalRConnector.prototype.sendStartInstanceCommand = function (bodyJson) {
          return __awaiter(this, void 0, void 0, function () {
              var serverUrl, _a, _b;
              var _c;
              return __generator(this, function (_d) {
                  switch (_d.label) {
                      case 0:
                          serverUrl = new URL(url('start'));
                          _a = fetch;
                          _b = [serverUrl.href];
                          _c = { method: 'POST' };
                          return [4 /*yield*/, this.headers()];
                      case 1: return [2 /*return*/, _a.apply(void 0, _b.concat([(_c.headers = _d.sent(), _c.body = bodyJson, _c)]))];
                  }
              });
          });
      };
      SignalRConnector.prototype.updatePeerStatus = function (status) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  return [2 /*return*/, this.hubRequest().then(function (h) { return h.invoke('UpdatePeerStatus', status); })
                          .catch(function (reason) { return console.log("Failed to update peer status to ".concat(status), reason); })];
              });
          });
      };
      SignalRConnector.prototype.logRemoteMessage = function (message, level) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  return [2 /*return*/, this.hubRequest().then(function (h) { return h.invoke('RemoteLogMessage', message, level, true); })
                          .catch(function (reason) { return console.log("Failed to send remote log message ".concat(message), reason); })];
              });
          });
      };
      SignalRConnector.prototype.shutdown = function () {
          var _a, _b;
          switch ((_a = this.hub) === null || _a === void 0 ? void 0 : _a.state) {
              case HubConnectionState.Connected:
              case HubConnectionState.Connecting:
              case HubConnectionState.Reconnecting:
                  this.hub.stop().then(function (r) { return console.log("hub connection stopped"); }).catch(function (e) { return console.error("error when stopping hub connection: ".concat(e)); });
                  break;
              default:
                  console.log("connector shutdown call ignored, state = ".concat((_b = this.hub) === null || _b === void 0 ? void 0 : _b.state));
          }
      };
      SignalRConnector.logLevel = LogLevel.Debug;
      // usually no filter for transport types should be enabled for SignalR, for testing supply bitwise OR combination
      // tslint:disable-next-line:no-bitwise
      SignalRConnector.transportType = HttpTransportType.None;
      return SignalRConnector;
  }(Connector));

  var SignalREventListener = /** @class */ (function () {
      function SignalREventListener(connector) {
          this.connector = connector;
      }
      SignalREventListener.prototype.addServerListUpdateListener = function (listener) {
          return this.connector.getServerListUpdate(listener);
      };
      SignalREventListener.prototype.addResizeFinishedListener = function (listener) {
          return this.connector.onResizeFinished(listener);
      };
      SignalREventListener.prototype.addStartingProgressListener = function (listener) {
          return this.connector.getStartingProgress(listener);
      };
      SignalREventListener.prototype.removeServerListUpdateListener = function (listener) {
          return this.connector.getServerListUpdate(null);
      };
      SignalREventListener.prototype.removeResizeFinishedListener = function (listener) {
          return this.connector.onResizeFinished(null);
      };
      SignalREventListener.prototype.removeStartingProgressListener = function (listener) {
          return this.connector.getStartingProgress(null);
      };
      SignalREventListener.prototype.check = function () {
          var _a;
          return (_a = this.connector) === null || _a === void 0 ? void 0 : _a.isConnected;
      };
      SignalREventListener.prototype.close = function () {
      };
      return SignalREventListener;
  }());

  var SignalingFactory = /** @class */ (function () {
      function SignalingFactory() {
      }
      Object.defineProperty(SignalingFactory, "connector", {
          get: function () {
              if (!this._connector) {
                  this._connector = new SignalRConnector();
              }
              return this._connector;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(SignalingFactory, "eventListener", {
          get: function () {
              if (!this._eventListener) {
                  this._eventListener = new SignalREventListener(SignalingFactory.connector);
              }
              return this._eventListener;
          },
          enumerable: false,
          configurable: true
      });
      return SignalingFactory;
  }());
  window.addEventListener('beforeunload', function (e) {
      var _a;
      // avoid console error on browser refresh
      (_a = SignalingFactory.eventListener) === null || _a === void 0 ? void 0 : _a.close();
  });

  var ServerListing = /** @class */ (function () {
      function ServerListing() {
          this.sleep = function (msec) { return new Promise(function (resolve) { return setTimeout(resolve, msec); }); };
          this.onServerListChanged = function (list) { };
          this.onStartingProgress = function (instanceId, status, errorMessage) { };
          this.isConnected = false;
          this.pingInterval = 30000;
          this._data = {};
          this.servers = [];
          this.iceConfig = {};
          this.checkSum = 0;
          this._showInstances = false;
          this.onServerListChanged = function (list) { };
          this.onStartingProgress = function (instanceId, status, errorMessage) { };
      }
      Object.defineProperty(ServerListing.prototype, "data", {
          get: function () {
              return this._data;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ServerListing.prototype, "showInstances", {
          get: function () {
              return this._showInstances;
          },
          enumerable: false,
          configurable: true
      });
      ServerListing.prototype.getIceServersConfig = function () {
          return __awaiter(this, void 0, void 0, function () {
              var res, data;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          console.log('getting config');
                          return [4 /*yield*/, SignalingFactory.connector.getIceServersConfig()
                                  .catch(function (e) {
                                  console.warn('Exception while trying to get config from server: ' + e);
                              })];
                      case 1:
                          res = _a.sent();
                          if (!(!res || !res.ok)) return [3 /*break*/, 2];
                          console.log('/servers failed');
                          return [3 /*break*/, 4];
                      case 2: return [4 /*yield*/, res.json()];
                      case 3:
                          data = _a.sent();
                          this.iceConfig = data.config;
                          console.log('Got config from server');
                          _a.label = 4;
                      case 4: return [2 /*return*/];
                  }
              });
          });
      };
      ServerListing.prototype.startPolling = function () {
          this.checkSum = 0;
          this.loopGetServers();
      };
      ServerListing.prototype.stopPolling = function () {
          SignalingFactory.eventListener.removeServerListUpdateListener(this.updateServerList)
              .then(function () { return console.log('successfully stopped ServerListUpdateListener'); })
              .catch(function (e) { return console.warn(e); });
          this.isConnected = false;
      };
      ServerListing.prototype.changeFilter = function (filter) {
          this._showInstances = filter;
          console.log('changing server filter to ' + filter);
          this.updateServerList(null);
      };
      ServerListing.prototype.loopGetServers = function () {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, SignalingFactory.eventListener.addServerListUpdateListener(this.updateServerList)];
                      case 1:
                          _a.sent();
                          console.log('starting watching for servers');
                          this.isConnected = true;
                          _a.label = 2;
                      case 2:
                          if (!this.isConnected) return [3 /*break*/, 5];
                          return [4 /*yield*/, this.updateServerList(null)];
                      case 3:
                          _a.sent();
                          return [4 /*yield*/, this.sleep(this.pingInterval)];
                      case 4:
                          _a.sent();
                          return [3 /*break*/, 2];
                      case 5:
                          console.log('Paused looking for updates (OK)');
                          return [2 /*return*/];
                  }
              });
          });
      };
      ServerListing.prototype.buildModelCheckSum = function (s) {
          var str = "".concat(s.upvInstanceId, ";").concat(s.available, ";").concat(s.model.path, ";").concat(s.model.name);
          var sum = hashCode(str);
          return sum;
      };
      ServerListing.prototype.processModels = function (data) {
          var newList = data.models;
          var checkSum = 0;
          newList.forEach(function (s) { return checkSum += serverListing.buildModelCheckSum(s); });
          if (serverListing.checkSum !== checkSum) {
              var output = 'Model list changes found ';
              console.log(output);
              serverListing.onServerListChanged(data);
          }
          serverListing.checkSum = checkSum;
      };
      ServerListing.prototype.updateServerList = function (event) {
          return __awaiter(this, void 0, void 0, function () {
              var res, data;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, SignalingFactory.connector.getModels(null)
                              .catch(function (e) {
                              console.warn('Exception while trying to fetch active servers: ' + e);
                          })];
                      case 1:
                          res = _a.sent();
                          if (!(!res || !res.ok)) return [3 /*break*/, 2];
                          console.log('/servers failed');
                          return [3 /*break*/, 5];
                      case 2: return [4 /*yield*/, res.json()];
                      case 3:
                          data = _a.sent();
                          if (data && data.models) {
                              serverListing.processModels(data);
                          }
                          else {
                              console.warn("Don't know how to deal with server response from GET models: ", data);
                          }
                          serverListing.servers = data;
                          if (!!SignalingFactory.eventListener.check()) return [3 /*break*/, 5];
                          return [4 /*yield*/, SignalingFactory.eventListener.addServerListUpdateListener(this.updateServerList)];
                      case 4:
                          _a.sent();
                          _a.label = 5;
                      case 5: return [2 /*return*/];
                  }
              });
          });
      };
      ServerListing.prototype.startInstance = function (modelPath, progressCallback) {
          return __awaiter(this, void 0, void 0, function () {
              var width, height, eventData, bodyJson, message, res, data, status_1;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          width = getWindowWidth();
                          height = getWindowHeight();
                          eventData = {
                              'clientId': SignalingFactory.connector.clientId,
                              'modelPath': modelPath,
                              'width': width,
                              'height': height
                          };
                          bodyJson = JSON.stringify(eventData);
                          console.log("starting instance:", bodyJson);
                          message = "Cannot start instance for ".concat(modelPath, "! ");
                          return [4 /*yield*/, SignalingFactory.connector.sendStartInstanceCommand(bodyJson)];
                      case 1:
                          res = _a.sent();
                          return [4 /*yield*/, res.json()];
                      case 2:
                          data = _a.sent();
                          console.log("response for starting instance:", data);
                          if (data) {
                              if (data.startCommand) {
                                  status_1 = Number.parseInt(data.startCommand.status, 10);
                                  if (status_1 === 4 && data.startCommand.instanceId) {
                                      return [2 /*return*/, data.startCommand];
                                  }
                                  serverListing.onStartingProgress = progressCallback;
                                  return [2 /*return*/, this.waitForInstance()];
                              }
                              else {
                                  message = "".concat(data);
                                  return [2 /*return*/, { 'errorMessage': message }];
                              }
                          }
                          else {
                              message = "".concat(message, " (JSON error)");
                              return [2 /*return*/, { 'errorMessage': message }];
                          }
                  }
              });
          });
      };
      ServerListing.prototype.waitForInstance = function () {
          return __awaiter(this, void 0, void 0, function () {
              var promise;
              var _this = this;
              return __generator(this, function (_a) {
                  console.log("waiting for instance to start");
                  promise = new Promise(function (resolve) { return __awaiter(_this, void 0, void 0, function () {
                      var listener;
                      return __generator(this, function (_a) {
                          switch (_a.label) {
                              case 0:
                                  listener = function (evt) {
                                      var finished = false;
                                      if (evt && evt.data) {
                                          var data = JSON.parse(evt.data);
                                          console.log("waiting for instance, my clientId = ".concat(SignalingFactory.connector.clientId), data);
                                          if (data.clientId && data.clientId === SignalingFactory.connector.clientId) {
                                              var status_2 = 0;
                                              status_2 = Number.parseInt(data.status, 10);
                                              console.log("(".concat(status_2, ") onStartingProgress: ").concat(evt.data), data);
                                              var message = '';
                                              if (!Number.isNaN(status_2)) {
                                                  switch (status_2) {
                                                      case -1:
                                                          message = "Cannot start instance ".concat(data.instanceId, " for ").concat(data.modelPath, ": ").concat(data.errorMessage);
                                                          console.warn("Starting instance failed");
                                                          finished = true;
                                                          break;
                                                      case 1:
                                                          message = "request sent";
                                                          break;
                                                      case 2:
                                                          message = "initializing instance";
                                                          break;
                                                      case 3:
                                                          message = "loading model ".concat(data.modelPath);
                                                          // test code needed for cancel button simulation:
                                                          // message = UiResources.cancelledByUser;
                                                          // data.errorMessage = message;
                                                          // status = -1;
                                                          // finished = true;
                                                          break;
                                                      case 4:
                                                          message = "instance ready to start connection";
                                                          finished = true;
                                                          break;
                                                  }
                                              }
                                              if (serverListing.onStartingProgress) {
                                                  console.log("(".concat(finished, ") ").concat(message, " || instance ").concat(data ? data.instanceId : null, ", client ").concat(data.clientId));
                                                  serverListing.onStartingProgress(message, data.status, data.errorMessage);
                                              }
                                              if (finished) {
                                                  SignalingFactory.eventListener.removeStartingProgressListener(listener);
                                                  resolve(data);
                                              }
                                          }
                                      }
                                      else {
                                          console.warn("something wrong regarding onStartingProgress event", evt);
                                      }
                                  };
                                  return [4 /*yield*/, SignalingFactory.eventListener.addStartingProgressListener(listener)];
                              case 1:
                                  _a.sent();
                                  return [2 /*return*/];
                          }
                      });
                  }); });
                  return [2 /*return*/, promise];
              });
          });
      };
      return ServerListing;
  }());
  var serverListing = new ServerListing();

  /**
   * Simple lookup for text resources. Customization / i18n can be achieved by calling setCustomMessages at start.
   */
  var UiResources = /** @class */ (function () {
      function UiResources() {
      }
      UiResources.setCustomMessages = function (customMessages) {
          UiResources.messages = customMessages;
      };
      /**
       * Retrieves text for key or the key itself if not defined in map.
       * @param key to look up.
       */
      UiResources.getText = function (key) {
          if (!key) {
              console.warn("UiResources: Key is null or undefined");
              return null;
          }
          var s = UiResources.messages.get(key);
          if (!s) {
              console.warn("Key ".concat(key, " is not defined in UiResources"));
              return key;
          }
          else {
              return s;
          }
      };
      UiResources.hasKey = function (key) {
          return UiResources.messages.has(key);
      };
      UiResources.noModelProvided = 'noModelProvided';
      UiResources.setupConnectionFailed = 'setupConnectionFailed';
      UiResources.sessionTerminated = 'sessionTerminated';
      UiResources.noAnswer = 'noAnswer';
      UiResources.stunTurnError = 'stunTurnError';
      UiResources.createSessionRejected = 'createSessionRejected';
      UiResources.sessionTimeout = 'sessionTimeout';
      UiResources.reconnectFailed = 'reconnectFailed';
      UiResources.cancelledByUser = 'cancelledByUser';
      UiResources.fallback = new Map([
          [UiResources.noModelProvided, 'No model provided'],
          [UiResources.setupConnectionFailed, 'Failed to start UPV. Please try again'],
          [UiResources.sessionTerminated, 'Session terminated'],
          [UiResources.noAnswer, 'No answer from UPV. Please try again later'],
          [UiResources.stunTurnError, 'Peer connection to UPV failed! STUN/TURN server appears to be unreachable from your network'],
          [UiResources.createSessionRejected, 'Create session rejected. Please try again'],
          [UiResources.sessionTimeout, 'Your session has expired. Please reconnect'],
          [UiResources.reconnectFailed, 'Unable to reconnect after network error. Please try again'],
          [UiResources.cancelledByUser, 'Loading cancelled by user'],
      ]);
      UiResources.messages = UiResources.fallback;
      return UiResources;
  }());

  /**
   * Controls how to show error message popup and further details if more than one error occured or technical details
   * are available that indicate error reasons but should be hidden at first sight.
   */
  var ErrorDetails = /** @class */ (function () {
      function ErrorDetails() {
          this._allMessages = [];
          this.showCloseButton = true;
      }
      Object.defineProperty(ErrorDetails.prototype, "allMessages", {
          get: function () {
              return this._allMessages;
          },
          set: function (value) {
              this._allMessages = value;
          },
          enumerable: false,
          configurable: true
      });
      ErrorDetails.prototype.addError = function (message) {
          this._allMessages.push(message);
      };
      return ErrorDetails;
  }());

  /**
   * Handles inbound and outbound communication through one dedicated WebRTC data channel.
   *  @abstract
   */
  var BaseChannelHandler = /** @class */ (function () {
      function BaseChannelHandler(dataChannel, onerror) {
          /**
           * [transferId] -> List of message chunks.
           */
          this.chunkLists = new Map();
          this.maxChunkSize = 32000;
          this.channel = dataChannel;
          this.chunkLists = new Map(); // transferId: ArrayList<messageContainer>
          this.onerror = onerror;
      }
      BaseChannelHandler.prototype.getStatus = function () {
          var _a;
          return (_a = this.channel) === null || _a === void 0 ? void 0 : _a.readyState;
      };
      Object.defineProperty(BaseChannelHandler.prototype, "connected", {
          get: function () {
              var _a;
              return ((_a = this.channel) === null || _a === void 0 ? void 0 : _a.readyState) === 'open';
          },
          enumerable: false,
          configurable: true
      });
      BaseChannelHandler.prototype.sendMessage = function (messageJson, messageType, referrerId) {
          var _a;
          var transferId = referrerId ? referrerId : uuidv4();
          var timestamp = new Date().toISOString();
          var chunkCount = Math.ceil(messageJson.length / this.maxChunkSize);
          var chunks = chunkString(messageJson, this.maxChunkSize);
          // for (let i = chunkCount - 1; i >= 0; i--) { // test messages sent in wrong order
          for (var i = 0; i < chunkCount; i++) {
              var jsonChunk = chunks[i];
              var containerMessage = {
                  MessageType: messageType,
                  TimeStamp: timestamp,
                  TransferId: transferId,
                  ChunkIndex: i,
                  TotalChunkCount: chunkCount,
                  Json: jsonChunk
              };
              var data = JSON.stringify(containerMessage);
              try {
                  this.channel.send(data);
              }
              catch (e) {
                  var errorMessage = "sendMessage failed! Error: ".concat(e.message);
                  console.warn(errorMessage, e);
                  (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, errorMessage);
              }
          }
          console.log("".concat(messageType, " message sent in ").concat(chunkCount, " chunk(s)"));
      };
      BaseChannelHandler.prototype.sendMessageAsync = function (messageJson, messageType, referrerId) {
          var _this = this;
          var transferId = referrerId ? referrerId : uuidv4();
          var timestamp = new Date().toISOString();
          var chunkCount = Math.ceil(messageJson.length / this.maxChunkSize);
          var chunks = chunkString(messageJson, this.maxChunkSize);
          var runAsync = new Promise(function (resolve) { return __awaiter(_this, void 0, void 0, function () {
              var until, _loop_1, this_1, i;
              var _a;
              return __generator(this, function (_b) {
                  switch (_b.label) {
                      case 0:
                          until = function (predicateFunction) {
                              var poll = function (done) { return (predicateFunction() ? done() : setTimeout(function () { return poll(done); }, 500)); };
                              return new Promise(poll);
                          };
                          _loop_1 = function (i) {
                              var jsonChunk, containerMessage, data, channel_1, previousBufferAmount, e_1, errorMessage;
                              return __generator(this, function (_c) {
                                  switch (_c.label) {
                                      case 0:
                                          jsonChunk = chunks[i];
                                          containerMessage = {
                                              MessageType: messageType,
                                              TimeStamp: timestamp,
                                              TransferId: transferId,
                                              ChunkIndex: i,
                                              TotalChunkCount: chunkCount,
                                              Json: jsonChunk
                                          };
                                          data = JSON.stringify(containerMessage);
                                          _c.label = 1;
                                      case 1:
                                          _c.trys.push([1, 3, , 4]);
                                          channel_1 = this_1.channel;
                                          channel_1.send(data);
                                          previousBufferAmount = channel_1.bufferedAmount;
                                          return [4 /*yield*/, until(function () { return channel_1.bufferedAmount < 1000000; })];
                                      case 2:
                                          _c.sent();
                                          if (previousBufferAmount !== channel_1.bufferedAmount) {
                                              console.log("chunk #".concat(i, ": waited until bufferedAmount decreases from ").concat(previousBufferAmount, " to ").concat(channel_1.bufferedAmount));
                                          }
                                          return [3 /*break*/, 4];
                                      case 3:
                                          e_1 = _c.sent();
                                          errorMessage = "sendMessage failed! Error: ".concat(e_1.message);
                                          console.warn(errorMessage, e_1);
                                          (_a = this_1.onerror) === null || _a === void 0 ? void 0 : _a.call(this_1, errorMessage);
                                          return [3 /*break*/, 4];
                                      case 4: return [2 /*return*/];
                                  }
                              });
                          };
                          this_1 = this;
                          i = 0;
                          _b.label = 1;
                      case 1:
                          if (!(i < chunkCount)) return [3 /*break*/, 4];
                          return [5 /*yield**/, _loop_1(i)];
                      case 2:
                          _b.sent();
                          _b.label = 3;
                      case 3:
                          i++;
                          return [3 /*break*/, 1];
                      case 4:
                          resolve("");
                          return [2 /*return*/];
                  }
              });
          }); });
          runAsync.then(function (errMsg) { return console.log("".concat(messageType, " message sent asynchronously in ").concat(chunkCount, " chunk(s)")); });
      };
      BaseChannelHandler.prototype.extractInnerMessageFromChunks = function (messageWrapper) {
          var jsonData;
          var transferId = messageWrapper.TransferId;
          if (messageWrapper.TotalChunkCount === 1) {
              jsonData = messageWrapper.Json;
          }
          else {
              if (!this.chunkLists.has(transferId)) {
                  this.chunkLists.set(transferId, []);
              }
              var chunks = this.chunkLists.get(transferId);
              chunks.push(messageWrapper);
              if (chunks.length >= messageWrapper.TotalChunkCount) {
                  jsonData = '';
                  Array.from(chunks).sort(function (a, b) {
                      return a.ChunkIndex - b.ChunkIndex;
                  }).forEach(function (value) { return jsonData += value.Json; });
                  this.chunkLists.delete(transferId);
                  console.log("processing ".concat(chunks.length, " chunks. Got ").concat(jsonData.length, " bytes"));
              }
          }
          return jsonData ? JSON.parse(jsonData) : null;
      };
      return BaseChannelHandler;
  }());

  var BackLinkChannelHandler = /** @class */ (function (_super) {
      __extends(BackLinkChannelHandler, _super);
      function BackLinkChannelHandler(dataChannel, onerror) {
          var _this_1 = _super.call(this, dataChannel, onerror) || this;
          var _this = _this_1;
          _this_1.channel.onopen = function (event) {
              console.log("Back link channel open", event);
          };
          _this_1.channel.onmessage = function (event) {
              _this.parseEvent(JSON.parse(event.data));
          };
          _this_1.channel.onerror = function (event) {
              console.warn('Error on back link channel', event);
          };
          return _this_1;
      }
      BackLinkChannelHandler.prototype.parseEvent = function (messageWrapper) {
          console.log("Back link channel ".concat(messageWrapper.MessageType, ": ").concat(messageWrapper.TransferId, ", (").concat(messageWrapper.ChunkIndex, "/").concat(messageWrapper.TotalChunkCount, ") JSON data: ").concat(messageWrapper.Json ? messageWrapper.Json.length : -1, " bytes"));
          switch (messageWrapper.MessageType) {
              case 'StreamingClientDownloadMessage':
                  this.downloadFile(messageWrapper);
                  break;
              case 'OpenFileRemoteMessage':
                  this.uploadFile(messageWrapper);
                  break;
              case 'OpenBrowserWindowRemoteMessage':
                  this.openUrl(messageWrapper);
                  break;
              case 'OpenMailToRemoteMessage':
                  this.openMailTo(messageWrapper);
                  break;
          }
      };
      /**
       * Extracts OpenMailToRemoteMessage and uses Mailto and optional Body to open local mail client.
       * @param messageWrapper of type OpenMailToRemoteMessage.
       */
      BackLinkChannelHandler.prototype.openMailTo = function (messageWrapper) {
          var _this_1 = this;
          var _a;
          var message = this.extractInnerMessageFromChunks(messageWrapper);
          if (!message) {
              return;
          }
          if (!message.MailtoUrl) {
              console.warn("OpenMailToRemoteMessage has no mailto link to open");
              return;
          }
          if (message.Body) {
              var clipboard = navigator.clipboard;
              if (clipboard) {
                  clipboard.writeText(message.Body).then(function () {
                      var _a;
                      var mailtoWindow = window.open(message.MailtoUrl, '_blank');
                      if (!mailtoWindow) {
                          var warningMessage = "Cannot open Mail client, probably due to browser's popup blocker! Ensure that popups are allowed for this site";
                          console.warn(warningMessage);
                          (_a = _this_1.onerror) === null || _a === void 0 ? void 0 : _a.call(_this_1, warningMessage);
                          alert(warningMessage);
                      }
                  }).catch(function (e) {
                      var _a;
                      var warningMessage = "Failed to write body to clipboard. System does not allow access to clipboard";
                      console.warn(warningMessage, e);
                      (_a = _this_1.onerror) === null || _a === void 0 ? void 0 : _a.call(_this_1, warningMessage);
                      alert(warningMessage);
                  });
              }
              else {
                  var clipboardWarning = 'Access to clipboard is only available from secure origins or localhost';
                  (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, clipboardWarning);
                  alert(clipboardWarning);
              }
          }
          else {
              window.open(message.MailtoUrl, '_blank');
          }
      };
      /**
       * Extracts URL and forwards it to the browser.
       * @param messageWrapper of type OpenBrowserWindowRemoteMessage.
       */
      BackLinkChannelHandler.prototype.openUrl = function (messageWrapper) {
          var message = this.extractInnerMessageFromChunks(messageWrapper);
          if (!message) {
              return;
          }
          if (!message.Url) {
              console.warn("OpenBrowserWindowRemoteMessage has no URL to open");
              return;
          }
          window.open(message.Url, '_blank');
      };
      /**
       * Provide raw data as file in browser downloads. Taken from https://stackoverflow.com/a/30832210/437283
       * @param messageWrapper of type  .
       */
      BackLinkChannelHandler.prototype.downloadFile = function (messageWrapper) {
          var message = this.extractInnerMessageFromChunks(messageWrapper);
          if (!message) {
              return;
          }
          var decoded = base64toBlob(message.Data, message.MimeType);
          var filename = message.FileName;
          var type = message.MimeType;
          var file = new Blob([decoded], { type: type });
          saveToDownload(file, filename);
      };
      /**
       * Show file open and start transmission back to UPV.
       * @param messageWrapper
       */
      BackLinkChannelHandler.prototype.uploadFile = function (messageWrapper) {
          var _this_1 = this;
          var message = this.extractInnerMessageFromChunks(messageWrapper);
          if (!message) {
              return;
          }
          var maxFileSize = message.MaxFileSize;
          openFile(message.Extensions, function (name, size, contents) {
              var _a;
              if (name && contents && size > 0) {
                  if (size > maxFileSize) {
                      var messageSize = "File uploads are currently restricted to ".concat(maxFileSize);
                      console.warn("".concat(messageSize, ", file size = ").concat(size));
                      (_a = _this_1.onerror) === null || _a === void 0 ? void 0 : _a.call(_this_1, messageSize);
                      alert(messageSize);
                      return;
                  }
                  // FileReader.readAsDataURL() provides base64 encoded string but with a preceding data URL declaration
                  // e.g. 'data:*/*;base64,' thus cut off everything to the first comma
                  var base64Data = contents.substr(contents.indexOf(',') + 1);
                  var uploadMessage = { FileName: name, Length: size, Data: base64Data };
                  _this_1.sendMessageAsync(JSON.stringify(uploadMessage), 'StreamingClientUploadMessage', null);
                  console.log('sendMessageAsync triggered');
              }
              else {
                  console.error("Reading file failed: ".concat(name, ", ").concat(size));
              }
          });
      };
      return BackLinkChannelHandler;
  }(BaseChannelHandler));

  /**
   * Counterpart for UPV's RemoteApiCommandMessage.CallbackTypes.
   */
  var ApiMessageCallbackTypes;
  (function (ApiMessageCallbackTypes) {
      ApiMessageCallbackTypes[ApiMessageCallbackTypes["None"] = 0] = "None";
      ApiMessageCallbackTypes[ApiMessageCallbackTypes["Add"] = 1] = "Add";
      ApiMessageCallbackTypes[ApiMessageCallbackTypes["Remove"] = 2] = "Remove";
  })(ApiMessageCallbackTypes || (ApiMessageCallbackTypes = {}));
  /**
   * Wrapper for ApiCommand that will be sent to UPV as "RemoteApiCommandMessage".
   */
  var ApiMessageContainer = /** @class */ (function () {
      function ApiMessageContainer() {
      }
      ApiMessageContainer.createV1 = function (id, command, callbackType) {
          if (callbackType === void 0) { callbackType = ApiMessageCallbackTypes.None; }
          var container = new ApiMessageContainer();
          container.Id = id;
          container.Command = JSON.stringify(command);
          container.CallbackType = callbackType;
          return container;
      };
      ApiMessageContainer.create = function (command, callbackType) {
          if (callbackType === void 0) { callbackType = ApiMessageCallbackTypes.None; }
          var container = new ApiMessageContainer();
          container.Id = command.requestId;
          var apiCommand = ApiCommand.FromCaxApiCommand(command);
          container.Command = JSON.stringify(apiCommand);
          container.CallbackType = callbackType;
          return container;
      };
      return ApiMessageContainer;
  }());
  /**
   * Value object for all fields of an API command.
   */
  var ApiCommand = /** @class */ (function () {
      /**
       * Creates an ApiCommand object that is needed for sendApiCommand.
       * @param command string containing the API command name.
       * @param additionalParameters string or null for additional parameters.
       * @param commandParameters optional array of parameters depending on the command.
       * @param condition optional condition to filter the command.
       * @param conditionCombineMode 'AND', 'OR' or null.
       * @param targetMode 1: ThreeD; 10: Intellipid. Default is ThreeD (1).
       */
      function ApiCommand(command, additionalParameters, commandParameters, condition, conditionCombineMode, targetMode) {
          if (targetMode === void 0) { targetMode = 1; }
          this.Command = command;
          this.AdditionalParameters = additionalParameters;
          this.CommandParameters = commandParameters;
          this.Condition = condition;
          this.ConditionCombineMode = conditionCombineMode;
          this.Model = null;
          // fallback to 1 (ThreeD) if
          this.Target = targetMode === 10 ? 10 : 1;
          this.Source = 0;
      }
      ApiCommand.parseCommandString = function (commandParameters) {
          if (Array.isArray(commandParameters)) {
              return commandParameters;
          }
          else {
              return !(!commandParameters) ? commandParameters.split('!') : null;
          }
      };
      ApiCommand.FromCaxApiCommand = function (cax) {
          var additionalParameters = convertKeysToCSharpStyle(cax.additionalParameters);
          var cmd = new ApiCommand(cax.command, additionalParameters, cax.commandParameters, cax.condition, cax.conditionCombineMode, Number(cax.target));
          return cmd;
      };
      return ApiCommand;
  }());

  var UpvApiResponseCallback = /** @class */ (function () {
      function UpvApiResponseCallback(callback, eventName) {
          this.eventName = eventName;
          this.callback = callback;
      }
      return UpvApiResponseCallback;
  }());
  var CommandChannelHandler = /** @class */ (function (_super) {
      __extends(CommandChannelHandler, _super);
      function CommandChannelHandler(dataChannel, onerror) {
          var _this = _super.call(this, dataChannel, onerror) || this;
          _this._messageType = 'RemoteApiCommandMessage';
          _this.responseListeners = new Map();
          _this.channel.onopen = function (event) {
              console.log("Command channel open", event);
          };
          _this.channel.onmessage = function (event) {
              _this.parseEvent(JSON.parse(event.data));
          };
          _this.channel.onerror = function (event) {
              console.warn('Error on back link channel', event);
          };
          return _this;
      }
      /**
       * Creates a message including ID and sends it.
       * @param apiCommand to execute.
       * @param callback on responses.
       * @param requestId optional preset for ID used for this request. Msut be unique for one API call or a specific
       *   event callback.
       * @returns {{Command: string, Id: number}} the API message containing the command and a referrer ID.
       */
      CommandChannelHandler.prototype.sendApiCommand = function (apiCommand, callback, requestId) {
          requestId = requestId !== null && requestId !== void 0 ? requestId : createRandomInt32();
          var apiMessage = ApiMessageContainer.createV1(requestId, apiCommand);
          this.sendMessage(JSON.stringify(apiMessage), this._messageType, null);
          if (callback) {
              var listener = new UpvApiResponseCallback(callback);
              this.responseListeners.set("".concat(requestId), listener);
          }
          return apiMessage;
      };
      CommandChannelHandler.prototype.sendApiCommandAsync = function (apiCommand, requestId) {
          return __awaiter(this, void 0, void 0, function () {
              var apiMessage, promise;
              var _this = this;
              return __generator(this, function (_a) {
                  requestId = requestId !== null && requestId !== void 0 ? requestId : createRandomInt32();
                  apiMessage = ApiMessageContainer.createV1(requestId, apiCommand);
                  this.sendMessage(JSON.stringify(apiMessage), this._messageType, null);
                  promise = new Promise(function (resolve) {
                      var callback = function (m) {
                          resolve(m);
                      };
                      var listener = new UpvApiResponseCallback(callback);
                      _this.responseListeners.set("".concat(apiMessage.Id), listener);
                  });
                  return [2 /*return*/, promise];
              });
          });
      };
      /**
       * New UPD-API v2 support
       * @param command to send via {CommandChannelHandler}.
       */
      CommandChannelHandler.prototype.sendCommand = function (command) {
          return __awaiter(this, void 0, void 0, function () {
              var requestId, apiMessage, apiMessageJson, promise;
              var _this = this;
              return __generator(this, function (_a) {
                  requestId = command.requestId;
                  apiMessage = ApiMessageContainer.create(command);
                  apiMessageJson = JSON.stringify(apiMessage);
                  // console.log(`sending command for new API`, apiMessageJson);
                  this.sendMessage(apiMessageJson, this._messageType, "".concat(requestId));
                  promise = new Promise(function (resolve) {
                      var callback = function (m) {
                          resolve(m);
                      };
                      var listener = new UpvApiResponseCallback(callback);
                      _this.responseListeners.set("".concat(requestId), listener);
                  });
                  return [2 /*return*/, promise];
              });
          });
      };
      CommandChannelHandler.prototype.addEventCallback = function (eventName, callback, requestId) {
          // remove any existing listeners, double check for ID and event
          if (requestId && this.responseListeners.has(requestId)) {
              console.warn("found another callback (".concat(requestId, ") for ID ").concat(requestId, " that will be removed before adding"));
              this.removeEventCallback(null, requestId);
          }
          var idForEventName = this.getIdForEventName(eventName);
          if (idForEventName) {
              console.warn("found another callback (".concat(idForEventName, ") for event name ").concat(eventName, " that will be removed before adding"));
              this.removeEventCallback(eventName);
          }
          requestId = requestId !== null && requestId !== void 0 ? requestId : createRandomInt32();
          var command = new ApiCommand('AddEventCallback', null, [eventName, requestId]);
          var apiMessage = ApiMessageContainer.createV1(requestId, command, ApiMessageCallbackTypes.Add);
          this.sendMessage(JSON.stringify(apiMessage), this._messageType, null);
          if (callback) {
              var listener = new UpvApiResponseCallback(callback, eventName);
              this.responseListeners.set("".concat(requestId), listener);
          }
          return requestId;
      };
      CommandChannelHandler.prototype.removeEventCallback = function (eventName, requestId) {
          var command;
          if (requestId && this.responseListeners.has(requestId)) {
              command = new ApiCommand('RemoveEventCallback', null, [requestId]);
              this.responseListeners.delete(requestId);
          }
          else if (eventName) {
              requestId = this.getIdForEventName(eventName);
              if (requestId) {
                  command = new ApiCommand('RemoveEventCallback', null, [requestId]);
                  this.responseListeners.delete(requestId);
              }
              else {
                  console.warn("no event callback found for event ".concat(eventName));
              }
          }
          else {
              console.warn("no event callback found for ID ".concat(requestId));
          }
          if (command) {
              var apiMessage = ApiMessageContainer.createV1(requestId, command, ApiMessageCallbackTypes.Remove);
              this.sendMessage(JSON.stringify(apiMessage), this._messageType, null);
          }
      };
      CommandChannelHandler.prototype.getIdForEventName = function (eventName) {
          var idForEvent;
          this.responseListeners.forEach((function (value, key) {
              if (value.eventName === eventName) {
                  idForEvent = key;
              }
          }));
          return idForEvent;
      };
      /**
       * Internally used to dispatch messages to appropriate methods.
       * @param messageWrapper message container.
       */
      CommandChannelHandler.prototype.parseEvent = function (messageWrapper) {
          console.log("Command channel ".concat(messageWrapper.MessageType, ": ").concat(messageWrapper.TransferId, ", (").concat(messageWrapper.ChunkIndex, "/").concat(messageWrapper.TotalChunkCount, ")")
              + "JSON data: ".concat(messageWrapper.Json ? messageWrapper.Json.length : -1, " bytes"));
          switch (messageWrapper.MessageType) {
              case 'RemoteApiResponseMessage':
                  this.processApiResponse(messageWrapper);
                  break;
              default:
                  console.warn("Unknown message type '".concat(messageWrapper.MessageType, "'"));
                  break;
          }
      };
      CommandChannelHandler.prototype.processApiResponse = function (messageWrapper) {
          var message = this.extractInnerMessageFromChunks(messageWrapper);
          if (!message) {
              return;
          }
          var referrerId = message.ReferrerId;
          if (this.responseListeners.has(referrerId)) {
              var callback = this.responseListeners.get(referrerId);
              callback.callback(message);
              if (!callback.eventName) {
                  this.responseListeners.delete(referrerId);
              }
          }
      };
      return CommandChannelHandler;
  }(BaseChannelHandler));

  var InputChannelHandler = /** @class */ (function (_super) {
      __extends(InputChannelHandler, _super);
      function InputChannelHandler(dataChannel, openCallback, onerror) {
          var _this = _super.call(this, dataChannel, onerror) || this;
          _this.lastActivityTime = Date.now();
          _this.onfocusInfo = function (e) { };
          _this.onfocusInfo = function (e) { };
          _this.channel.onopen = function (event) {
              console.log("Input channel open", event);
              openCallback(event);
          };
          _this.channel.onmessage = function (event) {
              _this.parseEvent(JSON.parse(event.data));
          };
          _this.channel.onerror = function (event) {
              console.warn('Error on input channel', event);
          };
          return _this;
      }
      /**
       * Creates a message including ID and sends it.
       * @param msg to send.
       */
      InputChannelHandler.prototype.sendMsg = function (msg) {
          if (this.channel == null) {
              return;
          }
          this.lastActivityTime = Date.now();
          switch (this.channel.readyState) {
              case 'connecting':
                  break;
              case 'open':
                  this.channel.send(msg);
                  break;
              case 'closing':
                  console.log("Attempt to sendMsg message while closing");
                  break;
              case 'closed':
                  console.log("Attempt to sendMsg message while connection closed.");
                  break;
          }
      };
      /**
       * Internally used to dispatch messages to appropriate methods.
       * @param containerMessage message container.
       */
      InputChannelHandler.prototype.parseEvent = function (containerMessage) {
          // console.log(`Input channel ${messageWrapper.MessageType}: ${messageWrapper.TransferId}, (${messageWrapper.ChunkIndex}/${messageWrapper.TotalChunkCount}) JSON data: ${messageWrapper.Json ? messageWrapper.Json.length : -1} bytes`);
          switch (containerMessage.MessageType) {
              case 'UiFocusInfoMessage':
                  var message = this.extractInnerMessageFromChunks(containerMessage);
                  this.onfocusInfo(message);
                  break;
              default:
                  console.warn("Unknown message type '".concat(containerMessage.MessageType, "'"));
                  break;
          }
      };
      return InputChannelHandler;
  }(BaseChannelHandler));

  var ClipboardChannelHandler = /** @class */ (function (_super) {
      __extends(ClipboardChannelHandler, _super);
      function ClipboardChannelHandler(dataChannel, onerror) {
          var _this = _super.call(this, dataChannel, onerror) || this;
          _this.lastActivityTime = Date.now();
          _this.onsetRemoteClipboardContent = function (e) { };
          _this.onsetRemoteClipboardContent = function (e) { };
          _this.channel.onopen = function (event) {
              console.log("Clipboard channel open", event);
          };
          _this.channel.onmessage = function (event) {
              _this.parseEvent(JSON.parse(event.data));
          };
          _this.channel.onerror = function (event) {
              console.warn('Error on Clipboard channel', event);
          };
          return _this;
      }
      /**
       * Internally used to dispatch messages to appropriate methods.
       * @param containerMessage message container.
       */
      ClipboardChannelHandler.prototype.parseEvent = function (containerMessage) {
          // console.log(`Input channel ${messageWrapper.MessageType}: ${messageWrapper.TransferId}, (${messageWrapper.ChunkIndex}/${messageWrapper.TotalChunkCount}) JSON data: ${messageWrapper.Json ? messageWrapper.Json.length : -1} bytes`);
          switch (containerMessage.MessageType) {
              case 'ClipboardMessage':
                  var message = this.extractInnerMessageFromChunks(containerMessage);
                  // console.log(message);
                  this.onsetRemoteClipboardContent(message);
                  break;
              default:
                  console.warn("Unknown message type '".concat(containerMessage.MessageType, "'"));
                  break;
          }
      };
      return ClipboardChannelHandler;
  }(BaseChannelHandler));

  var GpsChannelHandler = /** @class */ (function (_super) {
      __extends(GpsChannelHandler, _super);
      function GpsChannelHandler(dataChannel, onerror) {
          var _this = _super.call(this, dataChannel, onerror) || this;
          _this.lastActivityTime = Date.now();
          _this.channel.onopen = function (event) {
              console.log("Gps channel open", event);
          };
          _this.channel.onmessage = function (event) {
              _this.parseEvent(JSON.parse(event.data));
          };
          _this.channel.onerror = function (event) {
              console.warn('Error on Gps channel', event);
          };
          return _this;
      }
      /**
       * Internally used to dispatch messages to appropriate methods.
       * @param containerMessage message container.
       */
      GpsChannelHandler.prototype.parseEvent = function (containerMessage) {
          var _this = this;
          switch (containerMessage.MessageType) {
              case 'GpsMessage':
                  navigator.geolocation.getCurrentPosition(function (position) {
                      var gpsMessage = {
                          Latitude: position.coords.latitude,
                          Longitude: position.coords.longitude,
                          Altitude: position.coords.altitude,
                          Heading: position.coords.heading
                      };
                      _this.sendMessage(JSON.stringify(gpsMessage), 'GpsMessage', null);
                      // console.log(`Position: lat-${position.coords.latitude}, long-${position.coords.longitude}, altt-${position.coords.altitude}, bear-${position.coords.heading}`);
                  }, function (positionError) {
                      var gpsMessage = {
                          ErrorMessage: positionError.message
                      };
                      _this.sendMessage(JSON.stringify(gpsMessage), 'GpsMessage', null);
                  });
                  break;
              default:
                  console.warn("Unknown message type '".concat(containerMessage.MessageType, "'"));
                  break;
          }
      };
      return GpsChannelHandler;
  }(BaseChannelHandler));

  var MediaDeviceChannelHandler = /** @class */ (function (_super) {
      __extends(MediaDeviceChannelHandler, _super);
      function MediaDeviceChannelHandler(dataChannel, onerror) {
          var _this = _super.call(this, dataChannel, onerror) || this;
          _this.lastActivityTime = Date.now();
          _this.onMediaDeviceMessage = function (e) { };
          _this.onMediaDeviceMessage = function (e) { };
          _this.channel.onopen = function (event) {
              console.log("Media device channel open", event);
          };
          _this.channel.onmessage = function (event) {
              _this.parseEvent(JSON.parse(event.data));
          };
          _this.channel.onerror = function (event) {
              console.warn('Error on media device channel', event);
          };
          return _this;
      }
      /**
       * Internally used to dispatch messages to appropriate methods.
       * @param containerMessage message container.
       */
      MediaDeviceChannelHandler.prototype.parseEvent = function (containerMessage) {
          switch (containerMessage.MessageType) {
              case 'MediaDeviceInfoMessage':
                  this.sendMediaDeviceInfo();
                  break;
              case 'MediaDeviceMessage':
                  var e = this.extractInnerMessageFromChunks(containerMessage);
                  this.onMediaDeviceMessage(e);
                  break;
              default:
                  console.warn("Unknown message type '".concat(containerMessage.MessageType, "'"));
                  break;
          }
      };
      MediaDeviceChannelHandler.prototype.sendMediaDeviceInfo = function () {
          var _this = this;
          navigator.mediaDevices.enumerateDevices().then(function (deviceInfos) {
              var idVideo = [];
              var idAudio = [];
              for (var i = 0; i !== deviceInfos.length; ++i) {
                  var deviceInfo = deviceInfos[i];
                  if (deviceInfo.kind === 'audioinput') {
                      console.log('Found audio-input: ', deviceInfo.label);
                      idAudio.push(deviceInfo.deviceId);
                  }
                  else if (deviceInfo.kind === 'videoinput') {
                      console.log('Found video-input: ', deviceInfo.label, deviceInfo.deviceId);
                      idVideo.push(deviceInfo.deviceId);
                  }
                  else {
                      console.log('Found another kind of device: ', deviceInfo.label);
                  }
              }
              var message = {
                  VideoDeviceIds: idVideo,
                  AudioDeviceIds: idAudio
              };
              _this.sendMessage(JSON.stringify(message), 'MediaDeviceInfoMessage', null);
          });
      };
      return MediaDeviceChannelHandler;
  }(BaseChannelHandler));

  var AuthenticationChannelHandler = /** @class */ (function (_super) {
      __extends(AuthenticationChannelHandler, _super);
      function AuthenticationChannelHandler(dataChannel, onerror) {
          var _this = _super.call(this, dataChannel, onerror) || this;
          _this.lastActivityTime = Date.now();
          _this._userManagers = new Map();
          _this.channel.onopen = function (event) {
              console.log("Authentication channel open", event);
          };
          _this.channel.onmessage = function (event) {
              _this.parseEvent(JSON.parse(event.data));
          };
          _this.channel.onerror = function (event) {
              console.warn('Error on authentication channel', event);
          };
          return _this;
      }
      /**
       * Internally used to dispatch messages to appropriate methods.
       * @param containerMessage message container.
       */
      AuthenticationChannelHandler.prototype.parseEvent = function (containerMessage) {
          var _this = this;
          switch (containerMessage.MessageType) {
              case 'AuthenticationRequestMessage':
                  {
                      console.log('Received AuthenticationRequestMessage: ', containerMessage);
                      var request_1 = JSON.parse(containerMessage.Json);
                      var response_1 = this.createResponse(request_1);
                      signInPopup(request_1.OidcConfig).then(function (result) {
                          console.log('signinPopup result', result);
                          response_1.AuthenticationContextId = request_1.AuthenticationContextId;
                          if (result.errorMessage == null) {
                              _this._userManagers.set(request_1.AuthenticationContextId, result.userManager);
                              //is called on every change of the user (this includes an updated AccessToken)
                              var callback_1 = function (r) {
                                  var eventResponse = _this.createResponse(containerMessage.Json);
                                  eventResponse.AuthenticationContextId = request_1.AuthenticationContextId;
                                  _this.addResult(eventResponse, r);
                                  _this.send(eventResponse);
                              };
                              result.userManager.events.addUserLoaded(callback_1);
                              _this.addResult(response_1, result.user);
                              result.userManager.destroy = function () {
                                  result.userManager.events.removeUserLoaded(callback_1);
                                  result.userManager.stopSilentRenew();
                              };
                          }
                          else {
                              response_1.AuthenticationContextErrorMessage = result.errorMessage;
                          }
                          _this.send(response_1);
                      });
                      break;
                  }
              case 'AuthenticationSignOutMessage':
                  {
                      console.log('Received AuthenticationSignOutMessage: ', containerMessage);
                      var request = JSON.parse(containerMessage.Json);
                      //sending back a result would be possible here
                      //as the UnityClient implementation has no simple way of issuing a callback this is omitted here as well
                      var userManager = this._userManagers.get(request.AuthenticationContextId);
                      if (userManager == null) {
                          throw "No oidc handler found for AuthenticationSignOutMessage: " + JSON.stringify(request);
                      }
                      else {
                          userManager.signoutPopup().then(function () { return console.log('signed out'); });
                          console.log('signoutPopup was issued for: ' + request.AuthenticationContextId);
                      }
                      break;
                  }
              case 'AuthenticationCloseMessage':
                  {
                      console.log('Received AuthenticationCloseMessage: ', containerMessage);
                      var authenticationCloseMessage = JSON.parse(containerMessage.Json);
                      var userManager = this._userManagers.get(authenticationCloseMessage.AuthenticationContextId);
                      if (userManager == null) {
                          throw "No oidc handler found for AuthenticationCloseMessage: " + JSON.stringify(authenticationCloseMessage);
                      }
                      else {
                          userManager.destroy();
                          this._userManagers.delete(authenticationCloseMessage.AuthenticationContextId);
                          console.log("Authentication context was removed: " + authenticationCloseMessage.AuthenticationContextId);
                      }
                      break;
                  }
              default:
                  {
                      console.warn("Unknown message type '".concat(containerMessage.MessageType, "'"));
                      break;
                  }
          }
      };
      AuthenticationChannelHandler.prototype.createResponse = function (request) {
          return {
              AuthenticationContextId: request.AuthenticationContextId,
              AccessToken: null,
              IdentityToken: null,
              ExpiresIn: 0,
              AuthenticationContextErrorMessage: null
          };
      };
      AuthenticationChannelHandler.prototype.addResult = function (response, user) {
          if (user) {
              response.AccessToken = user.access_token;
              response.IdentityToken = user.id_token;
              response.ExpiresIn = user.expires_in;
          }
      };
      AuthenticationChannelHandler.prototype.send = function (response) {
          console.log('Sending AuthenticationResponseMessage... ', response);
          this.sendMessage(JSON.stringify(response), 'AuthenticationResponseMessage', null);
      };
      return AuthenticationChannelHandler;
  }(BaseChannelHandler));

  var DefaultVideoConfigProvider = /** @class */ (function () {
      function DefaultVideoConfigProvider() {
      }
      DefaultVideoConfigProvider.prototype.getVideoElementWidth = function () {
          return getWindowWidth();
      };
      DefaultVideoConfigProvider.prototype.getVideoElementHeight = function () {
          return getWindowHeight();
      };
      return DefaultVideoConfigProvider;
  }());

  /**
   * Handles codec preferences of RTC RTP transceivers.
   */
  var CodecSelector = /** @class */ (function () {
      function CodecSelector() {
      }
      /**
       * Sets the video codec preferences to have the codec basd on the given mime type as first in the list.
       * @param transceivers all active transceivers of the current peer connection.
       * @param preferredMimeType to filter codecs, e.g. 'video/H264', 'video/VP8'. Browser defaults are taken if not set.
       */
      CodecSelector.prototype.changeVideoCodecPreferences = function (transceivers, preferredMimeType) {
          var _this = this;
          if (!preferredMimeType) {
              return;
          }
          if (typeof RTCRtpReceiver.getCapabilities !== 'function') {
              console.warn("RTCRtpReceiver.getCapabilities is undefined");
              return;
          }
          transceivers.forEach(function (transceiver) {
              var kind = transceiver.receiver.track.kind;
              var codecCapabilities = RTCRtpReceiver.getCapabilities(kind).codecs;
              if (kind === 'video') {
                  var codecs = _this.sortCodecsByPreferredMimeType(codecCapabilities, preferredMimeType);
                  if (typeof transceiver.setCodecPreferences !== 'function') {
                      // Firefox (115) has no support; to make this work manipulating sdp string would be needed
                      console.warn("RTCRtpTransceiver.setCodecPreferences is undefined");
                      return;
                  }
                  console.log("Supported video codecs: ", codecs);
                  transceiver.setCodecPreferences(codecs);
              }
          });
      };
      CodecSelector.prototype.sortCodecsByPreferredMimeType = function (codecs, preferredMimeType) {
          var otherCodecs = [];
          var preferredCodecs = [];
          codecs.forEach(function (codec) {
              if (codec.mimeType === preferredMimeType) {
                  preferredCodecs.push(codec);
              }
              else {
                  otherCodecs.push(codec);
              }
          });
          return preferredCodecs.concat(otherCodecs);
      };
      return CodecSelector;
  }());

  /**
   * Responsible for initiating, holding and tear down of the video connection. Connected to signaling server and WebRTC
   * module.
   */
  var SignalRVideoPlayer = /** @class */ (function () {
      function SignalRVideoPlayer(element, config) {
          this.backlinkChannelHandler = null;
          this.isConnected = false;
          this.isReconnecting = false;
          this.lastConnectionState = '';
          this.upvInstanceId = '';
          this.iceCandidatesSendQueue = [];
          this.iceCandidatesReceiveQueue = [];
          this.sleep = function (msec) { return new Promise(function (resolve) { return setTimeout(resolve, msec); }); };
          var _this = this;
          SignalRVideoPlayer.globalInstanceCounter++;
          this.instanceCounter = SignalRVideoPlayer.globalInstanceCounter;
          this.cfg = SignalRVideoPlayer.getConfiguration(config);
          this.videoConfigProvider = new DefaultVideoConfigProvider();
          this.codecSelector = new CodecSelector();
          this.pc = null;
          this.backlinkChannel = null;
          this.backlinkChannelHandler = null;
          this.inputChannelHandlerHandler = null;
          this.clipboardChannelHandler = null;
          this.gpsChannelHandler = null;
          this.mediaDeviceChannelHandler = null;
          this.authenticationChannelHandler = null;
          this.offerOptions = {
              offerToReceiveAudio: true,
              offerToReceiveVideo: true,
          };
          this.video = element;
          // Safari does work not properly with video.muted = true; as seen in inspector
          // s. https://stackoverflow.com/a/54678952/437283
          this.video.setAttribute('autoplay', '');
          this.video.setAttribute('muted', 'muted');
          this.video.setAttribute('playsinline', '');
          // the following line shows the standard Safari controls for play, pause,...
          // but this turned out to work not properly: every mouse click toggles between pause and play
          // this.video.setAttribute('controls', '');
          this.video.addEventListener('loadedmetadata', function (event) {
              console.log("video loadedmetadata event -> start playing", event);
              // needed when loading /connect directly i.e. w/o user interaction, s. https://goo.gl/xX8pDD
              _this.video.muted = true;
              _this.video.play();
              _this.calculateVideoOrigin();
              _this.onconnect();
              _this.allErrorMessages = [];
          }, true);
          this.connectInterval = 1500;
          this.pingInterval = 15000;
          this.connector = SignalingFactory.connector;
          // callbacks
          this.ondisconnect = function () { };
          this.onconnect = function () { };
          this.onStatusUpdate = function (msg, status, errorMessage) { };
          this.onIdleWarning = function (seconds) { };
          this.onClearIdleWarning = function () { };
          this.onerror = function (message, previousMessages) { };
          this.sleep = function (msec) { return new Promise(function (resolve) { return setTimeout(resolve, msec); }); };
          this.isConnecting = true;
          this.allErrorMessages = [];
      }
      Object.defineProperty(SignalRVideoPlayer.prototype, "videoWidth", {
          get: function () {
              return this.video.videoWidth;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(SignalRVideoPlayer.prototype, "videoHeight", {
          get: function () {
              return this.video.videoHeight;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(SignalRVideoPlayer.prototype, "videoOriginX", {
          get: function () {
              return this._videoOriginX;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(SignalRVideoPlayer.prototype, "videoOriginY", {
          get: function () {
              return this._videoOriginY;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(SignalRVideoPlayer.prototype, "videoScale", {
          get: function () {
              return this._videoScale;
          },
          enumerable: false,
          configurable: true
      });
      SignalRVideoPlayer.getConfiguration = function (config) {
          var _a;
          if (config === undefined) {
              config = {};
              config.sdpSemantics = 'unified-plan';
              config.iceServers = [{ urls: ['stun:stun.l.google.com:19302'] }];
          }
          var urls = (_a = config.iceServers) === null || _a === void 0 ? void 0 : _a.map(function (server) { return server.urls.join(', '); }).join(', ');
          console.log("using TURN server(s): ".concat(urls));
          // might improve quality on Chrome
          config.optional = [{ 'googSuspendBelowMinBitrate': true }];
          return config;
      };
      SignalRVideoPlayer.prototype.setupConnection = function (upvInstanceId) {
          return __awaiter(this, void 0, void 0, function () {
              var _this, channel, clipboardChannel, gpsChannel, mediaDeviceChannel, authenticationChannel, createResponse, offer, desc, s;
              var _this_1 = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          _this = this;
                          this.close();
                          this.updateStatus('starting connection for video-player', 100);
                          // Create peerConnection with proxy server and set up handlers
                          this.pc = new RTCPeerConnection(this.cfg);
                          this.pc.onsignalingstatechange = function (e) {
                              console.log('signalingState changed event', e);
                              _this.updateStatus("signalingState changed => ".concat(_this.pc ? _this.pc.signalingState : '(pc closed)'), 110);
                          };
                          this.pc.oniceconnectionstatechange = function (e) {
                              console.log("iceConnectionState changed ".concat(_this.lastConnectionState, " => ").concat(_this.pc.iceConnectionState, ",\n        isReconnecting = ").concat(_this.isReconnecting), e);
                              if (_this.pc.iceConnectionState === 'completed') {
                                  // connected already, indicates that gathering has finished, ignore this and leave lastConnectionState == connected
                                  return;
                              }
                              if (_this.pc.iceConnectionState === 'connected') ;
                              if (_this.pc.iceConnectionState === 'failed') {
                                  // Firefox does not yet (v 85.0) support icecandidateerror events but reports STUN/TURN errors her instead
                                  _this.failWithStunError();
                              }
                              if (_this.pc.iceConnectionState === 'disconnected') {
                                  // happens especially in FF quite often: short disconnects for a 1 - 100 msecs
                                  if (_this.lastConnectionState === 'connected' && !_this.isReconnecting) {
                                      console.warn('trying to reconnect');
                                      _this.updateStatus("trying to reconnect", 105);
                                      _this.isReconnecting = true;
                                  }
                                  else {
                                      _this.ondisconnect();
                                      _this.isConnected = false;
                                  }
                              }
                              else if (_this.pc.iceConnectionState === 'connected') {
                                  if (!_this.isReconnecting) {
                                      _this.idleLoop();
                                  }
                                  else {
                                      _this === null || _this === void 0 ? void 0 : _this.onconnect();
                                      console.log('reconnect of peer connection successful');
                                      _this.isReconnecting = false;
                                  }
                              }
                              else if (_this.pc.iceConnectionState === 'checking') {
                                  _this.updateStatus(null, 130);
                              }
                              _this.lastConnectionState = _this.pc.iceConnectionState;
                          };
                          this.pc.onicegatheringstatechange = function (e) {
                              console.log('iceGatheringState change event', e);
                              _this.updateStatus("iceGatheringState changed -> ".concat(_this.pc.iceGatheringState), 120);
                          };
                          this.pc.ontrack = function (e) {
                              console.log('------------ New track added:', e);
                              _this.updateStatus('New track added:', 140);
                              _this.video.srcObject = e.streams[0];
                          };
                          this.pc.onicecandidate = function (e) {
                              var _a;
                              var candidate = e.candidate;
                              if (((_a = candidate === null || candidate === void 0 ? void 0 : candidate.candidate) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                                  if (_this.pc.remoteDescription) {
                                      _this.connector.sendCandidate(_this.connector.clientId, _this.connectionId, candidate.candidate, candidate.sdpMid, candidate.sdpMLineIndex)
                                          .then(function (dto) { var _a; return console.log("".concat(((_a = dto.errorMessage) === null || _a === void 0 ? void 0 : _a.length) > 0 ? 'Error sending candidate' : 'Success sending', " ").concat(candidate.candidate)); })
                                          .catch(function (exc) { return console.error("Hub error while sending candidate", exc); });
                                  }
                                  else {
                                      console.log("Queueing ".concat(candidate.candidate));
                                      _this.iceCandidatesSendQueue.push(candidate);
                                  }
                              }
                              else {
                                  console.log("Ignoring null candidate", candidate);
                              }
                          };
                          this.pc.onnegotiationneeded = function (ev) { return console.warn("negotiationneeded", ev); };
                          this.pc.addEventListener('icecandidateerror', function (e) {
                              var iceEvent = e;
                              // STUN errors are in the range 300-699. See RFC 5389, section 15.6
                              // for a list of codes. TURN adds a few more error codes; see
                              // RFC 5766, section 15 for details.
                              // >= 700: Server could not be reached; a specific error number is
                              // provided but these are not yet specified.
                              var msg = "ICE candidate error (".concat(iceEvent.errorCode, "): ").concat(iceEvent.errorText, " URL: ").concat(iceEvent.url);
                              console.warn(_this_1.addError(msg, false), e);
                          });
                          channel = this.pc.createDataChannel('data');
                          this.inputChannelHandlerHandler = new InputChannelHandler(channel, function () {
                              _this.updateStatus('Datachannel connected.', 200);
                              _this.isConnecting = false;
                              _this.connector.updatePeerStatus(1);
                          }, this.handleDataChannelErrors);
                          this.backlinkChannel = this.pc.createDataChannel('backlink');
                          this.backlinkChannelHandler = new BackLinkChannelHandler(this.backlinkChannel, this.handleDataChannelErrors);
                          this.commandChannel = this.pc.createDataChannel('commands');
                          this.commandChannelHandler = new CommandChannelHandler(this.commandChannel, this.handleDataChannelErrors);
                          clipboardChannel = this.pc.createDataChannel('clipboard');
                          this.clipboardChannelHandler = new ClipboardChannelHandler(clipboardChannel, this.handleDataChannelErrors);
                          gpsChannel = this.pc.createDataChannel('gps');
                          this.gpsChannelHandler = new GpsChannelHandler(gpsChannel, this.handleDataChannelErrors);
                          mediaDeviceChannel = this.pc.createDataChannel('mediaDevice');
                          this.mediaDeviceChannelHandler = new MediaDeviceChannelHandler(mediaDeviceChannel, this.handleDataChannelErrors);
                          this.mediaDeviceChannelHandler.onMediaDeviceMessage = this.onMediaDeviceMessage.bind(this);
                          authenticationChannel = this.pc.createDataChannel('authentication');
                          this.authenticationChannelHandler = new AuthenticationChannelHandler(authenticationChannel, this.handleDataChannelErrors);
                          return [4 /*yield*/, this.connector.create(upvInstanceId)];
                      case 1:
                          createResponse = _a.sent();
                          if (!(createResponse && createResponse.sessionId)) return [3 /*break*/, 8];
                          this.upvInstanceId = upvInstanceId;
                          this.sessionId = createResponse.sessionId;
                          this.maxClientIdleTime = Number(createResponse.maxIdleTime);
                          console.log("Client session created, ID = ".concat(this.sessionId));
                          return [4 /*yield*/, this.connector.onResizeFinished(function (resizeData) {
                                  _this_1.calculateVideoOrigin();
                              })];
                      case 2:
                          _a.sent();
                          return [4 /*yield*/, this.sendResizeRequest()];
                      case 3:
                          _a.sent();
                          this.pc.addTransceiver('video', { direction: 'recvonly' });
                          this.pc.addTransceiver('audio', { direction: 'recvonly' });
                          this.codecSelector.changeVideoCodecPreferences(this.pc.getTransceivers(), createResponse.preferredVideoCodec);
                          return [4 /*yield*/, this.pc.createOffer(this.offerOptions)];
                      case 4:
                          offer = _a.sent();
                          return [4 /*yield*/, this.createConnection()];
                      case 5:
                          _a.sent();
                          desc = new RTCSessionDescription({ sdp: offer.sdp, type: 'offer' });
                          return [4 /*yield*/, this.pc.setLocalDescription(desc)];
                      case 6:
                          _a.sent();
                          console.log('sending offer', desc);
                          return [4 /*yield*/, this.sendOffer(offer, upvInstanceId)];
                      case 7:
                          _a.sent();
                          return [2 /*return*/, null];
                      case 8:
                          s = "Create session rejected ".concat(createResponse === null || createResponse === void 0 ? void 0 : createResponse.statusText);
                          this.addError(s, false);
                          this.updateStatus(s, -1);
                          return [4 /*yield*/, this.sleep(2000)];
                      case 9:
                          _a.sent();
                          return [2 /*return*/, UiResources.createSessionRejected];
                  }
              });
          });
      };
      SignalRVideoPlayer.prototype.sendResizeRequest = function () {
          return __awaiter(this, void 0, void 0, function () {
              var tempDivElement, devicePixelRatio, dpi_y, w, h, diagonal, size, resizingData;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          tempDivElement = document.createElement('dpi');
                          tempDivElement.id = 'dpi';
                          tempDivElement.style.height = '1in';
                          tempDivElement.style.width = '1in';
                          tempDivElement.style.left = '100%';
                          tempDivElement.style.top = '100%';
                          tempDivElement.style.position = 'fixed';
                          document.body.appendChild(tempDivElement);
                          devicePixelRatio = window.devicePixelRatio || 1;
                          dpi_y = tempDivElement.offsetHeight * devicePixelRatio;
                          w = window.screen.width * devicePixelRatio;
                          h = window.screen.height * devicePixelRatio;
                          diagonal = Math.sqrt(w * w + h * h);
                          size = diagonal / dpi_y;
                          document.body.removeChild(tempDivElement);
                          resizingData = {
                              clientId: this.sessionId,
                              targetId: this.upvInstanceId,
                              connectionId: this.connectionId,
                              width: this.videoConfigProvider.getVideoElementWidth(),
                              height: this.videoConfigProvider.getVideoElementHeight(),
                              clientWidth: w,
                              clientHeight: h,
                              dpi: dpi_y,
                              sizeInInch: size
                          };
                          return [4 /*yield*/, this.connector.requestResizing(resizingData)];
                      case 1:
                          _a.sent();
                          console.log("resizing request sent for (".concat(resizingData.width, "; ").concat(resizingData.height, ")"));
                          return [2 /*return*/];
                  }
              });
          });
      };
      SignalRVideoPlayer.prototype.handleDataChannelErrors = function (message) {
          var _a;
          (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, message, this.allErrorMessages);
      };
      SignalRVideoPlayer.prototype.forceDisconnect = function () {
          return __awaiter(this, arguments, void 0, function (willReconnect) {
              if (willReconnect === void 0) { willReconnect = false; }
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          this.isConnecting = false;
                          return [4 /*yield*/, this.connector.getAnswer(this.connector.clientId, null)];
                      case 1:
                          _a.sent();
                          return [4 /*yield*/, this.connector.getCandidate(this.connector.clientId, null)];
                      case 2:
                          _a.sent();
                          return [4 /*yield*/, this.connector.onResizeFinished(null)];
                      case 3:
                          _a.sent();
                          this.close();
                          console.log('Forcing disconnect');
                          return [4 /*yield*/, this.connector.delete(this.connector.clientId, willReconnect)];
                      case 4:
                          _a.sent();
                          return [2 /*return*/];
                  }
              });
          });
      };
      SignalRVideoPlayer.prototype.createConnection = function () {
          return __awaiter(this, void 0, void 0, function () {
              var res;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this.connector.createConnection(this.connector.clientId)];
                      case 1:
                          res = _a.sent();
                          this.connectionId = res.connectionId;
                          console.log("createConnection successful, ID: ".concat(this.connectionId));
                          return [2 /*return*/];
                  }
              });
          });
      };
      SignalRVideoPlayer.prototype.sendOffer = function (offer, upvInstanceId) {
          return __awaiter(this, void 0, void 0, function () {
              var waitTime;
              var _this_1 = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this.connector.getAnswer(this.connector.clientId, function (answer) { return _this_1.setAnswer(answer); })];
                      case 1:
                          _a.sent();
                          return [4 /*yield*/, this.connector.getCandidate(this.connector.clientId, function (candidateContainerDto) { return _this_1.setCandidate(candidateContainerDto); })];
                      case 2:
                          _a.sent();
                          return [4 /*yield*/, this.connector.sendOffer(this.connector.clientId, this.connectionId, offer.sdp, upvInstanceId)];
                      case 3:
                          _a.sent();
                          waitTime = 20000;
                          this.sleep(waitTime).then(function () {
                              var _a, _b;
                              if (_this_1.isConnecting) {
                                  var connectionState = _this_1.pc ? ('signalingState = ' + _this_1.pc.signalingState + ', iceConnectionState = ' + _this_1.pc.iceConnectionState) : 'no peer connection';
                                  if ((_a = _this_1.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription) {
                                      if (((_b = _this_1.pc) === null || _b === void 0 ? void 0 : _b.iceConnectionState) !== 'connected') {
                                          var msg = "Timeout after (".concat(waitTime / 1000, " secs. Got answer from UPV but connection could not be established (").concat(connectionState, ")");
                                          console.warn(_this_1.addError(msg, false));
                                          _this_1.failWithStunError();
                                      }
                                  }
                                  else {
                                      var msg = UiResources.noAnswer;
                                      console.warn(_this_1.addError("No remote description, connection state: ".concat(connectionState), false));
                                      _this_1.addError(msg, true);
                                  }
                                  _this_1.isConnecting = false;
                              }
                              _this_1.connector.getAnswer(_this_1.connector.clientId, null);
                              _this_1.connector.getCandidate(_this_1.connector.clientId, null);
                          });
                          return [2 /*return*/];
                  }
              });
          });
      };
      SignalRVideoPlayer.prototype.setAnswer = function (answer) {
          return __awaiter(this, void 0, void 0, function () {
              var sdp, desc;
              var _this_1 = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          sdp = answer.sdp;
                          desc = new RTCSessionDescription({ sdp: sdp, type: 'answer' });
                          if (!this.pc.remoteDescription) return [3 /*break*/, 3];
                          console.log('Ignoring remote description because it\'s set already');
                          if (!(this.pc.signalingState !== 'stable')) return [3 /*break*/, 2];
                          console.log('Got answer, setting RemoteDescription ', this.pc.signalingState, desc);
                          return [4 /*yield*/, this.pc.setRemoteDescription(desc).catch(function (e) { return console.warn('Failed to setRemoteDescription: (' + desc + '):' + e); })];
                      case 1:
                          _a.sent();
                          _a.label = 2;
                      case 2: return [3 /*break*/, 5];
                      case 3:
                          console.log('Got answer, setting RemoteDescription ', desc);
                          return [4 /*yield*/, this.pc.setRemoteDescription(desc)
                                  .then(function () {
                                  // TODO kay: optimisation when polling is removed completely, connection can be set up with both IDs from
                                  //           start and all candidates can be sent immediately
                                  if (_this_1.iceCandidatesSendQueue.length > 0) {
                                      console.log("candidates send queue contains ".concat(_this_1.iceCandidatesSendQueue.length, " items"));
                                      _this_1.iceCandidatesSendQueue.forEach(function (candidate) { return _this_1.connector.sendCandidate(_this_1.connector.clientId, _this_1.connectionId, candidate.candidate, candidate.sdpMid, candidate.sdpMLineIndex)
                                          .then(function (dto) { var _a; return console.log("".concat(((_a = dto.errorMessage) === null || _a === void 0 ? void 0 : _a.length) > 0 ? 'Error sending queued candidate' : 'Sent', " : ").concat(candidate.candidate)); })
                                          .catch(function (exc) { return console.error(_this_1.addError("Hub error while sending candidates from queue: ".concat(exc.message), false), exc); }); });
                                      _this_1.iceCandidatesSendQueue = [];
                                  }
                                  if (_this_1.iceCandidatesReceiveQueue.length > 0) {
                                      console.log("candidates receive queue contains ".concat(_this_1.iceCandidatesReceiveQueue.length, " items"));
                                      _this_1.iceCandidatesReceiveQueue.forEach(function (candidate) {
                                          _this_1.pc.addIceCandidate(candidate)
                                              .then(function () { return console.log("added candidate from receive queue ".concat(candidate.candidate)); })
                                              .catch(function (e) { return console.warn(_this_1.addError("Failure during queued addIceCandidate(): ".concat(e.message), false), e); });
                                      });
                                      _this_1.iceCandidatesReceiveQueue = [];
                                  }
                              })
                                  .catch(function (e) { return console.warn('Failed to setRemoteDescription: (' + desc + '):' + e); })];
                      case 4:
                          _a.sent();
                          _a.label = 5;
                      case 5: return [2 /*return*/];
                  }
              });
          });
      };
      SignalRVideoPlayer.prototype.setCandidate = function (candidateContainerDto) {
          return __awaiter(this, void 0, void 0, function () {
              var candidates, i, cand, iceCand;
              var _this_1 = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          candidates = candidateContainerDto.candidates;
                          if (!(candidates.length > 0)) return [3 /*break*/, 6];
                          i = 0;
                          _a.label = 1;
                      case 1:
                          if (!(i < candidates.length)) return [3 /*break*/, 5];
                          cand = candidates[i];
                          iceCand = new RTCIceCandidate({
                              candidate: cand.candidate,
                              sdpMid: cand.sdpMid,
                              sdpMLineIndex: cand.sdpMLineIndex
                          });
                          if (!this.pc.remoteDescription) return [3 /*break*/, 3];
                          console.log("Processing ".concat(i, " from ").concat(candidates.length, " from UPV ").concat(iceCand.candidate));
                          return [4 /*yield*/, this.pc.addIceCandidate(iceCand).catch(function (e) {
                                  console.warn(_this_1.addError("Failure during addIceCandidate(): ".concat(e.message), false), e);
                              })];
                      case 2:
                          _a.sent();
                          return [3 /*break*/, 4];
                      case 3:
                          console.log("Queuing received UPV ".concat(iceCand.candidate));
                          this.iceCandidatesReceiveQueue.push(iceCand);
                          _a.label = 4;
                      case 4:
                          i++;
                          return [3 /*break*/, 1];
                      case 5: return [3 /*break*/, 7];
                      case 6:
                          console.warn('Candidates container is empty!', candidateContainerDto);
                          _a.label = 7;
                      case 7: return [2 /*return*/];
                  }
              });
          });
      };
      SignalRVideoPlayer.prototype.idleLoop = function () {
          return __awaiter(this, void 0, void 0, function () {
              var idleWarning, videoReceivers, track, settings, idleTime, delay;
              var _a, _b, _c, _d, _e;
              return __generator(this, function (_f) {
                  switch (_f.label) {
                      case 0:
                          this.isConnected = true;
                          console.log('starting idle loop');
                          this.connector.logRemoteMessage('remote :::: starting idle loop', StatusLogLevel.Info);
                          idleWarning = false;
                          _f.label = 1;
                      case 1:
                          if (!this.isConnected) return [3 /*break*/, 6];
                          if (!this.isReconnecting) return [3 /*break*/, 3];
                          console.log('waiting for reconnect');
                          return [4 /*yield*/, this.sleep(this.pingInterval)];
                      case 2:
                          _f.sent();
                          this.isReconnecting = false;
                          console.log("Status after trying to reconnect: ".concat((_a = this.pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState));
                          if (((_b = this.pc) === null || _b === void 0 ? void 0 : _b.iceConnectionState) !== 'connected') {
                              this.addError("Status after trying to reconnect ".concat((_c = this.pc) === null || _c === void 0 ? void 0 : _c.iceConnectionState), false);
                              this.forceDisconnect();
                              this.ondisconnect();
                              this.onerror(UiResources.reconnectFailed, this.allErrorMessages);
                              this.isConnected = false;
                          }
                          _f.label = 3;
                      case 3:
                          if (((_d = this.pc) === null || _d === void 0 ? void 0 : _d.iceConnectionState) !== 'connected') {
                              this.isConnected = false;
                              return [3 /*break*/, 6];
                          }
                          videoReceivers = (_e = this.pc.getSenders()) === null || _e === void 0 ? void 0 : _e.filter(function (rcv) { var _a, _b; return ((_b = (_a = rcv.track) === null || _a === void 0 ? void 0 : _a.kind) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === 'video'; });
                          if ((videoReceivers === null || videoReceivers === void 0 ? void 0 : videoReceivers.length) > 0) {
                              track = videoReceivers[0].track;
                              settings = track.getSettings();
                              console.log("-- ".concat(videoReceivers.length, " h: ").concat(settings.height, ", w:").concat(settings.width, ", A/R: ").concat(settings.aspectRatio, ", fps: ").concat(settings.frameRate), settings, track.getConstraints(), track.getSettings());
                          }
                          idleTime = Math.round((Date.now() - this.inputChannelHandlerHandler.lastActivityTime) / 1000);
                          if (this.maxClientIdleTime > 0 && idleTime > this.maxClientIdleTime - 30) {
                              if (idleTime > this.maxClientIdleTime) {
                                  this.addError("No mouse movement for ".concat(idleTime, " secs, max idle time ").concat(this.maxClientIdleTime, " secs exceeded"), false);
                                  this.forceDisconnect();
                                  this.ondisconnect();
                                  this.onerror(UiResources.sessionTimeout, this.allErrorMessages);
                                  this.isConnected = false;
                              }
                              else {
                                  delay = this.maxClientIdleTime - idleTime;
                                  // console.log(`client is idle for ${idleTime}, ${idleWarning}`)
                                  if (!idleWarning) {
                                      this.onIdleWarning(delay);
                                  }
                                  idleWarning = true;
                              }
                          }
                          else if (idleWarning) {
                              idleWarning = false;
                              this.onClearIdleWarning();
                          }
                          return [4 /*yield*/, this.connector.sendPing(this.sessionId, this.connectionId)];
                      case 4:
                          _f.sent();
                          return [4 /*yield*/, this.sleep(this.pingInterval)];
                      case 5:
                          _f.sent();
                          return [3 /*break*/, 1];
                      case 6:
                          console.log('idle loop stopped');
                          return [2 /*return*/];
                  }
              });
          });
      };
      SignalRVideoPlayer.prototype.resizeVideo = function () {
          var _this_1 = this;
          this.calculateVideoOrigin();
          var newWidth = this.videoConfigProvider.getVideoElementWidth();
          var newHeight = this.videoConfigProvider.getVideoElementHeight();
          this.sleep(1000).then(function (value) {
              if (newWidth === _this_1.videoConfigProvider.getVideoElementWidth() && newHeight === _this_1.videoConfigProvider.getVideoElementHeight()) {
                  _this_1.sendResizeRequest().then(function () {
                      console.log("resize request sent (".concat(newWidth, "; ").concat(newHeight, ")"));
                  });
              }
          });
      };
      SignalRVideoPlayer.prototype.calculateVideoOrigin = function () {
          var clientRect = this.video.getBoundingClientRect();
          var videoRatio = this.videoWidth / this.videoHeight;
          var clientRatio = clientRect.width / clientRect.height;
          ({ x: this._videoOriginX, y: this._videoOriginY, scale: this._videoScale });
          this._videoScale = Math.max(clientRect.width / this.videoWidth, clientRect.height / this.videoHeight);
          var videoOffsetX = videoRatio > clientRatio ? 0 : (clientRect.width - this.videoWidth * this._videoScale) * 0.5;
          var videoOffsetY = videoRatio > clientRatio ? (clientRect.height - this.videoHeight * this._videoScale) * 0.5 : 0;
          this._videoOriginX = clientRect.left + videoOffsetX;
          this._videoOriginY = clientRect.top + videoOffsetY;
      };
      SignalRVideoPlayer.prototype.failWithStunError = function () {
          var _a, _b;
          var urls = (_b = (_a = this.cfg) === null || _a === void 0 ? void 0 : _a.iceServers) === null || _b === void 0 ? void 0 : _b.map(function (server) { return server.urls.join(', '); }).join(', ');
          var msg = UiResources.stunTurnError;
          var details = "STUN/TURN server URLs: ".concat(urls);
          console.warn("".concat(msg, ": ").concat(this.addError(details, false)));
          this.addError(msg, true);
      };
      SignalRVideoPlayer.prototype.addError = function (message, isCritical) {
          this.allErrorMessages.push(message);
          if (isCritical) {
              this.connector.logRemoteMessage(message, StatusLogLevel.Error);
              this.onerror(message, this.allErrorMessages);
          }
          return message;
      };
      SignalRVideoPlayer.prototype.close = function (logMessage) {
          if (logMessage === void 0) { logMessage = null; }
          if (this.pc) {
              this.updateStatus(logMessage !== null && logMessage !== void 0 ? logMessage : "Closing current peer connection, state was ".concat(this.pc.connectionState), -1);
              this.pc.close();
              this.pc = null;
          }
      };
      SignalRVideoPlayer.prototype.updateStatus = function (msg, status, errorMessage) {
          if (status === void 0) { status = -1; }
          if (errorMessage === void 0) { errorMessage = null; }
          if (msg) {
              console.log('(' + this.instanceCounter + ')' + msg);
          }
          this.onStatusUpdate(msg, status, errorMessage);
      };
      SignalRVideoPlayer.prototype.sendCloseEvent = function () {
          this.connector.sendWindowClosed(this.connector.clientId, this.upvInstanceId);
      };
      SignalRVideoPlayer.prototype.onMediaDeviceMessage = function (request) {
          var _this_1 = this;
          if (request.On === true) {
              this.stopMediaStream();
              console.log('Media stream opening with device id:', request.DeviceId);
              // Constraints
              var useAudio = request.OnlyVideo !== true;
              var w = request.RequestedWidth !== 0 ? request.RequestedWidth : 1280;
              var h = request.RequestedHeight !== 0 ? request.RequestedHeight : 720;
              var videoConstraintSet = {};
              videoConstraintSet.width = { ideal: w };
              videoConstraintSet.height = { ideal: h };
              videoConstraintSet.frameRate = request.FrameRate;
              if (request.DeviceId !== null && request.DeviceId !== undefined) {
                  // empty id use facing mode
                  if (request.DeviceId === '') {
                      videoConstraintSet.facingMode = 'environment';
                  }
                  else {
                      videoConstraintSet.deviceId = request.DeviceId;
                  }
              }
              else {
                  videoConstraintSet.facingMode = 'environment';
              }
              var constraints = {
                  audio: useAudio,
                  video: videoConstraintSet,
              };
              // Navigator
              var error_1 = false;
              var errorMessage_1 = '';
              var trackConstraints_1 = null;
              navigator.mediaDevices.getUserMedia(constraints).then(function (mediaStream) { return __awaiter(_this_1, void 0, void 0, function () {
                  var track;
                  return __generator(this, function (_a) {
                      this.stream = mediaStream;
                      track = mediaStream.getTracks()[0];
                      trackConstraints_1 = track.getSettings();
                      if (this.rtcTrack !== null && this.rtcTrack !== undefined) {
                          console.log('Replacing track.. ', trackConstraints_1, track);
                          this.rtcTrack.replaceTrack(track);
                      }
                      else {
                          console.log('Adding track.. ', trackConstraints_1, track);
                          this.stream.addTrack(track);
                          this.rtcTrack = this.pc.addTrack(track, mediaStream);
                      }
                      return [2 /*return*/];
                  });
              }); }).then(function () { return __awaiter(_this_1, void 0, void 0, function () {
                  var offer;
                  return __generator(this, function (_a) {
                      switch (_a.label) {
                          case 0:
                              console.log('Making renegotiate offer.');
                              return [4 /*yield*/, this.pc.createOffer(this.offerOptions)];
                          case 1:
                              offer = _a.sent();
                              return [4 /*yield*/, this.pc.setLocalDescription(offer)];
                          case 2:
                              _a.sent();
                              return [4 /*yield*/, this.sendOffer(offer, this.upvInstanceId)];
                          case 3:
                              _a.sent();
                              return [2 /*return*/];
                      }
                  });
              }); }).catch(function (reason) { return __awaiter(_this_1, void 0, void 0, function () {
                  return __generator(this, function (_a) {
                      console.log('Error requesting media stream:', reason);
                      error_1 = true;
                      errorMessage_1 = reason.toString();
                      return [2 /*return*/];
                  });
              }); }).then(function () { return __awaiter(_this_1, void 0, void 0, function () {
                  var message;
                  return __generator(this, function (_a) {
                      message = {
                          On: !error_1,
                          RequestedWidth: trackConstraints_1 !== null ? trackConstraints_1.width : 0,
                          RequestedHeight: trackConstraints_1 !== null ? trackConstraints_1.height : 0,
                          ErrorMessage: errorMessage_1,
                      };
                      console.log(message);
                      this.mediaDeviceChannelHandler.sendMessage(JSON.stringify(message), 'MediaDeviceMessage', null);
                      return [2 /*return*/];
                  });
              }); });
          }
          else {
              console.log('Media stream closing.');
              var success = true;
              var error = '';
              try {
                  this.stopMediaStream();
              }
              catch (e) {
                  success = false;
                  error = e;
                  console.log('Error occurred while closing media stream:', e);
              }
              finally {
                  var message = {
                      On: success,
                      ErrorMessage: error
                  };
                  this.mediaDeviceChannelHandler.sendMessage(JSON.stringify(message), 'MediaDeviceMessage', null);
              }
          }
      };
      SignalRVideoPlayer.prototype.stopMediaStream = function () {
          var _this_1 = this;
          if (this.stream !== null && this.stream !== undefined) {
              console.log('Stopping current media stream2.');
              this.stream.getTracks().forEach(function (track, index, array) {
                  _this_1.stream.removeTrack(track);
                  track.stop();
              });
              this.stream = null;
          }
      };
      SignalRVideoPlayer.globalInstanceCounter = 0;
      return SignalRVideoPlayer;
  }());

  var APIConnector = {};

  var Util = {};

  var BaseDataTypes = {};

  Object.defineProperty(BaseDataTypes, "__esModule", { value: true });
  BaseDataTypes.FileTreeState = BaseDataTypes.CatalogSymbol = BaseDataTypes.ProjectionSphere = BaseDataTypes.Quaternion = BaseDataTypes.AttributeTreeNode = BaseDataTypes.IntelliPidDrawingInfo = BaseDataTypes.CustomAttributeSourceDefinition = BaseDataTypes.Definition = BaseDataTypes.Change = BaseDataTypes.ExportCustomAttributes = BaseDataTypes.ChangeSetLine = BaseDataTypes.ChangeSet = BaseDataTypes.FilesTreeObject = BaseDataTypes.TakeScreenshot = BaseDataTypes.SnapCircle = BaseDataTypes.SnapInfo = BaseDataTypes.ProjectInfo = BaseDataTypes.ModelInfo = BaseDataTypes.Instance = BaseDataTypes.ClippingPlane = BaseDataTypes.Color = BaseDataTypes.ObjectColors = BaseDataTypes.BoundsInfo = BaseDataTypes.Bounds = BaseDataTypes.CameraView = BaseDataTypes.Vector4D = BaseDataTypes.Vector3D = BaseDataTypes.Vector2D = void 0;
  class Vector2D {
      constructor(X, Y) {
          this.X = X;
          this.Y = Y;
      }
  }
  BaseDataTypes.Vector2D = Vector2D;
  class Vector3D {
      constructor(X, Y, Z) {
          this.X = X;
          this.Y = Y;
          this.Z = Z;
      }
  }
  BaseDataTypes.Vector3D = Vector3D;
  class Vector4D {
      constructor(X, Y, Z, W) {
          this.X = X;
          this.Y = Y;
          this.Z = Z;
          this.W = W;
      }
  }
  BaseDataTypes.Vector4D = Vector4D;
  class CameraView {
      constructor(Position, Rotation) {
          this.Position = Position;
          this.Rotation = Rotation;
      }
  }
  BaseDataTypes.CameraView = CameraView;
  class Bounds {
  }
  BaseDataTypes.Bounds = Bounds;
  class BoundsInfo {
  }
  BaseDataTypes.BoundsInfo = BoundsInfo;
  class ObjectColors {
      constructor() {
          this.Current = {};
          this.Default = {};
      }
  }
  BaseDataTypes.ObjectColors = ObjectColors;
  class Color {
  }
  BaseDataTypes.Color = Color;
  class ClippingPlane {
  }
  BaseDataTypes.ClippingPlane = ClippingPlane;
  class Instance {
  }
  BaseDataTypes.Instance = Instance;
  class ModelInfo {
  }
  BaseDataTypes.ModelInfo = ModelInfo;
  class ProjectInfo {
  }
  BaseDataTypes.ProjectInfo = ProjectInfo;
  class SnapInfo {
  }
  BaseDataTypes.SnapInfo = SnapInfo;
  class SnapCircle {
  }
  BaseDataTypes.SnapCircle = SnapCircle;
  class TakeScreenshot {
  }
  BaseDataTypes.TakeScreenshot = TakeScreenshot;
  class FilesTreeObject {
  }
  BaseDataTypes.FilesTreeObject = FilesTreeObject;
  class ChangeSet {
  }
  BaseDataTypes.ChangeSet = ChangeSet;
  class ChangeSetLine {
  }
  BaseDataTypes.ChangeSetLine = ChangeSetLine;
  class ExportCustomAttributes {
  }
  BaseDataTypes.ExportCustomAttributes = ExportCustomAttributes;
  class Change extends ChangeSetLine {
  }
  BaseDataTypes.Change = Change;
  class Definition {
  }
  BaseDataTypes.Definition = Definition;
  class CustomAttributeSourceDefinition {
  }
  BaseDataTypes.CustomAttributeSourceDefinition = CustomAttributeSourceDefinition;
  class IntelliPidDrawingInfo {
  }
  BaseDataTypes.IntelliPidDrawingInfo = IntelliPidDrawingInfo;
  class AttributeTreeNode {
  }
  BaseDataTypes.AttributeTreeNode = AttributeTreeNode;
  class Quaternion {
      constructor(X, Y, Z, W) {
          this.X = X;
          this.Y = Y;
          this.Z = Z;
          this.W = W;
      }
      static fromEuler(value) {
          //????
          let roll = value.X;
          let pitch = value.X;
          let yaw = value.X;
          let cr = Math.cos(roll * 0.5);
          let sr = Math.sin(roll * 0.5);
          let cp = Math.cos(pitch * 0.5);
          let sp = Math.sin(pitch * 0.5);
          let cy = Math.cos(yaw * 0.5);
          let sy = Math.sin(yaw * 0.5);
          let q = {
              W: cr * cp * cy + sr * sp * sy,
              X: sr * cp * cy - cr * sp * sy,
              Y: cr * sp * cy + sr * cp * sy,
              Z: cr * cp * sy - sr * sp * cy
          };
          return q;
      }
  }
  BaseDataTypes.Quaternion = Quaternion;
  class ProjectionSphere {
  }
  BaseDataTypes.ProjectionSphere = ProjectionSphere;
  class CatalogSymbol {
  }
  BaseDataTypes.CatalogSymbol = CatalogSymbol;
  class FileTreeState {
  }
  BaseDataTypes.FileTreeState = FileTreeState;

  var ParameterBase = {};

  var hasRequiredParameterBase;

  function requireParameterBase () {
  	if (hasRequiredParameterBase) return ParameterBase;
  	hasRequiredParameterBase = 1;
  	Object.defineProperty(ParameterBase, "__esModule", { value: true });
  	ParameterBase.GetClashesParameter = ParameterBase.FilesTreeCreateCommentParameter = ParameterBase.GetFilesTreeContentParameter = ParameterBase.FilesTreeSetStateParameter = ParameterBase.SetPidSketchToolParameter = ParameterBase.OpenAuthenticationContextParameter = ParameterBase.SetMarkupToolParameter = ParameterBase.PackageCondition = ParameterBase.Package = ParameterBase.PackageFilterParameter = ParameterBase.ApiMetadata = ParameterBase.ApiSerializationContainer = ParameterBase.FilesTreeImportContainerParameter = ParameterBase.ProcessFileParameter = ParameterBase.ExportCustomAttributesParameter = ParameterBase.SetCustomAttributeConfigParameter = ParameterBase.ImportCustomAttributeChangeSetParameter = ParameterBase.LoadCustomAttributeDataFileParameter = ParameterBase.LoadCustomAttributeConfigurationFileParameter = ParameterBase.AttributePoi = ParameterBase.Link = ParameterBase.PoIWithCommentParameter = ParameterBase.PlacePoiParameter = ParameterBase.PlaceObjParameter = ParameterBase.PlacePlyParameter = ParameterBase.PlaceArcParameter = ParameterBase.PlaceTextParameter = ParameterBase.DrawLineParameter = ParameterBase.IntelliClippingDescriptor = ParameterBase.VolumeClippingDescriptor = ParameterBase.ClippingDescriptor = ParameterBase.ParameterBase = void 0;
  	const _1 = requireUtil();
  	let ParameterBase$1 = class ParameterBase {
  	};
  	ParameterBase.ParameterBase = ParameterBase$1;
  	class ClippingDescriptor {
  	}
  	ParameterBase.ClippingDescriptor = ClippingDescriptor;
  	class VolumeClippingDescriptor {
  	}
  	ParameterBase.VolumeClippingDescriptor = VolumeClippingDescriptor;
  	class IntelliClippingDescriptor {
  	}
  	ParameterBase.IntelliClippingDescriptor = IntelliClippingDescriptor;
  	class DrawLineParameter {
  	}
  	ParameterBase.DrawLineParameter = DrawLineParameter;
  	class PlaceTextParameter {
  	}
  	ParameterBase.PlaceTextParameter = PlaceTextParameter;
  	class PlaceArcParameter {
  	}
  	ParameterBase.PlaceArcParameter = PlaceArcParameter;
  	class PlacePlyParameter {
  	}
  	ParameterBase.PlacePlyParameter = PlacePlyParameter;
  	class PlaceObjParameter {
  	}
  	ParameterBase.PlaceObjParameter = PlaceObjParameter;
  	class PlacePoiParameter {
  	}
  	ParameterBase.PlacePoiParameter = PlacePoiParameter;
  	class PoIWithCommentParameter extends PlacePoiParameter {
  	}
  	ParameterBase.PoIWithCommentParameter = PoIWithCommentParameter;
  	class Link {
  	}
  	ParameterBase.Link = Link;
  	class AttributePoi {
  	}
  	ParameterBase.AttributePoi = AttributePoi;
  	class LoadCustomAttributeConfigurationFileParameter {
  	}
  	ParameterBase.LoadCustomAttributeConfigurationFileParameter = LoadCustomAttributeConfigurationFileParameter;
  	class LoadCustomAttributeDataFileParameter {
  	}
  	ParameterBase.LoadCustomAttributeDataFileParameter = LoadCustomAttributeDataFileParameter;
  	class ImportCustomAttributeChangeSetParameter {
  	}
  	ParameterBase.ImportCustomAttributeChangeSetParameter = ImportCustomAttributeChangeSetParameter;
  	class SetCustomAttributeConfigParameter {
  	}
  	ParameterBase.SetCustomAttributeConfigParameter = SetCustomAttributeConfigParameter;
  	class ExportCustomAttributesParameter {
  	}
  	ParameterBase.ExportCustomAttributesParameter = ExportCustomAttributesParameter;
  	class ProcessFileParameter {
  	}
  	ParameterBase.ProcessFileParameter = ProcessFileParameter;
  	class FilesTreeImportContainerParameter {
  	}
  	ParameterBase.FilesTreeImportContainerParameter = FilesTreeImportContainerParameter;
  	class ApiSerializationContainer {
  	}
  	ParameterBase.ApiSerializationContainer = ApiSerializationContainer;
  	class ApiMetadata {
  	}
  	ParameterBase.ApiMetadata = ApiMetadata;
  	class PackageFilterParameter {
  	}
  	ParameterBase.PackageFilterParameter = PackageFilterParameter;
  	class Package {
  	}
  	ParameterBase.Package = Package;
  	/** Please use the static Helper functions to create the Conditions */
  	class PackageCondition {
  	    constructor() {
  	        this.SubConditions = [];
  	    }
  	    /**
  	     * Create a Attribute Condition
  	     */
  	    static createAttributeCondition(mode, key, conditionComparision, value) {
  	        return {
  	            Consolidation: mode,
  	            Type: _1.PackageConditionTypes.Attribute,
  	            Parameters: [key, conditionComparision, value],
  	            SubConditions: []
  	        };
  	    }
  	    /**
  	     * Create a Volume condition that contains a min and max folder
  	     */
  	    static createVolumeCondition(mode, volumeMode, min, max) {
  	        return {
  	            Consolidation: mode,
  	            Type: _1.PackageConditionTypes.Volume,
  	            Parameters: [volumeMode, min.X, min.Y, min.Z, max.X, max.Y, max.Z],
  	            SubConditions: []
  	        };
  	    }
  	    /**
  	     * Create a group Conditions that contains multiple Conditions
  	     */
  	    static createGroupCondition(mode, packageConditions) {
  	        return {
  	            Consolidation: mode,
  	            Type: _1.PackageConditionTypes.Group,
  	            Parameters: [],
  	            SubConditions: packageConditions
  	        };
  	    }
  	    /**
  	     * Create a Intelli Group Condition that supports usage of a radius
  	     */
  	    static createIntelliGroupCondition(mode, packageConditions, radius) {
  	        return {
  	            Consolidation: mode,
  	            Type: _1.PackageConditionTypes.IntelliVolume,
  	            Parameters: [radius],
  	            SubConditions: packageConditions
  	        };
  	    }
  	}
  	ParameterBase.PackageCondition = PackageCondition;
  	class SetMarkupToolParameter {
  	}
  	ParameterBase.SetMarkupToolParameter = SetMarkupToolParameter;
  	class OpenAuthenticationContextParameter {
  	}
  	ParameterBase.OpenAuthenticationContextParameter = OpenAuthenticationContextParameter;
  	class SetPidSketchToolParameter {
  	}
  	ParameterBase.SetPidSketchToolParameter = SetPidSketchToolParameter;
  	class FilesTreeSetStateParameter extends _1.FileTreeState {
  	}
  	ParameterBase.FilesTreeSetStateParameter = FilesTreeSetStateParameter;
  	class GetFilesTreeContentParameter {
  	}
  	ParameterBase.GetFilesTreeContentParameter = GetFilesTreeContentParameter;
  	class FilesTreeCreateCommentParameter {
  	}
  	ParameterBase.FilesTreeCreateCommentParameter = FilesTreeCreateCommentParameter;
  	class GetClashesParameter {
  	}
  	ParameterBase.GetClashesParameter = GetClashesParameter;
  	return ParameterBase;
  }

  var GetSet$1 = {};

  Object.defineProperty(GetSet$1, "__esModule", { value: true });
  GetSet$1.GetSet = GetSet$1.Set = GetSet$1.Get = void 0;
  class Get {
      constructor(getFunction) {
          this.getFunction = getFunction;
      }
      /**
       * Retrieves the value asynchronous
       * @returns
       */
      async get() {
          return this.getFunction();
      }
  }
  GetSet$1.Get = Get;
  let Set$1 = class Set {
      constructor(setFunction) {
          this.setFunction = setFunction;
      }
      /**
       * Sets the Value asynchronous
       * @param value
       * @returns
       */
      async set(value) {
          return this.setFunction(value);
      }
  };
  GetSet$1.Set = Set$1;
  class GetSet {
      constructor(getFunction, setFunction) {
          this.getFunction = getFunction;
          this.setFunction = setFunction;
      }
      /**
       * Retrieves the value asynchronous
       * @returns
       */
      async get() {
          return this.getFunction();
      }
      /**
       * Sets the Value asynchronous
       * @param value
       * @returns
       */
      async set(value) {
          return this.setFunction(value);
      }
  }
  GetSet$1.GetSet = GetSet;

  var Enums = {};

  (function (exports) {
  	Object.defineProperty(exports, "__esModule", { value: true });
  	exports.ExportableOptions = exports.PidSketchToolMode = exports.MarkupMode = exports.ClippingMode = exports.PointOfInterestType = exports.VolumeConditionMode = exports.AttributeConditionComparison = exports.ConsolidationMode = exports.PackageConditionTypes = exports.ApiCommands = exports.ProjectionSphereType = exports.FeatureTypes = exports.CustomAttributeDataType = exports.UpdateModes = exports.SceneType = exports.CombineModes = exports.TargetEnum = void 0;
  	(function (TargetEnum) {
  	    TargetEnum["Undefined"] = "0";
  	    TargetEnum["ThreeD"] = "1";
  	    TargetEnum["Intelli"] = "10";
  	    TargetEnum["Browser"] = "11";
  	})(exports.TargetEnum || (exports.TargetEnum = {}));
  	(function (CombineModes) {
  	    CombineModes["And"] = "AND";
  	    CombineModes["Or"] = "OR";
  	})(exports.CombineModes || (exports.CombineModes = {}));
  	(function (SceneType) {
  	    SceneType["Undefined"] = "0";
  	    SceneType["ThreeD"] = "1";
  	    SceneType["IntelliPid"] = "10";
  	    SceneType["Browser"] = "11";
  	})(exports.SceneType || (exports.SceneType = {}));
  	(function (UpdateModes) {
  	    UpdateModes[UpdateModes["Append"] = 0] = "Append";
  	    UpdateModes[UpdateModes["Full"] = 1] = "Full";
  	})(exports.UpdateModes || (exports.UpdateModes = {}));
  	(function (CustomAttributeDataType) {
  	    CustomAttributeDataType[CustomAttributeDataType["Calculation"] = 0] = "Calculation";
  	    CustomAttributeDataType[CustomAttributeDataType["CodeList"] = 1] = "CodeList";
  	    CustomAttributeDataType[CustomAttributeDataType["FreeText"] = 2] = "FreeText";
  	    CustomAttributeDataType[CustomAttributeDataType["Numeric"] = 3] = "Numeric";
  	    CustomAttributeDataType[CustomAttributeDataType["Unknown"] = 4] = "Unknown";
  	    CustomAttributeDataType[CustomAttributeDataType["Color"] = 5] = "Color";
  	})(exports.CustomAttributeDataType || (exports.CustomAttributeDataType = {}));
  	(function (FeatureTypes) {
  	    FeatureTypes["Unknown"] = "Unknown";
  	    FeatureTypes["Model"] = "Model";
  	    FeatureTypes["Sketch"] = "Sketch";
  	    FeatureTypes["Markup"] = "Markup";
  	    FeatureTypes["IntellipidSketch"] = "IntellipidSketch";
  	    FeatureTypes["AnimationConfiguration"] = "AnimationConfiguration";
  	    FeatureTypes["AnimationDefinition"] = "AnimationDefinition";
  	    FeatureTypes["Catalogue"] = "Catalogue";
  	    FeatureTypes["Symbol"] = "Symbol";
  	    FeatureTypes["MarkupContainer"] = "MarkupContainer";
  	    FeatureTypes["Orm"] = "Orm";
  	    FeatureTypes["Spraying"] = "Spraying";
  	    FeatureTypes["Comment"] = "Comment";
  	    FeatureTypes["View"] = "View";
  	    FeatureTypes["Package"] = "Package";
  	    FeatureTypes["Folder"] = "Folder";
  	    FeatureTypes["CommentSvg"] = "CommentSvg";
  	    FeatureTypes["Screenshot"] = "Screenshot";
  	    FeatureTypes["Photo"] = "Photo";
  	    FeatureTypes["TwoDToThreeD"] = "TwoDToThreeD";
  	    FeatureTypes["PointOfInterest"] = "PointOfInterest";
  	    FeatureTypes["Drawing"] = "Drawing";
  	    FeatureTypes["Files"] = "Files";
  	    FeatureTypes["MeasurementSnapshot"] = "MeasurementSnapshot";
  	    FeatureTypes["IntelliPidLegendPositions"] = "IntelliPidLegendPositions";
  	    FeatureTypes["IsolationPlan"] = "IsolationPlan";
  	    FeatureTypes["CataloguePlacement"] = "CataloguePlacement";
  	    FeatureTypes["DrawingComment"] = "DrawingComment";
  	    FeatureTypes["AppControl"] = "AppControl";
  	    FeatureTypes["Animation"] = "Animation";
  	    FeatureTypes["PIDSketch"] = "PIDSketch";
  	    FeatureTypes["Report"] = "Report";
  	})(exports.FeatureTypes || (exports.FeatureTypes = {}));
  	(function (ProjectionSphereType) {
  	    ProjectionSphereType[ProjectionSphereType["Picture"] = 0] = "Picture";
  	    ProjectionSphereType[ProjectionSphereType["Panorama"] = 1] = "Panorama";
  	})(exports.ProjectionSphereType || (exports.ProjectionSphereType = {}));
  	(function (ApiCommands) {
  	    //Camera
  	    ApiCommands["SetCameraView"] = "SetCameraView";
  	    ApiCommands["GetCameraView"] = "GetCameraView";
  	    ApiCommands["SetClippingPlane"] = "SetClippingPlane";
  	    ApiCommands["SetCameraViewLookAtTarget"] = "SetCameraViewLookAtTarget";
  	    ApiCommands["ResetView"] = "ResetView";
  	    //Filteroperation
  	    ApiCommands["GetObjects"] = "GetObjects";
  	    ApiCommands["GetSelectedObjects"] = "GetSelectedObjects";
  	    ApiCommands["GetObjectsAttributes"] = "GetObjectsAttributes";
  	    ApiCommands["GetObjectsBoundingBox"] = "GetObjectsBoundingBox";
  	    ApiCommands["GetObjectsColors"] = "GetObjectsColors";
  	    ApiCommands["GetObjectsSnapInfo"] = "GetObjectsSnapInfo";
  	    ApiCommands["GetObjectsChangeableAttributes"] = "GetObjectsChangeableAttributes";
  	    ApiCommands["SetAttribute"] = "SetAttribute";
  	    ApiCommands["Select"] = "Select";
  	    ApiCommands["ClearSelection"] = "ClearSelection";
  	    ApiCommands["Fit"] = "Fit";
  	    ApiCommands["Color"] = "Color";
  	    ApiCommands["ClearColor"] = "ClearColor";
  	    ApiCommands["Highlight"] = "Highlight";
  	    ApiCommands["ClearHighlight"] = "ClearHighlight";
  	    ApiCommands["ShowOnly"] = "ShowOnly";
  	    ApiCommands["SetVisibility"] = "SetVisibility";
  	    ApiCommands["GetClippingInfo"] = "GetClippingInfo";
  	    ApiCommands["VolumeClip"] = "VolumeClip";
  	    ApiCommands["VolumeClipByCoordinates"] = "VolumeClipByCoordinates";
  	    ApiCommands["IntelliClip"] = "IntelliClip";
  	    ApiCommands["ClearClipping"] = "ClearClipping";
  	    ApiCommands["SearchFallback"] = "SearchFallback";
  	    ApiCommands["GetIntelliPidRawSvgData"] = "GetIntelliPidRawSvgData";
  	    //Scene3d
  	    //Drawing
  	    ApiCommands["PlaceObj"] = "PlaceObj";
  	    ApiCommands["DrawLine"] = "DrawLine";
  	    ApiCommands["PlaceText"] = "PlaceText";
  	    ApiCommands["PlaceArc"] = "PlaceArc";
  	    ApiCommands["PlacePly"] = "PlacePly";
  	    ApiCommands["DestroyDrawing"] = "DestroyDrawing";
  	    //Model
  	    ApiCommands["GetModelInfo"] = "GetModelInfo";
  	    ApiCommands["GetProjectInfo"] = "GetProjectInfo";
  	    ApiCommands["LoadConfigFile"] = "LoadConfigFile";
  	    ApiCommands["ClearCustomAttributes"] = "ClearCustomAttributes";
  	    ApiCommands["ImportCustomAttributeChangeSet"] = "ImportCustomAttributeChangeset";
  	    ApiCommands["LoadCustomAttributeConfigurationFile"] = "LoadCustomAttributeConfigurationFile";
  	    ApiCommands["LoadCustomAttributeDataFile"] = "LoadCustomAttributeDataFile";
  	    ApiCommands["SetCustomAttributeConfiguration"] = "SetCustomAttributeConfiguration";
  	    ApiCommands["GetCustomAttributeConfiguration"] = "GetCustomAttributeConfiguration";
  	    ApiCommands["ExportCustomAttributes"] = "ExportCustomAttributes";
  	    ApiCommands["GetIntelliPidDrawings"] = "GetIntelliPidDrawings";
  	    ApiCommands["OpenIntelliPidDrawings"] = "OpenIntelliPidDrawings";
  	    ApiCommands["GetProjectionSpheres"] = "GetProjectionSpheres";
  	    ApiCommands["GetCurrentProjectionSphere"] = "GetCurrentProjectionSphere";
  	    ApiCommands["EnterProjectionSphere"] = "EnterProjectionSphere";
  	    ApiCommands["LeaveProjectionSphere"] = "LeaveProjectionSphere";
  	    ApiCommands["GetAllPids"] = "GetAllPids";
  	    ApiCommands["GetOpenPids"] = "GetOpenPids";
  	    ApiCommands["GetActivePid"] = "GetActivePid";
  	    ApiCommands["OpenPid"] = "OpenPid";
  	    ApiCommands["ClosePid"] = "ClosePid";
  	    //Scene
  	    ApiCommands["TakeScreenshot"] = "TakeScreenshot";
  	    ApiCommands["TakeAndSaveScreenShot"] = "TakeAndSaveScreenshot";
  	    ApiCommands["GetTreeConfiguration"] = "GetTreeConfiguration";
  	    ApiCommands["SetTreeConfiguration"] = "SetTreeConfiguration";
  	    ApiCommands["GetVisibleAspects"] = "GetVisibleAspects";
  	    ApiCommands["SetVisibleAspects"] = "SetVisibleAspects";
  	    ApiCommands["LoadColorFile"] = "LoadColorFile";
  	    ApiCommands["LoadLinkFile"] = "LoadLinkFile";
  	    ApiCommands["ClearLinks"] = "ClearLinks";
  	    //FilesTree
  	    ApiCommands["FilesTreeDeleteObject"] = "FilesTreeDeleteObject";
  	    ApiCommands["GetFilesTreeChildren"] = "GetFilesTreeChildren";
  	    ApiCommands["GetFilesTreeSiblings"] = "GetFilesTreeSiblings";
  	    ApiCommands["FilesTreeMoveObject"] = "FilesTreeMoveObject";
  	    ApiCommands["FilesTreeImportContainer"] = "FilesTreeImportContainer";
  	    ApiCommands["GetFilesTreeContent"] = "GetFilesTreeContent";
  	    ApiCommands["FilesTreeGetContainer"] = "FilesTreeGetContainer";
  	    ApiCommands["SetMarkupTool"] = "SetMarkupTool";
  	    ApiCommands["GetIntelliPidElementsHitByMarkup"] = "GetIntelliPidElementsHitByMarkup";
  	    ApiCommands["FilesTreeClose"] = "FilesTreeClose";
  	    ApiCommands["FilesTreeCreateMarkup"] = "FilesTreeCreateMarkup";
  	    ApiCommands["FilesTreeEdit"] = "FilesTreeEdit";
  	    ApiCommands["FilesTreeShow"] = "FilesTreeShow";
  	    ApiCommands["FilesTreeView"] = "FilesTreeView";
  	    ApiCommands["FilesTreeCreateSketch"] = "FilesTreeCreateSketch";
  	    ApiCommands["FilesTreeSetState"] = "FilesTreeSetState";
  	    ApiCommands["FilesTreeGetState"] = "FilesTreeGetState";
  	    ApiCommands["FilesTreeCreateComment"] = "FilesTreeCreateComment";
  	    //Folder
  	    ApiCommands["GetFilesTreeRoot"] = "GetFilesTreeRoot";
  	    ApiCommands["FilesTreeCreateFolder"] = "FilesTreeCreateFolder";
  	    //Poi
  	    ApiCommands["PlacePoi"] = "PlacePoi";
  	    ApiCommands["PlacePoiWithComment"] = "PlacePoiWithComment";
  	    // PidSketch
  	    ApiCommands["SetPidSketchTool"] = "SetPidSketchTool";
  	    //Events
  	    ApiCommands["AddEventCallback"] = "AddEventCallback";
  	    ApiCommands["RemoveEventCallback"] = "RemoveEventCallback";
  	    //Application
  	    ApiCommands["GetLifeCycleState"] = "GetLifeCycleState";
  	    ApiCommands["ShowMessage"] = "ShowMessage";
  	    ApiCommands["FocusViewer"] = "FocusViewer";
  	    ApiCommands["QuitApplication"] = "QuitApplication";
  	    ApiCommands["CacheModel"] = "CacheModel";
  	    ApiCommands["LoadModel"] = "LoadModel";
  	    ApiCommands["DeleteModel"] = "DeleteModel";
  	    ApiCommands["ActivateLicense"] = "ActivateLicense";
  	    ApiCommands["DeactivateLicense"] = "DeactivateLicense";
  	    ApiCommands["LoadFile"] = "LoadFile";
  	    ApiCommands["ProcessFile"] = "ProcessFile";
  	    ApiCommands["LoadSketch"] = "LoadSketch";
  	    ApiCommands["LoadPackageFile"] = "LoadPackageFile";
  	    ApiCommands["ExportPackageFile"] = "ExportPackageFile";
  	    ApiCommands["ClearAuthConfig"] = "ClearAuthConfig";
  	    ApiCommands["SetAuthConfig"] = "SetAuthConfig";
  	    ApiCommands["OpenPath"] = "OpenPath";
  	    ApiCommands["SetLanguage"] = "SetLanguage";
  	    ApiCommands["GetLanguage"] = "GetLanguage";
  	    //Attribute Tree
  	    ApiCommands["GetTreeRootNode"] = "GetTreeRootNode";
  	    ApiCommands["GetTreeFolderChildren"] = "GetTreeFolderChildren";
  	    ApiCommands["GetTreeFolderSiblings"] = "GetTreeFolderSiblings";
  	    ApiCommands["GetTreeNodesOfFolder"] = "GetTreeNodesOfFolder";
  	    ApiCommands["GetTreeStructure"] = "GetTreeStructure";
  	    //Remote
  	    ApiCommands["WfsLoadRemote"] = "WfsLoadRemote";
  	    ApiCommands["GetWfsRemoteContent"] = "GetWfsRemoteContent";
  	    ApiCommands["GetRenderStreamingInfo"] = "GetRenderStreamingInfo";
  	    ApiCommands["WfsClearAttached"] = "WfsClearAttached";
  	    //Authentication
  	    ApiCommands["OpenAuthenticationContext"] = "OpenAuthenticationContext";
  	    ApiCommands["CloseAuthenticationContext"] = "CloseAuthenticationContext";
  	    //PidSketch
  	    ApiCommands["SelectSymbolForPlacement"] = "SelectSymbolForPlacement";
  	    ApiCommands["GetCatalogSymbols"] = "GetCatalogSymbols";
  	    //Clash
  	    ApiCommands["StartClashComputation"] = "StartClashComputation";
  	    ApiCommands["GetClashCandidates"] = "GetClashCandidates";
  	    ApiCommands["GetClashResults"] = "GetClashResults";
  	    ApiCommands["CancelClashComputation"] = "CancelClashComputation";
  	})(exports.ApiCommands || (exports.ApiCommands = {}));
  	(function (PackageConditionTypes) {
  	    PackageConditionTypes["None"] = "None";
  	    PackageConditionTypes["IntelliVolume"] = "IntelliVolume";
  	    PackageConditionTypes["Group"] = "Group";
  	    PackageConditionTypes["Attribute"] = "Attribute";
  	    PackageConditionTypes["Volume"] = "Volume";
  	})(exports.PackageConditionTypes || (exports.PackageConditionTypes = {}));
  	(function (ConsolidationMode) {
  	    ConsolidationMode["Base"] = "Base";
  	    ConsolidationMode["AndNot"] = "AndNot";
  	    ConsolidationMode["Or"] = "Or";
  	    ConsolidationMode["And"] = "And";
  	})(exports.ConsolidationMode || (exports.ConsolidationMode = {}));
  	(function (AttributeConditionComparison) {
  	    AttributeConditionComparison["Equals"] = "==";
  	    AttributeConditionComparison["NotEquals"] = "!=";
  	    AttributeConditionComparison["Like"] = "Like";
  	    AttributeConditionComparison["NotLike"] = "NotLike";
  	})(exports.AttributeConditionComparison || (exports.AttributeConditionComparison = {}));
  	(function (VolumeConditionMode) {
  	    /// <summary>
  	    /// Inside
  	    /// </summary>
  	    VolumeConditionMode["Includes"] = "Includes";
  	    /// <summary>
  	    /// Overlap
  	    /// </summary>
  	    VolumeConditionMode["Overlaps"] = "Overlaps";
  	    /// <summary>
  	    /// Outside overlap
  	    /// </summary>
  	    VolumeConditionMode["NotIncludes"] = "Not Includes";
  	    /// <summary>
  	    /// Outside
  	    /// </summary>
  	    VolumeConditionMode["NotOverlaps"] = "Not Overlaps";
  	})(exports.VolumeConditionMode || (exports.VolumeConditionMode = {}));
  	(function (PointOfInterestType) {
  	    PointOfInterestType[PointOfInterestType["Sphere"] = 0] = "Sphere";
  	    PointOfInterestType[PointOfInterestType["CustomMesh"] = 1] = "CustomMesh";
  	})(exports.PointOfInterestType || (exports.PointOfInterestType = {}));
  	(function (ClippingMode) {
  	    ClippingMode[ClippingMode["None"] = 0] = "None";
  	    ClippingMode[ClippingMode["Volume"] = 1] = "Volume";
  	    ClippingMode[ClippingMode["GridMeasure"] = 2] = "GridMeasure";
  	    ClippingMode[ClippingMode["Intelli"] = 3] = "Intelli";
  	})(exports.ClippingMode || (exports.ClippingMode = {}));
  	(function (MarkupMode) {
  	    MarkupMode[MarkupMode["None"] = 0] = "None";
  	    MarkupMode[MarkupMode["Line"] = 1] = "Line";
  	    MarkupMode[MarkupMode["FreeHand"] = 2] = "FreeHand";
  	    MarkupMode[MarkupMode["Rectangle"] = 3] = "Rectangle";
  	    MarkupMode[MarkupMode["Oval"] = 4] = "Oval";
  	    MarkupMode[MarkupMode["Text"] = 5] = "Text";
  	    MarkupMode[MarkupMode["Erase"] = 6] = "Erase";
  	    MarkupMode[MarkupMode["OrthogonalLine"] = 7] = "OrthogonalLine";
  	    MarkupMode[MarkupMode["Move"] = 8] = "Move";
  	})(exports.MarkupMode || (exports.MarkupMode = {}));
  	(function (PidSketchToolMode) {
  	    // This reflects UPV
  	    PidSketchToolMode[PidSketchToolMode["None"] = 0] = "None";
  	    //Comment = 1,
  	    //BreakLine = 2,
  	    //TextMarker = 3,
  	    PidSketchToolMode[PidSketchToolMode["Routing"] = 4] = "Routing";
  	    PidSketchToolMode[PidSketchToolMode["Rectangle"] = 5] = "Rectangle";
  	    PidSketchToolMode[PidSketchToolMode["Circle"] = 6] = "Circle";
  	    PidSketchToolMode[PidSketchToolMode["Valve"] = 7] = "Valve";
  	    //CustomSymbol = 8,
  	    //IntelliPidLayer = 9,
  	    //Text = 10,
  	    //Copied = 11,
  	    //Legend = 12,
  	    PidSketchToolMode[PidSketchToolMode["Cloud"] = 13] = "Cloud";
  	    //
  	    // These are added extra 
  	    PidSketchToolMode[PidSketchToolMode["BreakLine"] = 99] = "BreakLine";
  	    PidSketchToolMode[PidSketchToolMode["UnBreakLine"] = 100] = "UnBreakLine";
  	    PidSketchToolMode[PidSketchToolMode["Copy"] = 101] = "Copy";
  	    PidSketchToolMode[PidSketchToolMode["Rotate"] = 102] = "Rotate";
  	    PidSketchToolMode[PidSketchToolMode["Undo"] = 103] = "Undo";
  	    PidSketchToolMode[PidSketchToolMode["Redo"] = 104] = "Redo";
  	})(exports.PidSketchToolMode || (exports.PidSketchToolMode = {}));
  	(function (ExportableOptions) {
  	    ExportableOptions[ExportableOptions["Inherit"] = 0] = "Inherit";
  	    ExportableOptions[ExportableOptions["Export"] = 1] = "Export";
  	    ExportableOptions[ExportableOptions["Ignore"] = 2] = "Ignore";
  	})(exports.ExportableOptions || (exports.ExportableOptions = {})); 
  } (Enums));

  var CustomAttributes = {};

  var CaxApiCommand$1 = {};

  Object.defineProperty(CaxApiCommand$1, "__esModule", { value: true });
  CaxApiCommand$1.CaxApiCommand = void 0;
  const Enums_1 = Enums;
  /** @internal */
  class CaxApiCommand {
      constructor(command) {
          this.requestId = 0;
          this.commandParameters = [];
          this.condition = "";
          this.conditionCombineMode = Enums_1.CombineModes.And;
          this.model = "";
          this.target = Enums_1.TargetEnum.ThreeD;
          this.command = command;
      }
      test() {
          this.target;
      }
  }
  CaxApiCommand$1.CaxApiCommand = CaxApiCommand;

  var hasRequiredCustomAttributes;

  function requireCustomAttributes () {
  	if (hasRequiredCustomAttributes) return CustomAttributes;
  	hasRequiredCustomAttributes = 1;
  	Object.defineProperty(CustomAttributes, "__esModule", { value: true });
  	CustomAttributes.CustomAttributes = CustomAttributes.CustomAttributeLegacy = void 0;
  	const APIConnector_1 = requireAPIConnector();
  	const CaxApiCommand_1 = CaxApiCommand$1;
  	const Enums_1 = Enums;
  	/**
  	 * Contains the file variants. These might be made unavailable in future versions and replaced by new commands
  	 * */
  	class CustomAttributeLegacy {
  	    constructor(customAttributes) {
  	        this.customAttributes = customAttributes;
  	    }
  	    async loadCustomAttributeConfigurationFile(file) {
  	        const command = this.customAttributes.createCommand(Enums_1.ApiCommands.LoadCustomAttributeConfigurationFile);
  	        command.commandParameters.push(file);
  	        return await APIConnector_1.Api.get().sendCommand(command);
  	    }
  	    async loadCustomAttributeDataFile(file) {
  	        const command = this.customAttributes.createCommand(Enums_1.ApiCommands.LoadCustomAttributeDataFile);
  	        command.commandParameters.push(file);
  	        return await APIConnector_1.Api.get().sendCommand(command);
  	    }
  	}
  	CustomAttributes.CustomAttributeLegacy = CustomAttributeLegacy;
  	let CustomAttributes$1 = class CustomAttributes {
  	    constructor(model) {
  	        this.model = model;
  	    }
  	    get Legacy() {
  	        return new CustomAttributeLegacy(this);
  	    }
  	    async clearCustomAttributes() {
  	        const command = this.createCommand(Enums_1.ApiCommands.ClearCustomAttributes);
  	        return await APIConnector_1.Api.get().sendCommand(command);
  	    }
  	    async loadCustomAttributeConfigurationBase64(contentBase64) {
  	        const command = this.createCommand(Enums_1.ApiCommands.LoadCustomAttributeConfigurationFile);
  	        command.additionalParameters = {
  	            LoadCustomAttributeConfiguration: {
  	                ContentBase64: contentBase64
  	            }
  	        };
  	        return await APIConnector_1.Api.get().sendCommand(command);
  	    }
  	    async loadCustomAttributeDataBase64(contentBase64) {
  	        const command = this.createCommand(Enums_1.ApiCommands.LoadCustomAttributeDataFile);
  	        command.additionalParameters = {
  	            LoadCustomAttributeDataFile: {
  	                ContentBase64: contentBase64
  	            }
  	        };
  	        return await APIConnector_1.Api.get().sendCommand(command);
  	    }
  	    async importCustomAttributeChangeSet(changeSets, showLoadScreen) {
  	        const command = this.createCommand(Enums_1.ApiCommands.ImportCustomAttributeChangeSet);
  	        command.additionalParameters = {
  	            ImportCustomAttributeChangeSet: {
  	                ShowLoadScreen: showLoadScreen,
  	                ChangeSet: {
  	                    Changes: changeSets
  	                }
  	            }
  	        };
  	        return await APIConnector_1.Api.get().sendCommand(command);
  	    }
  	    async setCustomAttributeConfiguration(definitions, updateMode) {
  	        const command = this.createCommand(Enums_1.ApiCommands.SetCustomAttributeConfiguration);
  	        command.additionalParameters = {
  	            SetCustomAttributeConfiguration: {
  	                GeneralDefinitions: definitions,
  	                UpdateMode: updateMode
  	            }
  	        };
  	        return await APIConnector_1.Api.get().sendCommand(command);
  	    }
  	    async getCustomAttributeConfiguration() {
  	        const command = this.createCommand(Enums_1.ApiCommands.GetCustomAttributeConfiguration);
  	        return (await APIConnector_1.Api.get().sendCommandWithReturnType(command)).ResultData
  	            .GetCustomAttributeConfiguration;
  	    }
  	    async exportCustomAttributes(exportAll) {
  	        const command = this.createCommand(Enums_1.ApiCommands.ExportCustomAttributes);
  	        command.additionalParameters = {
  	            ExportCustomAttributes: {
  	                ExportAllAttributes: exportAll
  	            }
  	        };
  	        return (await APIConnector_1.Api.get().sendCommandWithReturnType(command)).ResultData
  	            .ExportCustomAttributes;
  	    }
  	    createCommand(apiCommands) {
  	        const command = new CaxApiCommand_1.CaxApiCommand(apiCommands);
  	        return command;
  	    }
  	};
  	CustomAttributes.CustomAttributes = CustomAttributes$1;
  	return CustomAttributes;
  }

  var hasRequiredUtil;

  function requireUtil () {
  	if (hasRequiredUtil) return Util;
  	hasRequiredUtil = 1;
  	(function (exports) {
  		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
  		    if (k2 === undefined) k2 = k;
  		    var desc = Object.getOwnPropertyDescriptor(m, k);
  		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
  		      desc = { enumerable: true, get: function() { return m[k]; } };
  		    }
  		    Object.defineProperty(o, k2, desc);
  		}) : (function(o, m, k, k2) {
  		    if (k2 === undefined) k2 = k;
  		    o[k2] = m[k];
  		}));
  		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
  		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  		};
  		Object.defineProperty(exports, "__esModule", { value: true });
  		__exportStar(BaseDataTypes, exports);
  		__exportStar(requireParameterBase(), exports);
  		__exportStar(GetSet$1, exports);
  		__exportStar(Enums, exports);
  		__exportStar(requireCustomAttributes(), exports); 
  	} (Util));
  	return Util;
  }

  var APIConnectorVuplex = {};

  var hasRequiredAPIConnectorVuplex;

  function requireAPIConnectorVuplex () {
  	if (hasRequiredAPIConnectorVuplex) return APIConnectorVuplex;
  	hasRequiredAPIConnectorVuplex = 1;
  	Object.defineProperty(APIConnectorVuplex, "__esModule", { value: true });
  	APIConnectorVuplex.ApiConnectorVuplex = void 0;
  	const APIConnector_1 = requireAPIConnector();
  	/**
  	 * @internal
  	 */
  	class ApiConnectorVuplex {
  	    get available() {
  	        return window.vuplex != null;
  	    }
  	    inIframe() {
  	        try {
  	            return window.self !== window.top;
  	        }
  	        catch (e) {
  	            return true;
  	        }
  	    }
  	    initialize() {
  	        if (this.available) {
  	            this.attachListener();
  	        }
  	        else {
  	            window.addEventListener('vuplexready', this.attachListener);
  	        }
  	        //add another handler for window.message. If we are in an Iframe. window.vuplex is available but the event is not working
  	        if (this.inIframe()) {
  	            console.log("Detected Iframe. Adding additional IFrame Hook");
  	            addEventListener("message", (event) => {
  	                const json = JSON.parse(event.data);
  	                if (json.type == "ApiResponse") {
  	                    APIConnector_1.Api.get().handleEvent(json.message);
  	                }
  	            });
  	        }
  	    }
  	    attachListener() {
  	        window.vuplex.addEventListener('message', (event) => {
  	            const json = JSON.parse(event.data);
  	            if (json.type == "ApiResponse") {
  	                APIConnector_1.Api.get().handleEvent(json.message);
  	            }
  	        });
  	    }
  	    async sendCommand(command) {
  	        window.vuplex.postMessage({
  	            type: 'Command',
  	            message: JSON.stringify(command)
  	        });
  	    }
  	}
  	APIConnectorVuplex.ApiConnectorVuplex = ApiConnectorVuplex;
  	return APIConnectorVuplex;
  }

  var hasRequiredAPIConnector;

  function requireAPIConnector () {
  	if (hasRequiredAPIConnector) return APIConnector;
  	hasRequiredAPIConnector = 1;
  	Object.defineProperty(APIConnector, "__esModule", { value: true });
  	APIConnector.Api = APIConnector.ApiResponseContainer = void 0;
  	const Util_1 = requireUtil();
  	const APIConnectorVuplex_1 = requireAPIConnectorVuplex();
  	const CaxApiCommand_1 = CaxApiCommand$1;
  	class ApiResponseContainer {
  	}
  	APIConnector.ApiResponseContainer = ApiResponseContainer;
  	/**
  	 * @internal
  	 * Dont use the API class unless you know what you are doing. Changes to this class could be undocumented
  	 */
  	class Api {
  	    static get() {
  	        if (this.instance != null) {
  	            return this.instance;
  	        }
  	        this.instance = new Api();
  	        this.instance.initialize();
  	        return this.instance;
  	    }
  	    get AppControlsAvailable() {
  	        var _a;
  	        return ((_a = this.apiConnector) === null || _a === void 0 ? void 0 : _a.available) && this.apiConnector instanceof APIConnectorVuplex_1.ApiConnectorVuplex;
  	    }
  	    get BBVAvailable() {
  	        var _a;
  	        return ((_a = this.apiConnector) === null || _a === void 0 ? void 0 : _a.available) && !(this.apiConnector instanceof APIConnectorVuplex_1.ApiConnectorVuplex);
  	    }
  	    get Available() {
  	        var _a, _b;
  	        return (_b = (_a = this.apiConnector) === null || _a === void 0 ? void 0 : _a.available) !== null && _b !== void 0 ? _b : false;
  	    }
  	    /**
  	     * Sets / replaces the current connector as some connectors like BBV are not yet available at start because peer
  	     * connection needs to be established.
  	     * @param connector to use from now on.
  	     */
  	    registerConnector(connector) {
  	        this.apiConnector = connector;
  	    }
  	    handleEvent(json) {
  	        if (this.debug) {
  	            console.log("recieving response", json);
  	        }
  	        // todo: remove old property name fallback
  	        const asResponse = json;
  	        const requestId = asResponse.RequestId;
  	        const errorCode = asResponse.ErrorCode;
  	        if (requestId in Api.instance.waiting) {
  	            if (errorCode != 0) {
  	                const errorMessage = asResponse.ErrorMessage;
  	                Api.instance.waitingFailure[requestId](errorMessage);
  	                delete Api.instance.waiting[requestId];
  	                delete Api.instance.waitingFailure[requestId];
  	            }
  	            else {
  	                Api.instance.waiting[requestId](json);
  	                delete Api.instance.waiting[requestId];
  	                delete Api.instance.waitingFailure[requestId];
  	            }
  	        }
  	        if (requestId in Api.instance.registeredEvents) {
  	            Api.instance.registeredEvents[requestId](json);
  	        }
  	    }
  	    initialize() {
  	        this.apiConnector = new APIConnectorVuplex_1.ApiConnectorVuplex();
  	        this.apiConnector.initialize();
  	    }
  	    constructor() {
  	        this.waiting = {};
  	        this.waitingFailure = {};
  	        this.registeredEvents = {};
  	    }
  	    async sendCommandInternal(command) {
  	        var requestId = Math.floor(Math.random() * 2147483647);
  	        command.requestId = requestId;
  	        const promise = new Promise((resolve, error) => {
  	            var _a;
  	            this.waiting[requestId] = resolve;
  	            this.waitingFailure[requestId] = error;
  	            if ((_a = this.apiConnector) === null || _a === void 0 ? void 0 : _a.available) {
  	                if (this.debug) {
  	                    console.log('sending command', command);
  	                }
  	                this.apiConnector.sendCommand(command);
  	            }
  	            else {
  	                console.error("No backend available");
  	            }
  	        });
  	        const result = await promise;
  	        return result;
  	    }
  	    async sendCommand(command) {
  	        const result = await this.sendCommandInternal(command);
  	        return result;
  	    }
  	    async sendCommandWithReturnType(command) {
  	        const result = await this.sendCommandInternal(command);
  	        return result;
  	    }
  	    async addEventCallback(event, eventId, callback) {
  	        const command = new CaxApiCommand_1.CaxApiCommand(Util_1.ApiCommands.AddEventCallback);
  	        command.commandParameters.push(event.toString());
  	        command.commandParameters.push(eventId.toString());
  	        this.registeredEvents[eventId] = callback;
  	        return this.sendCommand(command);
  	    }
  	    async removeEventCallback(eventId) {
  	        const command = new CaxApiCommand_1.CaxApiCommand(Util_1.ApiCommands.RemoveEventCallback);
  	        command.commandParameters.push(eventId.toString());
  	        delete this.registeredEvents[eventId];
  	        return this.sendCommand(command);
  	    }
  	}
  	APIConnector.Api = Api;
  	Api.instance = undefined;
  	return APIConnector;
  }

  var APIConnectorExports = requireAPIConnector();

  /**
   * Processes API commands and responses for UPV Web Services via {CommandChannelHandler}.
   */
  var ApiConnectorBBV = /** @class */ (function () {
      function ApiConnectorBBV(commandChannelHandler) {
          this._commandChannelHandler = commandChannelHandler;
      }
      Object.defineProperty(ApiConnectorBBV.prototype, "available", {
          get: function () {
              var _a;
              return (_a = this._commandChannelHandler) === null || _a === void 0 ? void 0 : _a.connected;
          },
          enumerable: false,
          configurable: true
      });
      ApiConnectorBBV.prototype.initialize = function () {
          // check if reset is necessary for example after reconnect
      };
      ApiConnectorBBV.prototype.sendCommand = function (command) {
          return __awaiter(this, void 0, void 0, function () {
              var promise;
              var _this = this;
              return __generator(this, function (_a) {
                  promise = new Promise(function (resolve) {
                      var _a;
                      (_a = _this._commandChannelHandler) === null || _a === void 0 ? void 0 : _a.sendCommand(command).then(function (container) {
                          var json = container.Json;
                          var responseContent = JSON.parse(json);
                          responseContent.RequestId = Number(container.ReferrerId);
                          APIConnectorExports.Api.get().handleEvent(responseContent);
                          resolve();
                      });
                  });
                  return [2 /*return*/, promise];
              });
          });
      };
      return ApiConnectorBBV;
  }());

  var ModelConnector = /** @class */ (function () {
      function ModelConnector(upvWebInterface) {
          this.upvWebInterface = upvWebInterface;
          this.pageTitle = document.title;
      }
      ModelConnector.prototype.getCommandChannelHandler = function () {
          return this.videoPlayer.commandChannelHandler;
      };
      ModelConnector.prototype.startConnectionByModel = function (modelPath, displayName, playerParentElement) {
          var _this = this;
          this.modelPath = modelPath;
          this.displayName = displayName ? displayName : 'Not specified';
          console.log("ModelConnector starting ".concat(this.modelPath), this);
          serverListing.stopPolling();
          this.playerParentElement = playerParentElement;
          if (!modelPath) {
              this.upvWebInterface.onconnectingfailed(UiResources.noModelProvided, null);
              return;
          }
          document.title = "".concat(this.pageTitle, " loading ").concat(modelPath);
          this.upvWebInterface.updateStatusBar(null, 1, null);
          // add video player
          this.videoElement = document.createElement('video');
          this.videoElement.id = 'Video';
          this.videoElement.style.touchAction = 'none';
          if (this.playerParentElement.childElementCount > 0) {
              this.playerParentElement.insertBefore(this.videoElement, this.playerParentElement.children[0]);
          }
          else {
              this.playerParentElement.appendChild(this.videoElement);
          }
          this.setupVideoPlayer(this.videoElement, modelPath).then(function () {
              if (_this.videoPlayer) {
                  _this.videoPlayer.onconnect = function () {
                      _this.upvWebInterface.statusBar.stopLoadingBar();
                      _this.upvWebInterface.statusBar.startFadeOutMode(true);
                      var cancelButton = Array.from(_this.playerParentElement.children).find(function (value) { return value.id === 'disconnectButton'; });
                      if (cancelButton) { // might be null after reconnecting as button was removed before already
                          cancelButton.parentNode.removeChild(cancelButton);
                      }
                      // workaround for timing issues when sending remote API commands immediately after onconnect
                      // sometimes UPV seems to be not ready to process API commands
                      // to solve this both peers should sent an event to each other when ready and not rely on ICE events
                      new Promise(function (resolve) { return setTimeout(resolve, 1000); }).then(function () {
                          _this.raiseOnConnectEvent(modelPath);
                      });
                  };
              }
              else {
                  _this.upvWebInterface.statusBar.stopLoadingBar();
              }
          });
          if (this.upvWebInterface.devMode) {
              // button Cancel (Disconnect)
              var buttonDisconnect = document.createElement('button');
              buttonDisconnect.id = 'disconnectButton';
              buttonDisconnect.innerHTML = 'Cancel ';
              buttonDisconnect.title = modelPath;
              this.playerParentElement.appendChild(buttonDisconnect);
              buttonDisconnect.addEventListener('click', function () {
                  console.log('Button Disconnect clicked');
                  _this.onForceDisconnect();
              });
          }
      };
      ModelConnector.prototype.raiseOnConnectEvent = function (modelPath) {
          var apiConnectorBBV = new ApiConnectorBBV(this.getCommandChannelHandler());
          apiConnectorBBV.initialize();
          APIConnectorExports.Api.get().registerConnector(apiConnectorBBV);
          // execute initial API commands before sending onconnect event to subscribers to ensure display langauge is set
          this.upvWebInterface.createApiCommand('Relay', null, null, this.upvWebInterface.commandsParam, null, 1);
          // this.upvWebInterface.sendApiCommand(cmd, r => console.log('initial command result: ', r));
          this.upvWebInterface.onconnect();
          var event = new Event(this.upvWebInterface.connectedEvent);
          window.dispatchEvent(event);
          document.title = "".concat(this.pageTitle, ": ").concat(modelPath);
          // apiConnectorBBV.Test();
      };
      ModelConnector.prototype.setupVideoPlayer = function (element, modelPath) {
          return __awaiter(this, void 0, void 0, function () {
              var config, instanceId, data, setupErrorMessage;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, serverListing.getIceServersConfig()];
                      case 1:
                          _a.sent();
                          config = serverListing.iceConfig;
                          if (this.upvWebInterface.iceTransportPolicy) {
                              config.iceTransportPolicy = this.upvWebInterface.iceTransportPolicy;
                          }
                          this.videoPlayer = new SignalRVideoPlayer(element, config);
                          this.videoPlayer.videoConfigProvider = this.upvWebInterface.videoConfigProvider;
                          this.videoPlayer.onStatusUpdate = function (msg, status, errorMessage) { return _this.upvWebInterface.updateStatusBar(msg, status, errorMessage); };
                          this.videoPlayer.onIdleWarning = this.upvWebInterface.onshowidlewarning;
                          this.videoPlayer.onClearIdleWarning = this.upvWebInterface.onclearidlewarning;
                          this.videoPlayer.onerror = function (message, previousMessages) {
                              var details = new ErrorDetails();
                              details.allMessages = previousMessages;
                              _this.upvWebInterface.onconnectingfailed(message, details);
                              document.title = "".concat(_this.pageTitle);
                          };
                          window.addEventListener('resize', function (e) {
                              var _a, _b;
                              // On android don't resize when keyboard is open
                              // If input elements gets out of screen during resizing, it loses focus and input doesn't work
                              if (isUserAgentAndroid()) {
                                  if (!isInputTouchKeyboardOpen()) {
                                      (_a = _this.videoPlayer) === null || _a === void 0 ? void 0 : _a.resizeVideo();
                                  }
                              }
                              else {
                                  (_b = _this.videoPlayer) === null || _b === void 0 ? void 0 : _b.resizeVideo();
                              }
                          }, true);
                          window.addEventListener(this.upvWebInterface.customGridResizeEvent, function (evt) {
                              var _a;
                              if (evt === null || evt === void 0 ? void 0 : evt.detail) {
                                  _this.videoPlayer.resizeVideo();
                              }
                              else {
                                  (_a = _this.videoPlayer) === null || _a === void 0 ? void 0 : _a.calculateVideoOrigin();
                              }
                          }, true);
                          window.addEventListener('beforeunload', function (e) {
                              var _a;
                              console.log('Window before unload event');
                              (_a = _this.videoPlayer) === null || _a === void 0 ? void 0 : _a.sendCloseEvent();
                          });
                          instanceId = '';
                          return [4 /*yield*/, serverListing.startInstance(modelPath, function (instance, status, errorMessage) { return _this.upvWebInterface.updateStatusBar(instance, status, errorMessage); })];
                      case 2:
                          data = _a.sent();
                          console.log("response from serverListing.startInstance", data);
                          if (!this.videoPlayer) {
                              // user cancelled
                              this.upvWebInterface.onconnectingfailed('Connect operation cancelled by user', null);
                              return [2 /*return*/];
                          }
                          if (!(data && data.instanceId && data.status === 4)) return [3 /*break*/, 3];
                          instanceId = data.instanceId;
                          console.log("got UPV instance ID ".concat(instanceId));
                          return [3 /*break*/, 5];
                      case 3: return [4 /*yield*/, this.raiseError(data.errorMessage, data.instanceId, true)];
                      case 4:
                          _a.sent();
                          return [2 /*return*/];
                      case 5:
                          this.upvWebInterface.updateStatusBar(null, 4, null);
                          return [4 /*yield*/, this.videoPlayer.setupConnection(instanceId)];
                      case 6:
                          setupErrorMessage = _a.sent();
                          if (!setupErrorMessage) return [3 /*break*/, 8];
                          return [4 /*yield*/, this.raiseError(setupErrorMessage, data.instanceId, false)];
                      case 7:
                          _a.sent();
                          return [2 /*return*/];
                      case 8:
                          this.videoPlayer.ondisconnect = function () {
                              document.title = "".concat(_this.pageTitle);
                              _this.onDisconnect();
                          };
                          registerKeyboardEvents(this.videoPlayer, element);
                          registerMouseEvents(this.videoPlayer, element);
                          registerClipboardEvent(this.videoPlayer);
                          return [2 /*return*/];
                  }
              });
          });
      };
      ModelConnector.prototype.raiseError = function (messageId, instanceId, cancelLoading) {
          return __awaiter(this, void 0, void 0, function () {
              var details, errorMessage;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          details = new ErrorDetails();
                          if (UiResources.hasKey(messageId)) {
                              errorMessage = messageId;
                          }
                          else {
                              details.addError(messageId);
                              errorMessage = messageId;
                          }
                          console.warn("Loading failed: ".concat(messageId, " -> ").concat(errorMessage));
                          if (cancelLoading) {
                              SignalingFactory.connector.cancelLoading(SignalingFactory.connector.clientId, instanceId)
                                  .then(function () { return console.log("Loading cancelled"); })
                                  .catch(function (e) {
                                  console.warn('Exception while trying to fetch active servers: ' + e);
                              });
                          }
                          return [4 /*yield*/, this.onForceDisconnect()];
                      case 1:
                          _a.sent();
                          this.upvWebInterface.onconnectingfailed(errorMessage, details);
                          return [2 /*return*/];
                  }
              });
          });
      };
      ModelConnector.prototype.onForceDisconnect = function () {
          return __awaiter(this, void 0, void 0, function () {
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          console.log('onForceDisconnect', this.videoPlayer);
                          if (!this.videoPlayer) return [3 /*break*/, 2];
                          return [4 /*yield*/, this.videoPlayer.forceDisconnect(false)
                                  .then(function (value) { return console.log('onForceDisconnect ready', _this.videoPlayer); })
                                  .catch(function (reason) { return console.warn("onForceDisconnect failed", reason); })];
                      case 1:
                          _a.sent();
                          _a.label = 2;
                      case 2:
                          SignalingFactory.connector.recreateClientId();
                          return [4 /*yield*/, SignalingFactory.connector.registerClientId()];
                      case 3:
                          _a.sent();
                          this.onDisconnect();
                          return [2 /*return*/, true];
                  }
              });
          });
      };
      ModelConnector.prototype.resetVideoPlayer = function () {
          var playerDiv = this.playerParentElement;
          unregisterEvents(this.videoElement);
          clearChildren(playerDiv, 'statusLine');
          this.videoPlayer = null;
      };
      ModelConnector.prototype.onDisconnect = function () {
          this.resetVideoPlayer();
          this.upvWebInterface.statusBar.stopLoadingBar(true);
          this.upvWebInterface.ondisconnect();
          var event = new Event(this.upvWebInterface.disconnectedEvent);
          window.dispatchEvent(event);
      };
      return ModelConnector;
  }());

  /**
   * Default implementation for CAXperts loading screen, used as fallback if no customized screen is provided.
   */
  var DefaultLoadingScreenProvider = /** @class */ (function () {
      /**
       * Prepares but not performs creation of loading screen elements. HTML elements are created on demand in showLoadingScreen():
       * @param parentElement optional parent div element, leave null to create loading screen under body.
       */
      function DefaultLoadingScreenProvider(parentElement) {
          if (parentElement === void 0) { parentElement = null; }
          this.idLoadingScreenDiv = 'loadingScreenDiv';
          this.idLongLoadingDiv = 'loadingScreenLongDiv';
          this.parentElement = parentElement !== null && parentElement !== void 0 ? parentElement : document.body;
      }
      Object.defineProperty(DefaultLoadingScreenProvider.prototype, "longLoadingText", {
          get: function () {
              return this._longLoadingText;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(DefaultLoadingScreenProvider.prototype, "loadingText", {
          get: function () {
              return this._loadingText;
          },
          enumerable: false,
          configurable: true
      });
      DefaultLoadingScreenProvider.prototype.showLoadingScreen = function () {
          var element = document.getElementById(this.idLoadingScreenDiv);
          if (!element) {
              this.create();
          }
          else {
              element.style.display = this.savedStyle;
          }
      };
      DefaultLoadingScreenProvider.prototype.onProgressUpdate = function (message, status, errorMessage) {
          console.log("DefaultLoadingScreenProvider progress update: ".concat(status, ", ").concat(message, ", ").concat(errorMessage));
          var divLongLoading = document.getElementById(this.idLongLoadingDiv);
          if (divLongLoading && status > 1 && status < 4) {
              divLongLoading.style.visibility = 'visible';
          }
          else if (status >= 200) {
              this.hideLoadingScreen();
          }
      };
      DefaultLoadingScreenProvider.prototype.create = function () {
          // taken from https://stackoverflow.com/a/64000817/437283
          var element = function (tag, props) {
              if (props === void 0) { props = {}; }
              return Object.assign(document.createElement(tag), props);
          };
          var append = function (par) {
              var sibs = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                  sibs[_i - 1] = arguments[_i];
              }
              return sibs.reduce(function (p, sib) { return (p.appendChild(sib), p); }, par);
          };
          var imageUrl = url('images/ico-light-upv.png');
          this.loadingScreenDiv = append(element('div', { id: this.idLoadingScreenDiv, style: 'visibility: visible' }), append(element('div', { id: 'loadingScreenRing', className: 'loading-screen_ring' }), element('img', { id: 'imgIcoLight', src: imageUrl, className: 'loading-screen_image', style: 'width: 105px' }), element('span', { id: 'spanRotation', className: 'loading-screen_rotation' })), append(element('div', { id: 'loadingScreenShortDiv' }), element('span', { id: 'loadingScreenText', className: 'loading-screen_subtitle' })), append(element('div', { id: this.idLongLoadingDiv, style: 'visibility: hidden' }), element('span', { id: 'loadingScreenLongText', className: 'loading-screen_subtitle_2' })));
          append(this.parentElement, this.loadingScreenDiv);
          this.loadingScreenDiv = document.getElementById(this.idLoadingScreenDiv);
          this._loadingText = document.getElementById('loadingScreenText');
          this._longLoadingText = document.getElementById('loadingScreenLongText');
          this._loadingText.textContent = 'loading selected model ...';
          this._longLoadingText.textContent = 'Please note that models not preloaded can take longer to load. Please wait ...';
          this.savedStyle = this.loadingScreenDiv.style.display;
          console.log("DefaultLoadingProvider div created under parent", this.parentElement);
      };
      DefaultLoadingScreenProvider.prototype.hideLoadingScreen = function () {
          var element = document.getElementById(this.idLoadingScreenDiv);
          if (element) {
              element.style.display = 'none';
          }
          var divLongLoading = document.getElementById(this.idLongLoadingDiv);
          if (divLongLoading) {
              divLongLoading.style.visibility = 'hidden';
          }
      };
      return DefaultLoadingScreenProvider;
  }());
  /**
   * Very basic implementation that does not show any loading screen. An optional progress update callback can be provided
   * in constructor.
   */
  var DummyLoadingScreenProvider = /** @class */ (function () {
      function DummyLoadingScreenProvider(updateCallback) {
          this.onprogressupdate = updateCallback;
      }
      DummyLoadingScreenProvider.prototype.showLoadingScreen = function () {
      };
      DummyLoadingScreenProvider.prototype.hideLoadingScreen = function () {
      };
      DummyLoadingScreenProvider.prototype.onProgressUpdate = function (message, status, errorMessage) {
          if (this.onprogressupdate) {
              this.onprogressupdate(message, status, errorMessage);
          }
      };
      return DummyLoadingScreenProvider;
  }());

  /**
   * Interface to start a UPV web client session and communicate with a running player.
   */
  var UpvWebInterface = /** @class */ (function () {
      /**
       * Creates an instance. Use method connect() to connect to a UPV.
       * @param upvSignalingBackendUrl needed to listen to event sources if hosted on different servers (CORS).
       */
      function UpvWebInterface(upvSignalingBackendUrl) {
          var _this = this;
          this.statusBar = {};
          this.modelPathParam = getRequestParam('modelPath', null);
          this.clientIdParam = getRequestParam('clientId', null);
          this.commandsParam = getRequestParam('commands', null);
          // currently not used
          this.displayNameParam = getRequestParam('displayName', null);
          this.disconnectedEvent = 'disconnected';
          this.connectedEvent = 'connected';
          this.customGridResizeEvent = 'customgridresize';
          this.ondisconnect = function () { };
          this.onconnect = function () { };
          this.onconnectingfailed = function (message, details) { };
          this.oncustomgridresize = function () { };
          this.onshowidlewarning = function (secondsUntilDisconnect) { return _this.defaultIdleWarning(secondsUntilDisconnect); };
          this.onclearidlewarning = function () { return _this.defaultClearIdleWarning(); };
          // request parameter: autoStart=false can be used in connect.js to suppress direct starting
          this.autoStart = (/(true|1)/i).test(getRequestParam('autoStart', 'true'));
          // request parameter: devMode=true shows status messages in main windows
          this.devMode = (/(true|1)/i).test(getRequestParam('devMode', 'false'));
          this.iceTransportPolicy = getRequestParam('iceTransportPolicy', null);
          if (upvSignalingBackendUrl) {
              setUpvSignalingBackendUrl(upvSignalingBackendUrl);
          }
          else if (window === null || window === void 0 ? void 0 : window.upvSignalingBackendUrl) {
              setUpvSignalingBackendUrl(window === null || window === void 0 ? void 0 : window.upvSignalingBackendUrl);
          }
          this.videoConfigProvider = new DefaultVideoConfigProvider();
          console.log("got params: modelPath=".concat(this.modelPathParam, " backend Url=").concat(upvSignalingBackendUrl, " autoStart=").concat(this.autoStart, " devMode=").concat(this.devMode, " commands=").concat(this.commandsParam));
      }
      /**
       * Set the userInfo retrieved form Identity Server. This will be used in all subsequent requests.
       * @param userInfo from Identity Server containing access and refresh token, will be provided by quickSignin().
       */
      UpvWebInterface.prototype.setUserInfo = function (userInfo) {
          SignalingFactory.connector.setUserInfo(userInfo);
      };
      /**
       * Disables internal OIDC handling and set an access token directly - f.e. when obtained in the embedding application
       * @param accessTokenFn Will be called every time a access token is necessary
       */
      UpvWebInterface.prototype.setAccessTokenCall = function (accessTokenFn) {
          SignalingFactory.connector.setAccessTokenCall(accessTokenFn);
      };
      /**
       * Connect to signaling server and initiate a P2P connection to a UPV running the specified model.
       * If the there is no pre-started UPV having a free slot, an instance will start and load the model first.
       * @param modelPath to use for UPV on graphics server.
       * @param displayName currently not yet used.
       * @param playerParentElement div to use as parent for the HTML video element.
       */
      UpvWebInterface.prototype.connect = function (modelPath, displayName, playerParentElement) {
          var _this = this;
          if (!this.loadingScreenProvider) {
              this.loadingScreenProvider = new DefaultLoadingScreenProvider(playerParentElement);
          }
          SignalingFactory.connector.connectedEvent.on('connected', function (success) {
              if (!success) {
                  _this.loadingScreenProvider.onProgressUpdate('Connection to UPV Web Service lost, waiting for reconnect', 106, 'SignalR network connection down. This may affect the video connection too.');
              }
          });
          playerParentElement.oncontextmenu = function () {
              return false; // cancel default menu
          };
          // (obsolete) access to the status bar including progress indicator
          this.statusBar = new StatusLine(playerParentElement, this.devMode);
          this.loadingScreenProvider.showLoadingScreen();
          if (this.connector) {
              this.connector.onForceDisconnect().then(function () {
                  _this.connector = null;
                  console.log("disconnected from previous session");
                  _this.connector = new ModelConnector(_this);
                  _this.connector.startConnectionByModel(modelPath, displayName, playerParentElement);
                  // NOTE: if UPV instances are recycled (QuitAfterDisconnect=false), time out issues can occur
                  // when UPV instance reports to be ready for reusing but WebRTC is not yet completely reset;
                  // in this case further checking for the WebRTC status might be required
              });
          }
          else {
              this.connector = new ModelConnector(this);
              this.connector.startConnectionByModel(modelPath, displayName, playerParentElement);
          }
      };
      /**
       * Stops the current video session to UPV
       */
      UpvWebInterface.prototype.disconnect = function () {
          var _a;
          (_a = this.connector) === null || _a === void 0 ? void 0 : _a.onForceDisconnect();
          this.connector = null;
      };
      /**
       * Creates an ApiCommand object that is needed for sendApiCommand.
       * @param command string containing the API command name.
       * @param additionalParameters string or null for additional parameters.
       * @param commandParams optional array of parameters depending on the command. For downward compatibility alternatively
       * a string can used where '!' is used as separator.
       * @param condition optional condition to filter the command.
       * @param conditionMode 'AND', 'OR' or null.
       * @param targetMode 1: ThreeD; 10: Intellipid. Fallback is 1.
       * @returns {ApiCommand} command object, never null.
       * @deprecated Use {Application} instead to execute predefined API commands!
       */
      UpvWebInterface.prototype.createApiCommand = function (command, additionalParameters, commandParams, condition, conditionMode, targetMode) {
          return new ApiCommand(command, additionalParameters, ApiCommand.parseCommandString(commandParams), condition, conditionMode, targetMode);
      };
      /**
       * Sends the specified command. The response will be delegated to onApiResponse.
       * @param apiCommand object containing all command information. Should be created by createApiCommand().
       * @param onApiResponse optional callback for response processing. Note that each message has a dedicated response listener.
       * @deprecated Use {Application} instead to execute predefined API commands!
       */
      UpvWebInterface.prototype.sendApiCommand = function (apiCommand, onApiResponse) {
          var _a;
          (_a = this.getCommandChannelHandler()) === null || _a === void 0 ? void 0 : _a.sendApiCommand(apiCommand, onApiResponse);
      };
      /**
       * Sends the specified command asynchronously.
       * @param apiCommand object containing all command information. Should be created by createApiCommand().
       * @return Promise with API response from UPV.
       * @deprecated Use {Application} instead to execute predefined API commands!
       */
      UpvWebInterface.prototype.sendApiCommandAsync = function (apiCommand) {
          var _a;
          return (_a = this.getCommandChannelHandler()) === null || _a === void 0 ? void 0 : _a.sendApiCommandAsync(apiCommand);
      };
      /**
       * Register a collback function for one of the known UPV API events. Remains active until removeEventCallback is
       * called.
       * NOTE that only one handler is supported per event name so that previously registered handlers are replaced.
       * @param eventName e.g. 'SelectionChanged', s. https://www.caxperts.com/help/UniversalPlantViewer%20App/Linking%20and%20API#using-json-via-tcp
       * @param callback when event is fired.
       * @param requestId optional ID to use for registration.
       * @return the request ID, either the one provided as parameter or generated.
       */
      UpvWebInterface.prototype.addEventCallback = function (eventName, callback, requestId) {
          var _a;
          return (_a = this.getCommandChannelHandler()) === null || _a === void 0 ? void 0 : _a.addEventCallback(eventName, callback, requestId);
      };
      /**
       * Remove the API callback event handler by searching for either ID or event name (in this order).
       * @param eventName to lookup if no ID is given.
       * @param requestId under which the event handler is registered.
       */
      UpvWebInterface.prototype.removeEventCallback = function (eventName, requestId) {
          var _a;
          return (_a = this.getCommandChannelHandler()) === null || _a === void 0 ? void 0 : _a.removeEventCallback(eventName, requestId);
      };
      /**
       * Default handler for onshowidlewarning() callback to show a console warnings before an upcoming session timeout
       * if this is configured in UPV.
       * @param secondsUntilDisconnect estimated time until session is closed by server.
       */
      UpvWebInterface.prototype.defaultIdleWarning = function (secondsUntilDisconnect) {
          console.log("Session timeout in ".concat(secondsUntilDisconnect, " seconds"));
          this.statusBar.updateStatus("Session timeout in ".concat(secondsUntilDisconnect, " seconds. Please move your mouse or click"), 5000);
      };
      /**
       * Default handler for onclearidlewarning i.e the user has moved the mouse
       * @param msg can be ignored.
       */
      UpvWebInterface.prototype.defaultClearIdleWarning = function (msg) {
          this.statusBar.clearMessages();
      };
      /**
       * Experts only: Retrieves an internal reference to API command handler.
       * @returns {CommandChannelHandler} or null if not connected.
       */
      UpvWebInterface.prototype.getCommandChannelHandler = function () {
          var _a;
          return (_a = this.connector) === null || _a === void 0 ? void 0 : _a.getCommandChannelHandler();
      };
      UpvWebInterface.prototype.updateStatusBar = function (msg, status, errorMessage) {
          this.loadingScreenProvider.onProgressUpdate(msg, status, errorMessage);
      };
      return UpvWebInterface;
  }());

  exports.AuthenticationService = AuthenticationService;
  exports.DefaultLoadingScreenProvider = DefaultLoadingScreenProvider;
  exports.DefaultVideoConfigProvider = DefaultVideoConfigProvider;
  exports.DummyLoadingScreenProvider = DummyLoadingScreenProvider;
  exports.ErrorDetails = ErrorDetails;
  exports.RedirectStorage = RedirectStorage;
  exports.UiResources = UiResources;
  exports.UpvApiCookies = UpvApiCookies;
  exports.UpvWebInterface = UpvWebInterface;
  exports.addUrlPath = addUrlPath;
  exports.base64toBlob = base64toBlob;
  exports.baseUrl = baseUrl;
  exports.blobToBase64 = blobToBase64;
  exports.checkForApplicationsFolder = checkForApplicationsFolder;
  exports.chunkString = chunkString;
  exports.clamp = clamp;
  exports.clearChildren = clearChildren;
  exports.convertKeysToCSharpStyle = convertKeysToCSharpStyle;
  exports.createRandomInt32 = createRandomInt32;
  exports.extractBaseUrl = extractBaseUrl;
  exports.getRequestParam = getRequestParam;
  exports.getWindowHeight = getWindowHeight;
  exports.getWindowWidth = getWindowWidth;
  exports.hasTouchScreen = hasTouchScreen;
  exports.hashCode = hashCode;
  exports.isUserAgentAndroid = isUserAgentAndroid;
  exports.isUserAgentChrome = isUserAgentChrome;
  exports.isUserAgentIos = isUserAgentIos;
  exports.isUserAgentSafari = isUserAgentSafari;
  exports.loadingbar = loadingbar;
  exports.openFile = openFile;
  exports.quickSignIn = quickSignIn;
  exports.saveToDownload = saveToDownload;
  exports.serverListing = serverListing;
  exports.setUpvSignalingBackendUrl = setUpvSignalingBackendUrl;
  exports.signInPopup = signInPopup;
  exports.signInRedirect = signInRedirect;
  exports.signOutPopup = signOutPopup;
  exports.signalingBasePath = signalingBasePath;
  exports.url = url;
  exports.uuidv4 = uuidv4;

  return exports;

})({});
